name: Check for deployment messages
on:
  issue_comment:
    types: [created]
jobs:
  create_deployment:
    name: Create Deployment
    runs-on: ubuntu-latest
    outputs:
      force: ${{ steps.flags.outputs.force }}
      migrations: ${{ steps.changed_paths.outputs.migrations }}
    steps:
      - uses: khan/pull-request-comment-trigger@master
        id: check
        with:
          trigger: "/deploy"
          reaction: rocket
          prefix_only: true
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
      - uses: actions/github-script@v4
        if: steps.check.outputs.triggered == 'true'
        id: flags
        with:
          script: |
            const comment = context.payload.comment.body;
            const flags = (comment.match(/(--[-\w]+)/g) || []).map((f) => f.replace("--", ""));
            console.log(flags);
            const outputs = [
              // run all deployments regardless of code changes (migrations, client, api)
              "force", 
              // skip unit tests and other required checks
              "skip-checks",
              // skip auto-merging pull request upon successful deployment
              "skip-merge"
            ];
            for (const flag of outputs) {
              if (flags.indexOf(flag) !== -1) {
                core.setOutput(flag, "true");
              } else {
                core.setOutput(flag, "false");
              }
            }
            if (flags.indexOf("skip-checks") !== -1) {
              core.setOutput("required_contexts", "");
            } else {
              core.setOutput("required_contexts", "Test GraphQL API Server,Test React Client");
            }
      - uses: actions/github-script@v4
        if: steps.check.outputs.triggered == 'true'
        id: get_pr_status
        with:
          script: |
            const query = `query ($owner: String!, $repo: String!, $pull_number: Int!) {
              repository(owner: $owner, name: $repo) {
                pullRequest(number: $pull_number) {
                  headRefOid
                }
              }
            }`;

            const variables = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{  github.event.issue.number }}
            }
            const data = await github.graphql(query, variables);
            console.log(data);
            core.setOutput("head_ref", data.repository.pullRequest.headRefOid);
      # TODO: be sure user is allowed to deploy (best handled by environments?)
      # TODO: don't proceed unless contains ref of latest deployment
      - uses: actions/checkout@v2
        if: steps.check.outputs.triggered == 'true'
        with:
          ref: ${{steps.get_pr_status.outputs.head_ref}}
          fetch-depth: 0
      - uses: actions/github-script@v4
        if: steps.check.outputs.triggered == 'true'
        id: deployments
        with:
          script: |
            const query = `query($owner: String!, $repo: String!, $env: [String!]) { 
              repository(owner: $owner, name: $repo) {
                deployments(environments: $env, last: 100) {
                  nodes {
                    id
                    createdAt
                    state
                    commitOid
                    commit {
                      oid
                      associatedPullRequests(first: 2) {
                        nodes {
                          id
                          title
                          number
                        }
                      }
                    }
                  }
                }
              }
            }`;
            const variables = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              env: ['production_client', 'production_server', 'production_db_migrations', 'production']
            }
            const data = await github.graphql(query, variables)
            const lockedStates = ['PENDING', 'QUEUED', 'IN_PROGRESS', 'WAITING'];
            const activeDeployment = data.repository.deployments.nodes.find(({state}) => state == 'ACTIVE');
            const lockingDeployments = data.repository.deployments.nodes.filter(({state}) => lockedStates.indexOf(state) != -1);
            if (activeDeployment) {
              core.setOutput('active_ref', activeDeployment.commitOid);
              core.setOutput('has_active_ref', 'true');
            } else {
              core.setOutput('has_active_ref', 'false');
            }
            if (lockingDeployments.length) {
              core.setOutput('locked', 'true');
              core.setOutput('locked_ref', lockingDeployments[0].commitOid);
            } else {
              core.setOutput('locked', 'false');
            }
            if (lockingDeployments.length) {
              core.setFailed(`Deployments already in progress`);
            }
            console.log('base - activeDeployment commit oid', activeDeployment.commitOid);
            console.log('ref - pr head ref', '${{steps.get_pr_status.outputs.head_ref}}');
            console.log('git sha... ${{github.sha}}');
      - uses: dorny/paths-filter@v2
        if: steps.check.outputs.triggered == 'true'
        name: get changed packages
        id: changed_paths
        with:
          base: ${{ steps.deployments.outputs.active_ref }}
          ref: ${{steps.get_pr_status.outputs.head_ref}}
          list-files: "escape"
          filters: |
            api:
              - 'packages/api/**'
            client:
              - 'packages/client/**'
            migrations:
              - 'packages/api/migrations/committed/**'
            infra:
              - 'packages/infra/**'
            unmanaged_packages:
              - 'packages/!(api|client|infra)/**'
      # - uses: actions/github-script@v4
      #   if: steps.check.outputs.triggered == 'true'
      #   name: create payload
      #   id: payload
      #   with:
      #     script: |
      #       const files = "${{steps.changed_paths.outputs.migrations_files}}";
      #       let numMigrations = 0;
      #       if (files.length > 0) {
      #         numMigrations = files.split(",").length;
      #       }
      #       console.log('steps', ${{toJSON(steps)}})
      #       console.log(`!${{steps.flags.outputs.force}}`, !${{steps.flags.outputs.force}});
      #       const hasClientChanges = "${{steps.changed_paths.outputs.client}}" === 'true';
      #       const hasApiChanges = "${{steps.changed_paths.outputs.api}}" === 'true';
      #       if (!${{steps.flags.outputs.force}} && !hasClientChanges && !hasApiChanges && numMigrations < 1) {
      #         core.setFailed(`Cowardly refusing to create a deployment that has no actionable changes.`);
      #       }

      #       return {
      #         numMigrations,
      #         hasClientChanges,
      #         hasApiChanges,
      #         force: ${{steps.flags.outputs.force}},
      #         skipMerge: ${{steps.flags.outputs['skip-merge']}},
      #         pr: ${{  github.event.issue.number }}
      #       };
      # - uses: avakar/create-deployment@v1
      #   id: create_deployment
      #   if: steps.check.outputs.triggered == 'true'
      #   with:
      #     ref: ${{ steps.get_pr_status.outputs.head_ref }}
      #     payload: ${{toJSON(steps.payload.outputs.result)}}
      #     required_contexts: ${{ steps.flags.outputs.required_contexts}}
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.RELEASER_GITHUB_TOKEN }}
      # - uses: actions/github-script@v4
      #   name: Comment on issue upon failure
      #   if: failure()
      #   with:
      #     script: |
      #       let message = "Create deployment task failed";
      #       if ("${{steps.deployments.conclusion}}" === "failure") {
      #         message = "Deployment failed. There may be another deployment in progress.";
      #       }
      #       if ("${{steps.create_deployment.conclusion}}" === "failure") {
      #         message = "Deployment failed. Have tests passed? Use `--skip-checks` with care if needed.";
      #       }
      #       github.issues.createComment({
      #         issue_number: context.issue.number,
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         body: `:warning: ${message} [View job](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{github.run_id}})`
      #       })
  run_migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    environment: production_db_migrations
    needs:
      - create_deployment
    if: ${{ needs.create_deployment.outputs.migrations || needs.create_deployment.outputs.force }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
      - name: Install unbuffer command
        run: |
          sudo apt-get install expect
      # This remote command must succeed with the message "database migrations complete"
      - name: Run migrations using ecs exec
        run: |
          unbuffer aws ecs execute-command --cluster ${{secrets.MAINTENANCE_STACK}} --task ${{secrets.MAINTENANCE_TASK}} --container Default --command "/bin/sh -l /home/migrate.sh ${{github.sha}}" --interactive | tee /dev/stderr | grep "database migrations complete"
