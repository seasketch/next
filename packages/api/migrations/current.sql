-- Enter migration here

grant execute on function gen_random_uuid to anon;

drop table if exists data_source_types cascade;
create table data_source_types (
  type text primary key,
  description text
);

grant select on data_source_types to anon;

comment on table data_source_types is E'@enum';
insert into data_source_types (type, description) values
  ('vector', 'MapBox GL Style "vector" source'),
  ('raster', 'MapBox GL Style "raster" source'),
  ('raster-dem', 'MapBox GL Style "raster" source'),
  ('geojson', 'MapBox GL Style "geojson" source'),
  ('image', 'MapBox GL Style "image" source'),
  ('video', 'MapBox GL Style "video" source'),
  ('seasketch-vector', 'Combination of geojson and possible vector sources hosted on SeaSketch CND'),
  ('arcgis-dynamic-mapserver', 'Loads dynamic images for the entire viewport from arcgis server'),
  ('arcgis-vector', 'Loads vector data from arcgis server for rendering as a geojson source');


drop type if exists tile_scheme cascade;
create type tile_scheme as enum (
  'xyz',
  'tms'
);

drop type if exists raster_dem_encoding cascade;
create type raster_dem_encoding as enum (
  'mapbox',
  'terrarium'
);

drop table if exists data_source_import_types cascade;
create table data_source_import_types (
  type text primary key,
  description text
);

grant select on data_source_import_types to anon;

comment on table data_source_import_types is E'@enum';
insert into data_source_import_types (type, description) values
  ('arcgis', 'Imported from an arcgis feature layer identified by original_source_url'),
  ('upload', 'Uploaded directly to SeaSketch using GeoJSON or shapefile');


alter table projects drop column if exists data_sources_bucket_id;
-- alter table projects add column data_sources_bucket text not null default 'geojson-1.seasketch-data.org';

drop table if exists data_sources_buckets cascade;
create table data_sources_buckets (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  bucket text not null,
  name text not null,
  region text not null,
  location geometry(point, 4326) not null
);

insert into data_sources_buckets (name, region, bucket, location) values ('Oregon, USA', 'us-west-2', 'geojson-1.seasketch-data.org', ST_GeomFromText('POINT(-119.6313015 45.8511146)', 4326));
insert into data_sources_buckets (name, region, bucket, location) values ('Virginia, USA', 'us-east-1', 'geojson-2.seasketch-data.org', ST_GeomFromText('POINT(-77.15 38.91)', 4326));
insert into data_sources_buckets (name, region, bucket, location) values ('Ireland', 'eu-west-1', 'geojson-3.seasketch-data.org', ST_GeomFromText('POINT(-7.9 52.0)', 4326));
insert into data_sources_buckets (name, region, bucket, location) values ('SÃ£o Paulo', 'sa-east-1', 'geojson-4.seasketch-data.org', ST_GeomFromText('POINT(-47.9 -22.6)', 4326));
insert into data_sources_buckets (name, region, bucket, location) values ('Sydney', 'ap-southeast-2', 'geojson-5.seasketch-data.org', ST_GeomFromText('POINT(150.8 -33.7)', 4326));

grant select on data_sources_buckets to anon;

alter table projects add column data_sources_bucket_id int not null references data_sources_buckets (id) default 1;
CREATE INDEX ON "public"."projects"("data_sources_bucket_id");

GRANT UPDATE(data_sources_bucket_id) ON TABLE public.projects TO seasketch_superuser;
GRANT UPDATE(data_sources_bucket_id) ON TABLE public.projects TO seasketch_user;


drop table if exists data_sources cascade;
create table data_sources (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  type text not null references data_source_types (type) on delete cascade,
  attribution text,
  bounds decimal[4],
  maxzoom int,
  minzoom int,
  -- must be changed to data for geojson
  url text,
  -- raster & vector
  scheme tile_scheme,
  -- raster, vector, and raster-dem
  tiles text[],
  tile_size int check (tile_size = 128 or tile_size = 256 or tile_size = 512),
  -- raster dem
  encoding raster_dem_encoding,
  -- geojson
  buffer int check (buffer >= 0 and buffer <= 512),
  cluster boolean,
  cluster_max_zoom int,
  cluster_properties jsonb,
  cluster_radius int,
  generate_id boolean,
  line_metrics boolean,
  promote_id boolean,
  tolerance decimal,
  -- image & video
  coordinates decimal[4][2],
  -- video
  urls text[],
  -- eventually add tileset & tile job metadata here
  query_parameters jsonb,
  use_device_pixel_ratio boolean,
  import_type text references data_source_import_types (type) on delete cascade,
  original_source_url text,
  enhanced_security boolean,
  bucket_id int references data_sources_buckets (id) on delete cascade,
  object_key uuid
);



CREATE OR REPLACE FUNCTION before_insert_or_update_data_sources_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  declare
    bucket_id text;
  begin
    if new.minzoom is not null and (new.type != 'vector' and new.type != 'raster' and new.type != 'raster-dem' ) then
      raise 'minzoom may only be set for tiled sources (vector, raster, raster-dem)';
    end if;
    if new.coordinates is null and (new.type = 'video' or new.type = 'image') then
      raise 'coordinates must be set on image and video sources';
    end if;
    if new.coordinates is not null and (new.type != 'video' and new.type != 'image') then
      raise 'coordinates property can only be set on image and video sources';
    end if;
    if new.maxzoom is not null and (new.type = 'image' or new.type = 'video') then
      raise 'maxzoom cannot be set for image and video sources';
    end if;
    if new.url is null and (new.type = 'geojson' or new.type = 'image' or new.type = 'arcgis-dynamic-mapserver' or new.type = 'arcgis-vector') then
      raise 'url must be set for "%" sources', (new.type);
    end if;
    if new.scheme is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector') then
      raise 'scheme property is not allowed for "%" sources', (new.type);
    end if;
    if new.tiles is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector' and new.type != 'seasketch-vector') then
      raise 'tiles property is not allowed for "%" sources', (new.type);
    end if;
    if new.encoding is not null and new.type != 'raster-dem' then
      raise 'encoding property only allowed on raster-dem sources';
    end if;
    if new.tile_size is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector') then
      raise 'tile_size property is not allowed for "%" sources', (new.type);
    end if;
    if (new.type != 'geojson' and new.type != 'seasketch-vector') and (new.buffer is not null or new.cluster is not null or new.cluster_max_zoom is not null or new.cluster_properties is not null or new.cluster_radius is not null or new.generate_id is not null or new.line_metrics is not null or new.promote_id is not null or new.tolerance is not null) then
      raise 'geojson props such as buffer, cluster, generate_id, etc not allowed on % sources', (new.type);
    end if;
    if new.urls is not null and new.type != 'video' then
      raise 'urls property not allowed on % sources', (new.type);
    end if;
    if new.query_parameters is not null and (new.type != 'arcgis-vector' and new.type != 'arcgis-dynamic-mapserver') then
      raise 'query_parameters property not allowed on % sources', (new.type);
    end if;
    if new.use_device_pixel_ratio is not null and new.type != 'arcgis-dynamic-mapserver' then
      raise 'use_device_pixel_ratio property not allowed on % sources', (new.type);
    end if;
    if new.import_type is not null and new.type != 'seasketch-vector' then
      raise 'import_type property is only allowed for seasketch-vector sources';
    end if;
    if new.import_type is null and new.type = 'seasketch-vector' then
      raise 'import_type property is required for seasketch-vector sources';
    end if;
    if new.original_source_url is not null and new.type != 'seasketch-vector' then
      raise 'original_source_url may only be set on seasketch-vector sources';
    end if;
    if new.enhanced_security is not null and new.type != 'seasketch-vector' then
      raise 'enhanced_security may only be set on seasketch-vector sources';
    end if;
    if new.type = 'seasketch-vector' then
      new.bucket_id = (select data_sources_bucket_id from projects where id = new.project_id);
      new.object_key = (select gen_random_uuid());
      new.tiles = null;
      new.url = null;
    end if;
    return new;
  end;
$$;

CREATE TRIGGER before_insert_or_update_data_sources
    BEFORE INSERT OR UPDATE ON data_sources
    FOR EACH ROW 
    EXECUTE PROCEDURE before_insert_or_update_data_sources_trigger();

alter table data_sources enable row level security;


comment on column data_sources.id is 'Should be used as sourceId in stylesheets.';
comment on column data_sources.type is 'MapBox GL source type or custom seasketch type.';
comment on column data_sources.attribution is 'Contains an attribution to be displayed when the map is shown to a user.';
comment on column data_sources.bounds is 'An array containing the longitude and latitude of the southwest and northeast corners of the source bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL. This property can also be used as metadata for non-tiled sources.';
comment on column data_sources.maxzoom is 'For Vector, Raster, GeoJSON and Raster DEM sources. Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.';
comment on column data_sources.minzoom is 'For Vector, Raster, and Raster DEM sources. Minimum zoom level for which tiles are available, as in the TileJSON spec.';
comment on column data_sources.url is 'A URL to a TileJSON resource for tiled sources. For GeoJSON or SEASKETCH_VECTOR sources, use this to fill in the data property of the source. Also used by ARCGIS_DYNAMIC_MAPSERVER and ARCGIS_VECTOR';
comment on column data_sources.scheme is 'For MapBox Vector and Raster sources. Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.';
comment on column data_sources.tiles is 'For tiled sources, a list of endpoints that can be used to retrieve tiles.';
comment on column data_sources.tile_size is 'The minimum visual size to display tiles for this layer. Only configurable for raster layers.';
comment on column data_sources.encoding is 'Raster-DEM only. The encoding used by this source. Mapbox Terrain RGB is used by default';
comment on column data_sources.buffer is 'GeoJSON only. Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance.';
comment on column data_sources.cluster is '
GeoJSON only.

If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new Point features in the source with additional properties:

  * cluster Is true if the point is a cluster
  * cluster_id A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://docs.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)
  * point_count Number of original points grouped into this cluster
  * point_count_abbreviated An abbreviated point count
';
comment on column data_sources.cluster_max_zoom is 'GeoJSON only. Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered).';
comment on column data_sources.cluster_properties is 'See [MapBox GL Style docs](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#geojson-clusterProperties).';
comment on column data_sources.cluster_radius is 'GeoJSON only. Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile.';
comment on column data_sources.generate_id is 'GeoJSON only. Whether to generate ids for the geojson features. When enabled, the feature.id property will be auto assigned based on its index in the features array, over-writing any previous values.';
comment on column data_sources.line_metrics is 'GeoJSON only. Whether to calculate line distance metrics. This is required for line layers that specify line-gradient values.';
comment on column data_sources.promote_id is 'GeoJSON only. A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}.`';
comment on column data_sources.tolerance is 'GeoJSON only. Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance).';
comment on column data_sources.coordinates is 'Image sources only. Corners of image specified in longitude, latitude pairs.';
comment on column data_sources.urls is 'Video sources only. URLs to video content in order of preferred format.';
comment on column data_sources.query_parameters is 'ARCGIS_DYNAMIC_MAPSERVER and ARCGIS_VECTOR only. Key-Value object with querystring parameters that will be added to requests.';
comment on column data_sources.use_device_pixel_ratio is 'ARCGIS_DYNAMIC_MAPSERVER only. When using a high-dpi screen, request higher resolution images.';
comment on column data_sources.import_type is 'For SeaSketchVector sources, identifies whether the original source comes from a direct upload or a service location like ArcGIS server';
comment on column data_sources.original_source_url is 'For SeaSketchVector sources, identifies location of original service that hosted the data, if any. This can be used to update a layer with an updated copy of the data source if necessary.';
comment on column data_sources.enhanced_security is 'SEASKETCH_VECTOR sources only. When enabled, uploads will be placed in a different class of storage that requires a temporary security credential to access. Set during creation and cannot be changed.';
comment on column data_sources.bucket_id is 'SEASKETCH_VECTOR sources only. S3 bucket where data are stored. Populated from Project.data_sources_bucket on creation.';
comment on column data_sources.object_key is 'SEASKETCH_VECTOR sources only. S3 object key where data are stored';

CREATE INDEX ON "public"."data_sources"("project_id");

grant select on data_sources to anon;
grant select, insert, delete on data_sources to seasketch_user;
grant update (attribution, maxzoom, minzoom, url, scheme, tiles, tile_size, encoding, buffer, cluster, cluster_max_zoom, cluster_properties, cluster_radius, generate_id, line_metrics, promote_id, tolerance, coordinates, urls, query_parameters, use_device_pixel_ratio) on data_sources to seasketch_user;


comment on table data_sources is '
@omit all
SeaSketch DataSources are analogous to MapBox GL Style sources but are extended
to include new types to support services such as ArcGIS MapServers and content
hosted on the SeaSketch CDN.

When documentation is lacking for any of these properties, consult the [MapBox GL Style docs](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#geojson-promoteId)
';

drop type if exists render_under_type cascade;
create type render_under_type as enum (
  'labels',
  'land',
  'none'
);

drop table if exists data_layers cascade;

create table data_layers (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  data_source_id integer not null references data_sources (id) on delete no action,
  source_layer text,
  sublayer text,
  render_under render_under_type not null default 'labels',
  mapbox_gl_styles jsonb
  -- interactivity_type TBD
);

CREATE INDEX ON "public"."data_layers"("project_id");
CREATE INDEX ON "public"."data_layers"("data_source_id");

CREATE OR REPLACE FUNCTION before_insert_or_update_data_layers_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  declare
    source_type text;
  begin
    select type into source_type from data_sources where id = new.data_source_id;
    if source_type is null then
      raise 'Unknown source type. %', (new.data_source_id);
    end if;
    if new.sublayer is not null and source_type != 'arcgis-dynamic-mapserver' then
      raise 'sublayer property can only be specified for layers associated with a arcgis-dynamic-mapserver source';
    end if;
    if source_type = 'vector' then
      if new.source_layer is null then
        raise 'Layers with "vector" data sources must specify a source_layer';
      end if;
    else
      if new.source_layer is not null then
        raise 'Only Layers with data_sources of type "vector" should specify a source_layer';
      end if;
    end if;
    if (source_type = 'vector' or source_type = 'geojson' or source_type = 'seasketch-vector') then
      if new.mapbox_gl_styles is null then
        raise 'Vector layers must specify mapbox_gl_styles';
      end if;
    else
      if new.mapbox_gl_styles is not null then
        raise 'Layers with data_sources of type % should not specify mapbox_gl_styles', (source_type);
      end if;
    end if;
    return new;
  end;
$$;

CREATE TRIGGER before_insert_or_update_data_layers
    BEFORE INSERT OR UPDATE ON data_layers
    FOR EACH ROW 
    EXECUTE PROCEDURE before_insert_or_update_data_layers_trigger();


grant select on data_layers to anon;
grant all on data_layers to seasketch_user;
alter table data_layers enable row level security;



comment on table data_layers is '
Data layers represent multiple MapBox GL Style layers tied to a single source. 
These layers could also be called "operational layers" in that they are meant to
be overlaid on a basemap.

The layers can appear tied to a TableOfContentsItem or be part of rich features 
associated with a basemap.
';

comment on column data_layers.source_layer is 'For vector tile sources (VECTOR), references the layer inside the vector tiles that this layer applies to.';
comment on column data_layers.sublayer is 'For ARCGIS_MAPSERVER and eventually WMS sources. In this case mapbox_gl_styles is blank and this layer merely controls the display of a single sublayer when making image requests.';
comment on column data_layers.render_under is 'Determines z-ordering of layer in relation to layers in the basemap. For this functionality to work, layers must be identified in the basemap configuration.';
comment on column data_layers.mapbox_gl_styles is '
@name mapboxGLStyles
JSON array of MapBox GL Style layers. Layers should not specify an id or sourceId. These will be automatically generated at runtime.
';

CREATE EXTENSION if not exists ltree;

drop table if exists table_of_contents_items cascade;

create table table_of_contents_items (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  path ltree not null,
  
  stable_id text not null,
  parent_stable_id text,
  
  is_draft boolean not null default true,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  title text not null,
  is_folder boolean not null default true,
  show_radio_children boolean not null default false,
  is_click_off_only boolean not null default false,
  metadata jsonb check (metadata is null or char_length(metadata::text) < 100000),
  bounds decimal[4],
  data_layer_id int unique references data_layers (id)
);

CREATE OR REPLACE FUNCTION before_insert_or_update_table_of_contents_items_trigger() RETURNS trigger
    LANGUAGE plpgsql
    security definer
    AS $$
  begin
    if old.is_folder != new.is_folder then
      raise 'Cannot change is_folder. Create a new table of contents item';
    end if;
    if old.is_draft = false then
      raise 'Cannot alter table of contents items after they are published';
    end if;
    if old is null and new.is_draft = true then -- inserting
      -- verify that stable_id is unique among draft items
      if (select count(id) from table_of_contents_items where stable_id = new.stable_id and is_draft = true) > 0 then
        raise '% is not a unique stable_id.', new.stable_id;
      end if;
      -- set path
      if new.parent_stable_id is null then
        new.path = new.stable_id;
      else
        if (select count(id) from table_of_contents_items where is_draft = true and stable_id = new.parent_stable_id) > 0 then
          -- set path, finding path of parent and appending to it
          new.path = (select path from table_of_contents_items where is_draft = true and stable_id = new.parent_stable_id) || new.stable_id;
        else
          raise 'Cannot find parent item with stable_id=%', new.parent_stable_id;
        end if;
      end if;
    end if;
    if new.is_folder then
      if new.data_layer_id is not null then
        raise 'Folders cannot have data_layer_id set';
      end if;
      if new.metadata is not null then
        raise 'Folders cannot have metadata set';
      end if;
      if new.bounds is not null then
        raise 'Folders cannot have bounds set';
      end if;
    else
      if new.data_layer_id is null then
        raise 'data_layer_id must be set if is_folder=false';
      end if;
      if new.show_radio_children then
        raise 'show_radio_children must be false if is_folder=false';
      end if;
      if new.is_click_off_only then
        raise 'is_click_off_only must be false if is_folder=false';
      end if;
    end if;
    return new;
  end;
$$;

CREATE TRIGGER before_insert_or_update_table_of_contents_items
    BEFORE INSERT OR UPDATE ON table_of_contents_items
    FOR EACH ROW 
    EXECUTE PROCEDURE before_insert_or_update_table_of_contents_items_trigger();

create or replace function update_table_of_contents_item_parent("itemId" int, "parentStableId" text)
  returns table_of_contents_items
  language plpgsql
  security definer
  volatile
  as $$
    declare
      pid int;
      parent_path ltree;
      current_path ltree;
      item table_of_contents_items;
    begin
      select project_id into pid from table_of_contents_items where id = "itemId" and is_draft = true;
      if pid is null then
        raise 'Could not find draft item with id = %', "itemId";
      end if;
      select path into current_path from table_of_contents_items where id = "itemId" and is_draft = true;
      if session_is_admin(pid) = false then
        raise 'Permission denied';
      end if;
      select path into parent_path from table_of_contents_items where is_draft = true and project_id = pid and stable_id = "parentStableId";
      if parent_path is null then
        raise 'Could not find valid parent with stable_id=%', "parentStableId";
      else
        update 
          table_of_contents_items 
        set path = parent_path || subpath(path, nlevel(current_path)-1) 
        where path <@ current_path;
      end if;
      select * into item from table_of_contents_items where id = "itemId";
      return item;
    end;
  $$;

grant execute on function update_table_of_contents_item_parent to seasketch_user;

grant insert (stable_id, parent_stable_id, project_id, title, is_folder, show_radio_children, is_click_off_only,  metadata, bounds, data_layer_id) on table_of_contents_items to seasketch_user;
grant update (title, show_radio_children, is_click_off_only, metadata, bounds, data_layer_id) on table_of_contents_items to seasketch_user;
grant select (path, id, parent_stable_id, is_draft, project_id, title, is_folder, show_radio_children, is_click_off_only, metadata, bounds, data_layer_id, stable_id) on table_of_contents_items to anon;


alter table table_of_contents_items enable row level security;

drop policy if exists table_of_contents_items_admin on table_of_contents_items;
create policy table_of_contents_items_admin on table_of_contents_items for all using (
  session_is_admin(project_id)
) with check (
  session_is_admin(project_id)
);

-- delete from access_control_lists where table_of_contents_item_id is not null;
alter table access_control_lists drop column if exists table_of_contents_item_id;

alter table access_control_lists add column table_of_contents_item_id int unique 
  references table_of_contents_items (id) on delete cascade;

alter table access_control_lists drop constraint if exists
  access_control_list_has_related_model;
alter table access_control_lists add constraint 
  access_control_list_has_related_model check (
    (
        (sketch_class_id is not null)::integer +
        (forum_id_read is not null)::integer +
        (forum_id_write is not null)::integer +
        (table_of_contents_item_id is not null)::integer
    ) = 1
  );

create or replace function create_table_of_contents_item_acl() returns trigger
    security definer
    language plpgsql
    AS $$
begin
  insert into
    access_control_lists(project_id, table_of_contents_item_id, type)
    values(new.project_id, new.id, 'public'::access_control_list_type);
      return new;
end;
$$;

-- Enable the trigger function
create trigger trig_create_table_of_contents_item_acl after insert on table_of_contents_items
  for each row execute function create_table_of_contents_item_acl();

drop policy if exists access_control_lists_update on access_control_lists;

create POLICY "access_control_lists_update" on access_control_lists FOR UPDATE
      TO seasketch_user
      USING ((session_is_admin(( SELECT sketch_classes.project_id
   FROM sketch_classes
  WHERE (sketch_classes.id = access_control_lists.sketch_class_id))) OR session_is_admin(( SELECT forums.project_id
   FROM forums
  WHERE ((forums.id = access_control_lists.forum_id_read) OR (forums.id = access_control_lists.forum_id_write)))))
  OR (
    session_is_admin((select project_id from table_of_contents_items where table_of_contents_items.id = access_control_lists.table_of_contents_item_id))
  )
  
  )
      WITH CHECK ((session_is_admin(( SELECT sketch_classes.project_id
   FROM sketch_classes
  WHERE (sketch_classes.id = access_control_lists.sketch_class_id))) OR session_is_admin(( SELECT forums.project_id
   FROM forums
  WHERE ((forums.id = access_control_lists.forum_id_read) OR (forums.id = access_control_lists.forum_id_write)))))
  or session_is_admin((select project_id from table_of_contents_items where table_of_contents_items.id = access_control_lists.table_of_contents_item_id))
  
  );


create unique index on access_control_lists (table_of_contents_item_id) 
  where table_of_contents_item_id is not null;

create or replace function _session_on_toc_item_acl(lpath ltree)
  returns boolean
  language sql
  stable
  security definer
  as $$
    with test (on_acl) as (select 
      bool_and(session_on_acl(access_control_lists.id)) as bool_and
    from
      access_control_lists
    where
      table_of_contents_item_id in (
        select id from table_of_contents_items where is_draft = false and table_of_contents_items.path @> lpath
      ) and
      type != 'public') select on_acl = true or (on_acl is null and lpath is not null) from test;
  $$;

grant execute on function ltree_isparent to anon;

grant execute on function _session_on_toc_item_acl(ltree) to anon;

-- create or replace function debug_toc_acl(tocid int, project_id int)
--   returns boolean
--   language sql
--   stable
--   security definer
--   as $$
--     -- select session_has_project_access(project_id) and ((select is_draft from table_of_contents_items where id = "tocid"))=false and _session_on_toc_item_acl(((select path from table_of_contents_items where id = "tocid")));
--     with test (on_acl) as (select 
--         bool_and(session_on_acl(access_control_lists.id)) as bool_and
--       from
--         access_control_lists
--       where
--         table_of_contents_item_id in (
--           select id from table_of_contents_items where is_draft = false and table_of_contents_items.path @> ((select path from table_of_contents_items where id = "tocid"))
--         ) and
--         type != 'public') select on_acl = true or on_acl is null from test;
--   $$;

-- grant execute on function debug_toc_acl(int, int) to anon;

drop policy if exists table_of_contents_items_select on table_of_contents_items;
create policy table_of_contents_items_select on table_of_contents_items for select to anon using (
  -- check every acl in the path to this item
  -- this is going to be a very sub-optimal query when attempting to get the 
  -- full list of items
  session_has_project_access(project_id) and is_draft=false and _session_on_toc_item_acl(path)
);





comment on column table_of_contents_items.stable_id is 'Stable id referenced by parent_stable_id and map bookmarks. Also maintains nesting paths when publishing.';
comment on column table_of_contents_items.path is '
@omit
ltree-compatible, period delimited list of ancestor stable_ids
';
comment on column table_of_contents_items.is_draft is 'Identifies whether this item is part of the draft table of contents edited by admin or the static public version';
comment on column table_of_contents_items.title is 'Name used in the table of contents rendering';
comment on column table_of_contents_items.is_folder is 'If not a folder, the item is a layer-type and must have a data_layer_id';
comment on column table_of_contents_items.show_radio_children is 'If set, children of this folder will appear as radio options so that only one may be toggle at a time';
comment on column table_of_contents_items.is_click_off_only is 'If set, folders with this property cannot be toggled in order to activate all their children. Toggles can only be used to toggle children off';
comment on column table_of_contents_items.metadata is 'DraftJS compatible representation of text content to display when a user requests layer metadata. Not valid for Folders';
comment on column table_of_contents_items.bounds is 'If set, users will be able to zoom to the bounds of this item';
comment on column table_of_contents_items.data_layer_id is 'If is_folder=false, a DataLayers visibility will be controlled by this item';


create or replace function publish_table_of_contents("projectId" int)
  returns setof table_of_contents_items
  language plpgsql
  volatile
  security definer
  as $$
    declare
      lid int;
      item table_of_contents_items;
      source_id int;
      copied_source_id int;
      acl_type access_control_list_type;
      acl_id int;
      orig_acl_id int;
      new_toc_id int;
    begin
      -- check permissions
      -- if session_is_admin("projectId") = false then
      --   raise 'Permission denied. Must be a project admin';
      -- end if;
      -- delete existing published table of contents items, layers, and sources
      delete from data_sources where id in (
        select 
          data_source_id 
        from
          data_layers
        inner JOIN
          table_of_contents_items
        on
          data_layers.id = table_of_contents_items.data_layer_id
        where
          table_of_contents_items.project_id = "projectId" and
          is_draft = false
      );
      delete from data_layers where id in (
        select 
          data_layer_id 
        from 
          table_of_contents_items 
        where 
          project_id = "projectId" and
          is_draft = false
      );
      delete from 
        table_of_contents_items 
      where 
        project_id = "projectId" and 
        is_draft = false;

      -- one-by-one, copy related layers and link table of contents items
      for item in 
        select 
          * 
        from 
          table_of_contents_items 
        where 
          is_draft = true and 
          project_id = "projectId"
      loop
        if item.is_folder = false then
          insert into data_layers (
            project_id,
            data_source_id,
            source_layer,
            sublayer,
            render_under,
            mapbox_gl_styles
          )
            select "projectId", 
              data_source_id, 
              source_layer, 
              sublayer, 
              render_under, 
              mapbox_gl_styles from data_layers
            where id = item.data_layer_id
          returning id into lid;
        else
          lid = item.data_layer_id;
        end if;        
        insert into table_of_contents_items (
          is_draft,
          project_id,
          path,
          stable_id,
          parent_stable_id,
          title,
          is_folder,
          show_radio_children,
          is_click_off_only,
          metadata,
          bounds,
          data_layer_id
        ) values (
          false,
          "projectId",
          item.path,
          item.stable_id,
          item.parent_stable_id,
          item.title,
          item.is_folder,
          item.show_radio_children,
          item.is_click_off_only,
          item.metadata,
          item.bounds,
          lid
        ) returning id into new_toc_id;
        select 
          type, id into acl_type, orig_acl_id 
        from 
          access_control_lists 
        where 
          table_of_contents_item_id = (
            select 
              id 
            from 
              table_of_contents_items 
            where is_draft = true and stable_id = item.stable_id
          );
        -- copy access control list settings
        if acl_type != 'public' then
          update 
            access_control_lists 
          set type = acl_type 
          where table_of_contents_item_id = new_toc_id 
          returning id into acl_id;
          if acl_type = 'group' then
            insert into 
              access_control_list_groups (
                access_control_list_id, 
                group_id
              ) 
            select 
              acl_id, 
              group_id 
            from 
              access_control_list_groups 
            where 
              access_control_list_id = orig_acl_id;
          end if;
        end if;
      end loop;
      -- one-by-one, copy related sources and update foreign keys of layers
      for source_id in
        select distinct(data_source_id) from data_layers where id in (
          select 
            data_layer_id 
          from 
            table_of_contents_items 
          where 
            is_draft = false and 
            project_id = "projectId" and 
            is_folder = false
        )
      loop
        -- TODO: This function will have to be updated whenever the schema 
        -- changes since these columns are hard coded... no way around it.
        insert into data_sources (
          project_id,
          type,
          attribution,
          bounds,
          maxzoom,
          minzoom,
          url,
          scheme,
          tiles,
          tile_size,
          encoding,
          buffer,
          cluster,
          cluster_max_zoom,
          cluster_properties,
          cluster_radius,
          generate_id,
          line_metrics,
          promote_id,
          tolerance,
          coordinates,
          urls,
          query_parameters,
          use_device_pixel_ratio,
          import_type,
          original_source_url,
          enhanced_security,
          bucket_id,
          object_key
        )
          select 
            "projectId", 
          type,
          attribution,
          bounds,
          maxzoom,
          minzoom,
          url,
          scheme,
          tiles,
          tile_size,
          encoding,
          buffer,
          cluster,
          cluster_max_zoom,
          cluster_properties,
          cluster_radius,
          generate_id,
          line_metrics,
          promote_id,
          tolerance,
          coordinates,
          urls,
          query_parameters,
          use_device_pixel_ratio,
          import_type,
          original_source_url,
          enhanced_security,
          bucket_id,
          object_key
          from 
            data_sources 
          where
            id = source_id
          returning id into copied_source_id;
        update 
          data_layers 
        set data_source_id = copied_source_id 
        where 
          data_source_id = source_id and
          data_layers.id in ((
            select distinct(data_layer_id) from table_of_contents_items where is_draft = false and 
            project_id = "projectId" and 
            is_folder = false
          ));
      end loop;
      -- return items
      return query select * from table_of_contents_items 
        where project_id = "projectId" and is_draft = false;
    end;
  $$;

grant execute on function publish_table_of_contents to seasketch_user;

drop function if exists delete_table_of_contents_branch(id int);
create or replace function delete_table_of_contents_branch("tableOfContentsItemId" int)
  returns void
  language plpgsql
  volatile
  security definer
  as $$
    declare
      toc_id int;
      root_path ltree;
    begin
      if session_is_admin((select project_id from table_of_contents_items where table_of_contents_items.id = "tableOfContentsItemId")) = false then
        raise 'Permission denied. Must be a project admin';
      end if;
      if (select is_draft from table_of_contents_items where table_of_contents_items.id = "tableOfContentsItemId") = false then
        raise 'Cannot delete published table of contents items';
      end if;
      select path into root_path from table_of_contents_items where table_of_contents_items.id = "tableOfContentsItemId";
      for toc_id in
        select table_of_contents_items.id from table_of_contents_items where root_path @> path and is_draft = true
      loop
        execute _delete_table_of_contents_item(toc_id);
      end loop;
      return;
    end;
  $$;

grant execute on function delete_table_of_contents_branch to seasketch_user;

drop function if exists _delete_table_of_contents_item(tid int);
create or replace function _delete_table_of_contents_item(tid int)
  returns void
  language plpgsql
  volatile
  security definer
  as $$
  declare
    layer_id int;
    source_id int;
    layer_count int;
  begin
    select data_layer_id into layer_id from table_of_contents_items where id = "tid";
    select data_source_id into source_id from data_layers where id = layer_id;
    delete from table_of_contents_items where id = "tid";
    delete from data_layers where id = layer_id;
    if source_id is not null then
      select count(id) into layer_count from data_layers where data_source_id = source_id;
      if layer_count = 0 then
        delete from data_sources where id = source_id;
      end if;
    end if;
    return;
  end;
$$;

drop policy if exists data_layers_admin on data_layers;
drop policy if exists data_layers_select on data_layers;
drop policy if exists data_layers_insert on data_layers;
drop policy if exists data_layers_update on data_layers;
drop policy if exists data_layers_delete on data_layers;

create policy data_layers_select on data_layers for select using (
  session_is_admin(project_id) or _session_on_toc_item_acl((select table_of_contents_items.path from table_of_contents_items where is_draft = false and data_layer_id = data_layers.id))
);

create policy data_layers_insert on data_layers for insert with check (
  session_is_admin(project_id)
);

create policy data_layers_update on data_layers for update using (
  session_is_admin(data_layers.project_id) and (select (select 1 from table_of_contents_items where data_layer_id = data_layers.id and is_draft = false) is null)
) with check (
  session_is_admin(data_layers.project_id)
);

create policy data_layers_delete on data_layers for delete using (
  session_is_admin(project_id)
);


drop policy if exists data_sources_admin on data_sources;
drop policy if exists data_sources_select on data_sources;
drop policy if exists data_sources_insert on data_sources;
drop policy if exists data_sources_update on data_sources;
drop policy if exists data_sources_delete on data_sources;

create policy data_sources_select on data_sources for select using (
  session_is_admin(project_id) or _session_on_toc_item_acl((
    select table_of_contents_items.path from table_of_contents_items where is_draft=false and  data_layer_id = ((
      select data_layers.id from data_layers where data_source_id = data_sources.id
    ))
  ))
);

create policy data_sources_insert on data_sources for insert with check (
  session_is_admin(project_id)
);

create policy data_sources_update on data_sources for update using (
  session_is_admin(project_id) and (select (select 1 from table_of_contents_items where data_layer_id = ((select data_layers.id from data_layers where data_source_id = data_sources.id)) and is_draft = false) is null)
) with check (
  session_is_admin(project_id)
);

create policy data_sources_delete on data_sources for delete using (
  session_is_admin(project_id)
);


