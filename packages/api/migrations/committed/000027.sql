--! Previous: sha1:cd8ee90dd87bceb81b00043cf06dca75bd6a593e
--! Hash: sha1:35823d24a95fd9ce6c2fd8297259163d26a1cf73

-- Enter migration here

alter table table_of_contents_items add column if not exists enable_download boolean not null default true;

grant select(enable_download) on table_of_contents_items to anon;

grant insert(enable_download) on table_of_contents_items to seasketch_user;

grant update(enable_download) on table_of_contents_items to seasketch_user;

drop type if exists cursor_type cascade;
create type cursor_type as enum ('AUTO', 'DEFAULT', 'POINTER', 'CROSSHAIR');
drop type if exists interactivity_type cascade;
create type interactivity_type as enum ('BANNER', 'TOOLTIP', 'POPUP', 'FIXED_BLOCK', 'NONE');

drop table if exists interactivity_settings;

create table interactivity_settings (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  data_source_id integer NOT NULL REFERENCES data_sources (id) ON DELETE CASCADE,
  source_layer text,
  type interactivity_type not null default 'NONE',
  short_template text,
  long_template text,
  cursor cursor_type not null default 'AUTO',
  unique (data_source_id, source_layer)
);

comment on table interactivity_settings is '
@simpleCollections only
@omit all
';

CREATE INDEX interactivity_settings_data_source_id ON interactivity_settings (data_source_id);
CREATE INDEX interactivity_settings_type ON interactivity_settings (type);

grant select on table interactivity_settings to anon;
grant update on table interactivity_settings to seasketch_user;
grant insert on table interactivity_settings to seasketch_user;

alter table interactivity_settings enable row level security;

create policy interactivity_settings_select on interactivity_settings using (session_has_project_access((select project_id from data_sources where id = data_source_id)));
create policy interactivity_settings_admin on interactivity_settings using (session_is_admin((select project_id from data_sources where id = data_source_id))) with check (session_is_admin((select project_id from data_sources where id = data_source_id)));


CREATE or replace FUNCTION public.publish_table_of_contents("projectId" integer) RETURNS SETOF public.table_of_contents_items
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
    declare
      lid int;
      item table_of_contents_items;
      source_id int;
      copied_source_id int;
      acl_type access_control_list_type;
      acl_id int;
      orig_acl_id int;
      new_toc_id int;
    begin
      -- check permissions
      if session_is_admin("projectId") = false then
        raise 'Permission denied. Must be a project admin';
      end if;
      -- delete existing published table of contents items, layers, sources, and interactivity settings
      delete from 
        interactivity_settings 
      where
        data_source_id in (
          select 
            data_source_id 
          from
            data_layers
          inner JOIN
            table_of_contents_items
          on
            data_layers.id = table_of_contents_items.data_layer_id
          where
            table_of_contents_items.project_id = "projectId" and
            is_draft = false
        );

      delete from data_sources where id in (
        select 
          data_source_id 
        from
          data_layers
        inner JOIN
          table_of_contents_items
        on
          data_layers.id = table_of_contents_items.data_layer_id
        where
          table_of_contents_items.project_id = "projectId" and
          is_draft = false
      );
      delete from data_layers where id in (
        select 
          data_layer_id 
        from 
          table_of_contents_items 
        where 
          project_id = "projectId" and
          is_draft = false
      );
      delete from 
        table_of_contents_items 
      where 
        project_id = "projectId" and 
        is_draft = false;

      -- one-by-one, copy related layers and link table of contents items
      for item in 
        select 
          * 
        from 
          table_of_contents_items 
        where 
          is_draft = true and 
          project_id = "projectId"
      loop
        if item.is_folder = false then
          insert into data_layers (
            project_id,
            data_source_id,
            source_layer,
            sublayer,
            render_under,
            mapbox_gl_styles
          )
            select "projectId", 
              data_source_id, 
              source_layer, 
              sublayer, 
              render_under, 
              mapbox_gl_styles from data_layers
            where id = item.data_layer_id
          returning id into lid;
        else
          lid = item.data_layer_id;
        end if;
        -- TODO: this will have to be modified with the addition of any columns
        insert into table_of_contents_items (
          is_draft,
          project_id,
          path,
          stable_id,
          parent_stable_id,
          title,
          is_folder,
          show_radio_children,
          is_click_off_only,
          metadata,
          bounds,
          data_layer_id
        ) values (
          false,
          "projectId",
          item.path,
          item.stable_id,
          item.parent_stable_id,
          item.title,
          item.is_folder,
          item.show_radio_children,
          item.is_click_off_only,
          item.metadata,
          item.bounds,
          lid
        ) returning id into new_toc_id;
        select 
          type, id into acl_type, orig_acl_id 
        from 
          access_control_lists 
        where 
          table_of_contents_item_id = (
            select 
              id 
            from 
              table_of_contents_items 
            where is_draft = true and stable_id = item.stable_id
          );
        -- copy access control list settings
        if acl_type != 'public' then
          update 
            access_control_lists 
          set type = acl_type 
          where table_of_contents_item_id = new_toc_id 
          returning id into acl_id;
          if acl_type = 'group' then
            insert into 
              access_control_list_groups (
                access_control_list_id, 
                group_id
              ) 
            select 
              acl_id, 
              group_id 
            from 
              access_control_list_groups 
            where 
              access_control_list_id = orig_acl_id;
          end if;
        end if;
      end loop;
      -- one-by-one, copy related sources and update foreign keys of layers
      for source_id in
        select distinct(data_source_id) from data_layers where id in (
          select 
            data_layer_id 
          from 
            table_of_contents_items 
          where 
            is_draft = false and 
            project_id = "projectId" and 
            is_folder = false
        )
      loop
        -- TODO: This function will have to be updated whenever the schema 
        -- changes since these columns are hard coded... no way around it.
        insert into data_sources (
          project_id,
          type,
          attribution,
          bounds,
          maxzoom,
          minzoom,
          url,
          scheme,
          tiles,
          tile_size,
          encoding,
          buffer,
          cluster,
          cluster_max_zoom,
          cluster_properties,
          cluster_radius,
          generate_id,
          line_metrics,
          promote_id,
          tolerance,
          coordinates,
          urls,
          query_parameters,
          use_device_pixel_ratio,
          import_type,
          original_source_url,
          enhanced_security,
          bucket_id,
          object_key,
          byte_length
        )
          select 
            "projectId", 
          type,
          attribution,
          bounds,
          maxzoom,
          minzoom,
          url,
          scheme,
          tiles,
          tile_size,
          encoding,
          buffer,
          cluster,
          cluster_max_zoom,
          cluster_properties,
          cluster_radius,
          generate_id,
          line_metrics,
          promote_id,
          tolerance,
          coordinates,
          urls,
          query_parameters,
          use_device_pixel_ratio,
          import_type,
          original_source_url,
          enhanced_security,
          bucket_id,
          object_key,
          byte_length
          from 
            data_sources 
          where
            id = source_id
          returning id into copied_source_id;
        -- copy any interactivity settings
        insert into interactivity_settings (
          data_source_id,
          source_layer,
          type,
          short_template,
          long_template,
          cursor
        ) select
          copied_source_id,
          source_layer,
          type,
          short_template,
          long_template,
          cursor
        from
          interactivity_settings
        where
          data_source_id = source_id;
        -- update data_layers that should now reference the copy
        update 
          data_layers 
        set data_source_id = copied_source_id 
        where 
          data_source_id = source_id and
          data_layers.id in ((
            select distinct(data_layer_id) from table_of_contents_items where is_draft = false and 
            project_id = "projectId" and 
            is_folder = false
          ));
      end loop;
      -- return items
      return query select * from table_of_contents_items 
        where project_id = "projectId" and is_draft = false;
    end;
  $$;

create or replace function after_data_source_insert_create_interaction_settings_trigger() 
  returns trigger 
  security definer
  language plpgsql
  as $$
    begin
      if new.type != 'vector' then
        insert into interactivity_settings (data_source_id) values (new.id);
      end if;
      return new;
    end;
  $$;

DROP TRIGGER IF EXISTS after_data_source_insert_create_interaction_settings ON data_sources;
CREATE TRIGGER after_data_source_insert_create_interaction_settings
    AFTER INSERT ON data_sources
    FOR EACH ROW EXECUTE PROCEDURE after_data_source_insert_create_interaction_settings_trigger();


CREATE or replace FUNCTION public.before_insert_or_update_data_sources_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  declare
    bucket_id text;
  begin
    if new.minzoom is not null and (new.type != 'vector' and new.type != 'raster' and new.type != 'raster-dem' ) then
      raise 'minzoom may only be set for tiled sources (vector, raster, raster-dem)';
    end if;
    if new.coordinates is null and (new.type = 'video' or new.type = 'image') then
      raise 'coordinates must be set on image and video sources';
    end if;
    if new.coordinates is not null and (new.type != 'video' and new.type != 'image') then
      raise 'coordinates property can only be set on image and video sources';
    end if;
    if new.maxzoom is not null and (new.type = 'image' or new.type = 'video') then
      raise 'maxzoom cannot be set for image and video sources';
    end if;
    if new.url is null and (new.type = 'geojson' or new.type = 'image' or new.type = 'arcgis-dynamic-mapserver' or new.type = 'arcgis-vector') then
      raise 'url must be set for "%" sources', (new.type);
    end if;
    if new.scheme is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector') then
      raise 'scheme property is not allowed for "%" sources', (new.type);
    end if;
    if new.tiles is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector' and new.type != 'seasketch-vector') then
      raise 'tiles property is not allowed for "%" sources', (new.type);
    end if;
    if new.encoding is not null and new.type != 'raster-dem' then
      raise 'encoding property only allowed on raster-dem sources';
    end if;
    if new.tile_size is not null and (new.type != 'raster' and new.type != 'raster-dem' and new.type != 'vector') then
      raise 'tile_size property is not allowed for "%" sources', (new.type);
    end if;
    if (new.type != 'geojson' and new.type != 'seasketch-vector') and (new.buffer is not null or new.cluster is not null or new.cluster_max_zoom is not null or new.cluster_properties is not null or new.cluster_radius is not null or new.generate_id is not null or new.line_metrics is not null or new.promote_id is not null or new.tolerance is not null) then
      raise 'geojson props such as buffer, cluster, generate_id, etc not allowed on % sources', (new.type);
    end if;
    if (new.byte_length is not null and new.type != 'seasketch-vector') then
      raise 'byte_length can only be set on seasketch-vector sources';
    end if;
    if (new.type = 'seasketch-vector' and new.byte_length is null) then
      raise 'seasketch-vector sources must have byte_length set to an approximate value';
    end if;
    if new.urls is not null and new.type != 'video' then
      raise 'urls property not allowed on % sources', (new.type);
    end if;
    if new.query_parameters is not null and (new.type != 'arcgis-vector' and new.type != 'arcgis-dynamic-mapserver') then
      raise 'query_parameters property not allowed on % sources', (new.type);
    end if;
    if new.use_device_pixel_ratio is not null and new.type != 'arcgis-dynamic-mapserver' then
      raise 'use_device_pixel_ratio property not allowed on % sources', (new.type);
    end if;
    if new.import_type is not null and new.type != 'seasketch-vector' then
      raise 'import_type property is only allowed for seasketch-vector sources';
    end if;
    if new.import_type is null and new.type = 'seasketch-vector' then
      raise 'import_type property is required for seasketch-vector sources';
    end if;
    if new.original_source_url is not null and new.type != 'seasketch-vector' then
      raise 'original_source_url may only be set on seasketch-vector sources';
    end if;
    if new.enhanced_security is not null and new.type != 'seasketch-vector' then
      raise 'enhanced_security may only be set on seasketch-vector sources';
    end if;
    if old is null and new.type = 'seasketch-vector' then
      new.bucket_id = (select data_sources_bucket_id from projects where id = new.project_id);
      new.object_key = (select gen_random_uuid());
      new.tiles = null;
      new.url = null;
    end if;
    return new;
  end;
$$;

drop type if exists sprite_type cascade;
create type sprite_type as enum (
  'icon', 'fill', 'line'
);

drop table if exists sprites cascade;
create table sprites (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  type sprite_type,
  md5 text not null,
  unique(md5, project_id)
);

drop table if exists sprite_images cascade;
create table sprite_images (
  sprite_id int not null references sprites (id) on delete cascade,
  pixel_ratio int not null default 1,
  width int not null CHECK (width > 0 and width <= 1024),
  height int not null CHECK (height > 0 and height <= 1024),
  url text not null,
  unique(sprite_id, pixel_ratio)
);


drop table if exists data_layers_sprites;

create or replace function data_layers_sprites(l data_layers)
returns setof sprites as $$
  select * from sprites where id in (
      select i::int from (
        select 
          unnest(regexp_matches(l.mapbox_gl_styles::text, 'seasketch://sprites/([^"]+)', 'g')) i 
      ) t)
    ;
$$ language sql stable;

grant execute on function data_layers_sprites to anon;
comment on function data_layers_sprites is '@simpleCollections only';

-- grant all on sprites to seasketch_user;
-- grant all on sprite_images to seasketch_user;
grant select on sprites to anon;
grant select on sprite_images to anon;

alter table sprites enable row level security;
alter table sprite_images enable row level security;

create policy sprites_read on sprites for select using(project_id is null or session_has_project_access(project_id));
create policy sprite_images_read on sprite_images for select using(
  (select project_id from sprites where id = sprite_id) is null or session_has_project_access((select project_id from sprites where id = sprite_id))
);

comment on table sprites is '
@omit all
@simpleCollections only
Image sprites for use in Mapbox GL Styles. The database holds metadata about the sprite, the actual images are in cloud storage referenced by the URL parameter. 
';

comment on table sprite_images is '
@omit all
@simpleCollections only
';

comment on column sprite_images.url is 'Supports multipart Upload operations';
comment on column sprite_images.width is 'Must be <= 1024';
comment on column sprite_images.height is 'Must be <= 1024';
comment on column sprite_images.pixel_ratio is 'Device pixel ratio a copy of this image supports. 2x would be for "retina" devices. Multiple records may point to the same sprite id, but each must have a unique combination of id, pixel_ratio, and data_layer_id.';
comment on column sprites.type is 'Optional. Indicates whether the image is intended for use with particular GL Styles';
comment on column sprites.project_id is 'If unset, sprite will be available for use in all projects';
comment on column sprites.md5 is 'Hash of lowest-dpi image in the set (pixelRatio=1). Useful for de-duplicating symbols that have been imported multiple times';

CREATE INDEX ON sprites (project_id);
CREATE INDEX ON sprite_images (sprite_id);

create or replace function create_sprite("projectId" int, _md5 text, _type sprite_type, _pixel_ratio int, _width int, _height int, _url text) 
  returns sprites
  language plpgsql
  security definer
as $$
  declare
    sprite sprites;
  begin
    if session_is_admin("projectId") = false then
      raise 'Not authorized';
    end if;
    if _pixel_ratio != 1 then
      raise 'New sprites can only be created with an image with a pixel_ratio of 1';
    end if;
    if _url is null then
      raise 'Must be called with a url';
    end if;
    if _md5 is null then
      raise 'Must be called with an md5 hash';
    end if;
    select * into sprite from sprites where sprites.md5 = _md5 limit 1;
    if sprite is null then
      insert into sprites (project_id, type, md5) values ("projectId", _type, _md5) returning * into sprite;
    end if;
    insert into sprite_images (sprite_id, pixel_ratio, width, height, url) values (sprite.id, _pixel_ratio, _width, _height, _url);
    return sprite;
  end;
$$;

grant execute on function create_sprite to seasketch_user;
comment on function create_sprite is '@omit';

create or replace function add_image_to_sprite("spriteId" int, "pixelRatio" int, width int, height int, image text)
  returns sprites
  language plpgsql
  security definer
  as $$
    declare
      sprite sprites;
    begin
    if session_is_admin((select project_id from sprites where id = "spriteId")) then
      insert into sprite_images (sprite_id, pixel_ratio, width, height, url) values ("spriteId", "pixelRatio", width, height, image);
      select * into sprite from sprites where id = "spriteId";
      return sprite;
    else
      raise 'Not authorized';
    end if;
    end;
$$;

grant execute on function add_image_to_sprite to seasketch_user;

comment on function add_image_to_sprite is '@omit';
