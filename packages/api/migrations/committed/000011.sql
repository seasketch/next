--! Previous: sha1:daf005967b8ad7eb22970792274cadfbaf5b0fa1
--! Hash: sha1:3ff56f9cdc6c7bd3afafc300a9f953f5a14a5f42

-- Redefine this to simplify checks
CREATE OR REPLACE FUNCTION session_is_admin("projectId" integer) RETURNS boolean
    LANGUAGE sql SECURITY DEFINER
    AS $$
    select session_is_superuser() or is_admin("projectId", nullif(current_setting('session.user_id', TRUE), '')::integer);
$$;

drop function if exists access_control_lists_groups;
drop table if exists access_control_list_groups;
drop table if exists access_control_lists cascade;
drop type if exists access_control_list_type;

create type access_control_list_type as enum (
  'public',
  'admins_only',
  'group'
);

-- placeholder to test access_control_lists
drop table if exists forums;
create table forums (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  name text not null
);

create index on forums (project_id);

-- Built using this guide: 
-- https://hashrocket.com/blog/posts/modeling-polymorphic-associations-in-a-relational-database#exclusive-belongs-to-aka-exclusive-arc-
create table access_control_lists (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  type access_control_list_type not null default 'public',
  -- TODO: new models utilizing this system will have to be added here
  forum_id int unique references forums (id) on delete cascade
);

-- TODO: update this constraint each time a new model is added
alter table access_control_lists add constraint access_control_list_has_related_model check (((forum_id is not null)::integer) = 1);

-- TODO: create new indexes each time a model is added
create unique index on access_control_lists (forum_id) where forum_id is not null;

-- TODO: triggers should be added for all models to create acls with defaults
CREATE or replace FUNCTION create_forum_acl() RETURNS trigger
    security definer
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO
    access_control_lists(project_id, forum_id, type)
    VALUES(new.project_id, new.id, 'public'::access_control_list_type);
      RETURN new;
END;
$$;

CREATE TRIGGER trig_create_forum_acl AFTER INSERT ON forums 
  FOR EACH ROW EXECUTE FUNCTION create_forum_acl();

create table access_control_list_groups (
  access_control_list_id int not null references access_control_lists (id) on delete cascade,
  group_id int not null references project_groups (id) on delete cascade,
  unique(access_control_list_id, group_id)
);

create index on access_control_list_groups (access_control_list_id);

GRANT select on forums to anon;
GRANT all on forums to seasketch_user;
GRANT select(type, id, forum_id), update (type) on access_control_lists to seasketch_user;
GRANT select on access_control_list_groups to seasketch_user;

COMMENT on table access_control_lists is E'@omit all,many\n@name acl';
comment on column access_control_lists.project_id is E'@omit';
COMMENT on table access_control_list_groups is E'@omit';

-- TODO: check that non-admins can't access acl's groups (through table rls)
create function access_control_lists_groups (acl access_control_lists)
  returns setof project_groups
  language sql
  stable
  as $$
    select * from project_groups where id in (select group_id from access_control_list_groups where access_control_list_id = acl.id)
  $$;

GRANT execute on function access_control_lists_groups to seasketch_user;

COMMENT on function access_control_lists_groups is E'@simpleCollections only';

create or replace function add_group_to_acl ("aclId" int, "groupId" int)
  returns void
  language plpgsql
  security definer
  as $$
    DECLARE
      pid int;
    BEGIN
      select project_id into pid from access_control_lists where id = "aclId";
      if session_is_admin(pid) then
        insert into access_control_list_groups (access_control_list_id, group_id) values ("aclId", "groupId");
      else
        raise exception 'Must be an administrator';
      end if;
    END
  $$;

GRANT execute on function add_group_to_acl to seasketch_user;

create or replace function remove_group_from_acl ("aclId" int, "groupId" int)
  returns void
  language plpgsql
  security definer
  as $$
    DECLARE
      pid int;
    BEGIN
      select project_id into pid from access_control_lists where id = "aclId";
      if session_is_admin(pid) then
        delete from access_control_list_groups where access_control_list_id = "aclId" and group_id = "groupId";
      else
        raise exception 'Must be an administrator';
      end if;
    END
  $$;

GRANT execute on function remove_group_from_acl to seasketch_user;

COMMENT on function remove_group_from_acl is E'Remove a group from a given access control list. Must be an administrator.';
COMMENT on function add_group_to_acl is E'Add a group to a given access control list. Must be an administrator.';

CREATE INDEX ON "public"."access_control_lists"("project_id");
CREATE INDEX ON "public"."access_control_list_groups"("group_id");

DROP function if exists session_on_acl;
CREATE OR REPLACE FUNCTION session_on_acl(acl_id int)
  returns boolean
  language sql
  security definer
  stable
  as $$
    with acl as (
      select type, project_id from access_control_lists where id = acl_id
    )
    select exists(select 1 from acl where type = 'public') or
    session_is_admin((select project_id from access_control_lists where id = acl_id)) or
    (
      exists(select 1 from acl where type = 'group') and 
      current_setting('session.user_id', TRUE) != '' and 
      exists (
        select 1 from access_control_list_groups 
          where access_control_list_id = acl_id and group_id in (
            select group_id from project_group_members where user_id = nullif(current_setting('session.user_id', TRUE), '')::integer
          )
      )
    )
  $$;

GRANT execute on function session_on_acl to anon;
COMMENT on function session_on_acl is E'@omit';

CREATE OR REPLACE FUNCTION it_me("userId" integer) RETURNS boolean
  LANGUAGE sql SECURITY DEFINER
  AS $$
  select nullif(current_setting('session.user_id', TRUE), '')::integer = "userId";
$$;

GRANT execute on function it_me to anon;
comment on function it_me is E'@omit';

alter table forums enable row level security;

drop policy if exists forum_access_policy on forums;
create policy forum_access_select on forums for select to anon using (
  session_on_acl(
    (select id from access_control_lists where forum_id = forums.id)
  )
);

drop policy if exists forum_access_admins on forums;
create policy forum_access_admins on forums for all to seasketch_user 
  using ( session_is_admin(project_id) ) 
  with check ( session_is_admin(project_id));
