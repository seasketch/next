--! Previous: sha1:c5a00be2a63ac9d7c0ce54bbbc5d17fe83469ed3
--! Hash: sha1:caa10561eb38d0000106a791b3aec4b6f8917e03

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
drop table if exists jwks cascade;
create table jwks (
  kid UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  kty text not null default 'RSA',
  e text not null,
  use text not null default 'sig',
  alg text not null default 'RS256',
  n text not null,
  private_pem text not null,
  public_pem text not null,
  created_at timestamp with time zone not null DEFAULT timezone('utc'::text, now()),
  expires_at timestamp with time zone not null DEFAULT timezone('utc'::text, now() + interval '120 days')
);

grant all on jwks to graphile;

comment on table jwks is '
@omit
JSON web key set table. Design guided by https://tools.ietf.org/html/rfc7517
';

grant execute on function uuid_generate_v4 to graphile;

drop type if exists survey_access_type cascade;
create type survey_access_type as enum (
  'PUBLIC',
  'INVITE_ONLY'
);

drop table if exists surveys cascade;
create table surveys (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  name text not null check (char_length(name) <= 255),
  is_disabled boolean not null default true,
  access_type survey_access_type not null default 'PUBLIC',
  limit_to_single_response boolean not null default true,
  geofence geography(POLYGON, 4326) default null,
  show_social_media_buttons boolean default true,
  start_button_text varchar(22) default 'Take the Survey',
  intro_message jsonb not null default '{}'::jsonb check (char_length(intro_message::text) < 100000),
  closing_message jsonb not null default '{}'::jsonb check (char_length(intro_message::text) < 100000)
);

create index on surveys (project_id);

grant select on surveys to anon;
grant all on surveys to seasketch_user;

comment on column surveys.intro_message is 'Shown to users before starting a survey response. Expected to be something like Draft.js content state';
comment on column surveys.closing_message is 'Shown to users after completing a survey. Expected to be something like Draft.js content state';
comment on column surveys.geofence is 'If set, responses that originate from an IP address outside this fence will be flagged.';
comment on column surveys.limit_to_single_response is 'If set, there can only be one response with matching contact information. The app will also discourage multiple submissions from the same browser session.';

drop table if exists survey_invited_groups;
create table survey_invited_groups (
  survey_id integer not null references surveys (id) on delete cascade,
  group_id integer not null references project_groups (id) on delete cascade,
  unique(survey_id, group_id)
);

drop type if exists invite_status cascade;
create type invite_status as enum (
  'UNSENT',
  'QUEUED',
  'SENT',
  'DELIVERED',
  'BOUNCED',
  'COMPLAINT',
  'UNCONFIRMED',
  'CONFIRMED',
  'TOKEN_EXPIRED',
  'ERROR'
);

comment on type invite_status is 'Invite status is derived from feedback notifications coming from the AWS SES email service and token expiration date. See the inviteEmails relation for more details.';

drop type if exists email_status cascade;
create type email_status as enum (
  'QUEUED',
  'SENT',
  'DELIVERED',
  'BOUNCED',
  'COMPLAINT',
  'ERROR'
);


drop table if exists project_invites cascade;
create table project_invites (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  project_id integer NOT NULL REFERENCES projects (id) ON DELETE CASCADE,
  created_at timestamp with time zone not null DEFAULT timezone('utc'::text, now()),
  -- set if user already exists with matching email, or upon registration
  user_id integer references users(id) on delete cascade,
  was_used boolean not null default false,
  fullname text,
  email email not null,
  make_admin boolean not null default false,
  unique(email, project_id)
);

create index project_invites_project_id on project_invites (project_id);

comment on table project_invites is '
@omit all
@simpleCollections only
';

comment on constraint project_invites_project_id_fkey on project_invites is '@omit';

-- create function projects_

grant select on project_invites to seasketch_user;
grant update (fullname, email, make_admin) on project_invites to seasketch_user;
grant delete on project_invites to seasketch_user;

alter table project_invites enable row level security;

grant execute on function texticregexeq(text, text) to anon;
grant execute on function texticregexeq(citext, citext) to anon;
create policy project_invites_admin on project_invites for all to seasketch_user using (session_is_admin(project_id)) with check (session_is_admin(project_id));

drop table if exists project_invite_groups cascade;
create table project_invite_groups (
  invite_id integer not null references project_invites (id),
  group_id integer not null references project_groups (id),
  unique(invite_id, group_id)
);


drop type if exists project_invite_options cascade;
create type project_invite_options as (
  email email,
  fullname text
);

drop type if exists create_project_invites_results;

create or replace function create_project_invites ("projectId" int, "sendEmailNow" boolean, "makeAdmin" boolean, "groupNames" text[], "projectInviteOptions" project_invite_options[])
  returns setof project_invites
  security definer
  language plpgsql
  as $$
    declare
      invite_ids int[];
      invite_id int;
      options project_invite_options;
      i_id int;
      invites project_invites[];
      existing_participants project_participants[];
    begin
      if (select session_is_admin("projectId")) = false then
        raise exception 'Must be project administrator';
      end if;

      with ins as (
        insert into project_invites (
          project_id,
          make_admin,
          email,
          fullname
        ) 
        select 
          "projectId",
          "makeAdmin",
          email, 
          fullname 
        from 
          unnest("projectInviteOptions")
        on conflict do nothing
        returning id
      )
      select array_agg(id) into invite_ids from ins;

      -- add to groups if exists
      if "groupNames" is not null and array_length("groupNames", 1) > 0 then
          insert into
            project_invite_groups (
              invite_id,
              group_id
            )
          select
            unnest(invite_ids),
            project_groups.id
          from
            project_groups
          where
            project_groups.name = any("groupNames") and
            project_id = "projectId"
          ;
      end if;
      -- afterwards, create invite_emails records if "sendEmailsNow" is true
      if "sendEmailNow" = true then
        perform send_project_invites((
          select
            array_agg(id)
          from
            project_invites
          where
            email in (select email from unnest("projectInviteOptions"))
        ));
      end if;
      return query select * from project_invites where project_id = "projectId" and email in (select email from unnest("projectInviteOptions"));
    end;
  $$;

grant execute on function create_project_invites to seasketch_user;

drop table if exists survey_invites cascade;
create table survey_invites (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  survey_id integer NOT NULL REFERENCES surveys (id) ON DELETE CASCADE,
  created_at timestamp with time zone not null DEFAULT timezone('utc'::text, now()),
  user_id integer references users(id) on delete cascade,
  was_used boolean not null default false,
  fullname text,
  email email not null,
  was_added_from_group boolean not null default false,
  unique(email, survey_id)
);

grant select on survey_invites to seasketch_user;
grant update (fullname, email) on survey_invites to seasketch_user;
grant delete on survey_invites to seasketch_user;
alter table survey_invites enable row level security;
create policy survey_invites_admin_select on survey_invites for select to seasketch_user using (session_is_admin((select project_id from surveys where surveys.id = survey_id)));
create policy survey_invites_admin_update on survey_invites for update to seasketch_user using (session_is_admin((select project_id from surveys where surveys.id = survey_id))) with check (session_is_admin((select project_id from surveys where surveys.id = survey_id)));
create policy survey_invites_admin_delete on survey_invites for delete to seasketch_user using (session_is_admin((select project_id from surveys where surveys.id = survey_id)));


-- add survey_invites_status function
comment on column survey_invites.was_added_from_group is '
@omit
Indicates that the invite was created due to user membership of a group and not manually added. Manually added users are not removed by group membership-related triggers
';

drop table if exists invite_emails cascade;
create table invite_emails (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  to_address email not null,
  project_invite_id integer references project_invites (id),
  survey_invite_id integer references survey_invites (id),
  message_id text,
  status email_status not null default 'QUEUED'::email_status,
  created_at timestamp with time zone not null DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone,
  token_expires_at timestamp with time zone,
  token text,
  error text
);

create index on invite_emails (token);
create index on invite_emails (project_invite_id);
create index on invite_emails (status);
create index on invite_emails (project_invite_id, to_address);
create index on invite_emails (survey_invite_id, to_address);
create index on invite_emails (survey_invite_id);

create or replace function project_invite_was_used (invite_id int)
  returns boolean
  security definer
  stable
  language sql
  as $$
    select was_used from project_invites where id = invite_id;
  $$;

grant execute on function project_invite_was_used to anon;
comment on function project_invite_was_used is '@omit';

create or replace function get_public_jwk(id uuid)
  returns text
  security definer
  stable
  language sql
  as $$
    select public_pem from jwks where kid = id
  $$;

grant execute on function get_public_jwk to anon;
comment on function get_public_jwk is '@omit';

create or replace function project_invites_status(invite project_invites)
  returns invite_status
  security definer
  language plpgsql
  stable
  as $$
    declare
      email_status invite_status;
      expired boolean;
      has_complaint boolean;
    begin
      select exists(select 1 from invite_emails where to_address = invite.email and status = 'COMPLAINT') into has_complaint;
      if invite.was_used = true then 
        return 'CONFIRMED';
      end if;
      if has_complaint then
        return 'COMPLAINT';
      else
        select
          now() > token_expires_at as expired,
          status
        into
          expired,
          email_status
        from
          invite_emails
        where
          project_invite_id = invite.id
        order by
          created_at desc
        limit 1;
        if expired = true then
          return 'TOKEN_EXPIRED';
        elsif email_status is null then
          return 'UNSENT';
        else
          return email_status::invite_status;
        end if;
      end if;
    end;      
  $$;

grant execute on function project_invites_status to seasketch_user;

drop type if exists invite_order_by;
create type invite_order_by as enum (
  'NAME',
  'EMAIL'
);

drop function if exists projects_invites;
create function projects_invites(p projects, statuses invite_status[], "orderBy" invite_order_by, "direction" sort_by_direction)
  returns setof project_invites
  language sql
  stable
  as $$
    select 
      * 
    from 
      project_invites 
    where 
      session_is_admin(p.id) and 
      project_id = p.id and 
      project_invites_status(project_invites.*) = any (statuses)
    order by
      (CASE WHEN "orderBy" = 'EMAIL' and "direction" = 'ASC' THEN email
            WHEN "orderBy" = 'NAME' and "direction" = 'ASC' THEN fullname
            else fullname
      END) ASC,
      (CASE WHEN "orderBy" = 'EMAIL' and "direction" = 'DESC' THEN email
            WHEN "orderBy" = 'NAME' and "direction" = 'DESC' THEN fullname
            ELSE fullname
      END) DESC
  $$;

grant execute on function projects_invites to seasketch_user;
comment on function projects_invites is 'List project invites by status';


alter table invite_emails add constraint invite_email_has_related_model check (((survey_invite_id is not null)::integer + (project_invite_id is not null)::integer) = 1);

grant select (project_invite_id, survey_invite_id, status, created_at, updated_at, token_expires_at) on invite_emails to seasketch_user;
alter table invite_emails enable row level security;
create policy invite_emails_admin on invite_emails for select to seasketch_user using (
  session_is_admin((
    select id from projects where id in (
      select project_id from project_invites where project_invites.id = project_invite_id
    ) or id in (
      select surveys.project_id from surveys where surveys.id in (
        select survey_id from survey_invites where survey_invites.id = survey_invite_id
      )
    )
  ))
);

create or replace function before_invite_emails_insert()
  returns trigger 
  language plpgsql
  volatile
  AS $$
  begin
    if NEW.status != 'QUEUED' and (NEW.token is null or NEW.token_expires_at is null) then
      raise exception 'token and token_expires_at must be set on invite_emails unless status = "QUEUED"';
    end if;
    -- assigning to_address
    if NEW.project_invite_id is not null then
      NEW.to_address = (select email from project_invites where id = NEW.project_invite_id);
    end if;
    if NEW.survey_invite_id is not null then
      NEW.to_address = (select email from survey_invites where id = NEW.survey_invite_id);
    end if;

    -- check if user has compained in any other emails
    if exists (
      select 
        1
      from 
        invite_emails
      where
        to_address = NEW.to_address and
        status = 'COMPLAINT'
    ) then
      return NULL;
    end if;

    if NEW.project_invite_id is not null then
      if exists (
        select 1 from invite_emails 
        where project_invite_id = new.project_invite_id and
        (status = 'QUEUED' or status = 'SENT') and
        (token_expires_at is null or now() < token_expires_at)
      ) then
        return NULL;
      end if;
    end if;
    if NEW.survey_invite_id is not null then
      if exists (
        select 1 from invite_emails where 
        survey_invite_id = new.survey_invite_id and
        (status = 'QUEUED' or status = 'SENT') and
        (token_expires_at is null or now() < token_expires_at)
      ) then
        return NULL;
      end if;
    end if;
    return new;
  end;
$$;

create trigger before_invite_emails_insert_trigger
  before insert on invite_emails
  for each row
  execute procedure before_invite_emails_insert();

create or replace function before_invite_emails_update()
  returns trigger 
  language plpgsql
  volatile
  AS $$
  begin
    if NEW.status != 'QUEUED' and (NEW.token is null or NEW.token_expires_at is null) then
      raise exception 'token and token_expires_at must be set on invite_emails unless status = "QUEUED"';
    end if;
    return new;
  end;
$$;

create trigger before_invite_emails_update_trigger
  before update on invite_emails
  for each row
  execute procedure before_invite_emails_update();

drop function if exists send_project_invites;
create function send_project_invites("inviteIds" int[])
  returns setof invite_emails
  security definer
  language plpgsql
  as $$
    begin
      if exists(
        select 1 from projects where id = any(
          select distinct(project_id) from project_invites where project_invites.id = any("inviteIds")
        ) and session_is_admin(id) = false
      ) then
        raise exception 'Must be project administrator';
      end if;
      return query insert into invite_emails (project_invite_id) select unnest("inviteIds") returning *;
    end;
  $$;

grant execute on function send_project_invites to seasketch_user;

create or replace function send_all_project_invites("projectId" int)
  returns setof invite_emails
  language plpgsql
  as $$
    begin
      if session_is_admin("projectId") = false then
        raise exception 'Must be project administrator';
      end if;
      return query select * from send_project_invites((select array_agg(id) from project_invites where project_id = "projectId"));
    end;
  $$;

grant execute on function send_all_project_invites to seasketch_user;
-- Add indexes
-- Add row level security
-- Add insert trigger to responses that sets was_used on related invite if exists
-- Add invite_users_from_groups(surveyId, groupId);



comment on table survey_invited_groups is '
@omit all
@simpleCollections only
';
CREATE INDEX ON "public"."survey_invited_groups"("group_id");

alter table surveys enable row level security;

create policy surveys_admin on surveys for all to seasketch_user using (
  session_is_admin(project_id)
) with check (
  session_is_admin(project_id)
);

create or replace function session_in_group("groupIds" int[])
  returns boolean
  language sql
  security definer
  stable
  as $$
    select exists (
      select 1 from project_group_members where it_me(user_id) and group_id = any("groupIds")
    )
$$;

create or replace function survey_group_ids(id int)
  returns int[]
  language sql
  security definer
  stable
  as $$
    select array_agg(group_id) from survey_invited_groups where survey_id = id
$$;

grant execute on function session_in_group to anon;
grant execute on function survey_group_ids to anon;
comment on function session_in_group is '@omit';
comment on function survey_group_ids is '@omit';


create policy surveys_select on surveys for select to anon using (
  session_is_admin(project_id) or (
    session_has_project_access(project_id) and is_disabled = false and (
      (
        access_type = 'PUBLIC'
      ) or (
        session_in_group(survey_group_ids(id))
      )
    )
  )
);

alter table survey_invited_groups enable row level security;
create policy surveys_invited_groups_admin on survey_invited_groups for all to seasketch_user using (
  session_is_admin((select project_id from surveys where id = survey_id))
) with check (
  session_is_admin((select project_id from surveys where id = survey_id))
);

drop table if exists survey_responses cascade;
create table survey_responses (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  survey_id integer NOT NULL REFERENCES surveys (id) ON DELETE CASCADE,
  user_id integer REFERENCES users (id) ON DELETE CASCADE,
  data jsonb not null default '{}'::jsonb check (char_length(data::text) < 10000),
  is_draft boolean not null default false,
  is_duplicate_ip boolean not null default false,
  is_duplicate_entry boolean not null default false,
  is_unrecognized_user_agent boolean not null default false,
  bypassed_duplicate_submission_control boolean not null default false,
  outside_geofence boolean not null default false,
  created_at timestamp with time zone not null DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone
);

comment on column survey_responses.data is 'JSON representation of responses, keyed by the form field export_id';
comment on column survey_responses.is_draft is 'Users may save their responses for later editing before submission. After submission they can no longer edit them.';
comment on column survey_responses.is_duplicate_entry is 'Detected by looking for matches in contact fields (name, phone number, and/or email address)';
comment on column survey_responses.bypassed_duplicate_submission_control is 'The SeaSketch client blocks users from submitting multiple responses in single-submission surveys, unless the user bypasses the warning in order to submit entries on a shared computer.';
comment on column survey_responses.is_unrecognized_user_agent is 'Responses are flagged if not using Chrome, Mozilla, Safari, Opera, IE, Edge, or other recognized user agents. May indicate malicious use of automation tools.';
comment on column survey_responses.outside_geofence is '
@omit create
Checked on SUBMISSION, so adding or changing a survey geofence after responses have been submitted will not update values. GPS coordinates and IP addresses are not stored for privacy purposes.
';
comment on column survey_responses.is_duplicate_entry is '
@omit create
Duplicate entries are detected by matching contact-information field values.
';
comment on column survey_responses.is_duplicate_ip is '
@omit create
Detected by comparing ip hashes from previous entries. IP hashes are not tied to particular responses, so only the second and subsequent entries are flagged.
';
comment on column survey_responses.is_unrecognized_user_agent is '
@omit create
Unusual or missing user-agent headers on submissions are flagged. May indicate scripting but does not necessarily imply malicious intent.
';
comment on column survey_responses.bypassed_duplicate_submission_control is '
Should be set by the client on submission and tracked by cookies or localStorage. Surveys that permit only a single entry enable users to bypass the limit for legitimate purposes, like entering responses on a shared computer.
';


create index on survey_responses (survey_id);
create index on survey_responses (survey_id, user_id);

drop table if exists survey_response_network_addresses;
create table survey_response_network_addresses (
  survey_id integer NOT NULL REFERENCES surveys (id) ON DELETE CASCADE,
  ip_hash text not null,
  num_responses int not null default 1
);

CREATE INDEX ON survey_response_network_addresses USING hash (ip_hash);
create index on survey_response_network_addresses (survey_id);


grant select on survey_invited_groups to anon;
grant insert on survey_invited_groups to seasketch_user;
grant delete on survey_invited_groups to seasketch_user;

grant select on access_control_lists to anon;
grant update(type) on access_control_lists to seasketch_user;
-- Fix row level security on access_control_lists
alter table access_control_lists enable row level security;
drop policy if exists access_control_lists_select on access_control_lists;
drop policy if exists access_control_lists_update on access_control_lists;
create policy access_control_lists_select on access_control_lists for select to anon using (true);
create policy access_control_lists_update on access_control_lists for update to seasketch_user 
  using (
    session_is_admin((select project_id from sketch_classes where id = sketch_class_id)) or 
    session_is_admin((select project_id from forums where id = forum_id))
  ) with check (
    session_is_admin((select project_id from sketch_classes where id = sketch_class_id)) or 
    session_is_admin((select project_id from forums where id = forum_id))
  );

comment on function create_bbox is '@omit';

CREATE EXTENSION IF NOT EXISTS "unaccent";

CREATE OR REPLACE FUNCTION slugify("value" TEXT, "allow_unicode" BOOLEAN)
RETURNS TEXT AS $$

  WITH "normalized" AS (
    SELECT CASE
      WHEN "allow_unicode" THEN "value"
      ELSE unaccent("value")
    END AS "value"
  )
  SELECT regexp_replace(
    trim(
      lower(
        regexp_replace(
          "value",
          E'[^\\w\\s-]',
          '',
          'gi'
        )
      )
    ),
    E'[-\\s]+', '-', 'gi'
  ) FROM "normalized";

$$ LANGUAGE SQL STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION slugify(TEXT)
RETURNS TEXT AS 'SELECT slugify($1, false)' LANGUAGE SQL IMMUTABLE STRICT;

drop type if exists form_template_type cascade;
create type form_template_type as enum (
  'SURVEYS',
  'SKETCHES',
  'SURVEYS_AND_SKETCHES'
);
comment on type form_template_type is 'Indicates which features should use the form as a template';

drop table if exists forms cascade;
create table forms (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sketch_class_id int unique references sketch_classes(id) on delete cascade,
  -- TODO: eventually add a survey_id
  survey_id int unique references surveys(id) on delete cascade,
  is_template boolean not null default false,
  template_type form_template_type constraint  template_types_only_if_is_template check(template_type is null or is_template = true),
  template_name text constraint must_have_template_name_if_is_template check (template_name is not null or is_template = false)
);
create index on forms (sketch_class_id);
create index on forms (is_template);

comment on constraint forms_sketch_class_id_fkey on forms is '
@simpleCollections only
';
comment on column forms.is_template is 'SeaSetch developers can create template forms than can be used when creating SketchClasses or Surveys';
comment on column forms.template_type is 'Indicates which features should use this form as a template';

comment on table forms is '
@omit all
';

create function template_forms ()
  returns setof forms
  security definer
  language SQL
  stable
  as $$
    select * from forms where is_template = true;
  $$;

grant execute on function template_forms to anon;

comment on function template_forms is '@simpleCollections only';

grant select on forms to anon;
grant delete on forms to seasketch_user;
-- grant insert (sketch_class_id) on forms to seasketch_user;

drop type if exists form_field_type cascade;
create type form_field_type as enum (
  'TEXTINPUT',
  'TEXTAREA',
  'SELECT',
  'SECTION'
);
comment on type form_field_type is 'In the future new field types can be added by using the command `alter type form_field_type add value ''NEW_TYPE'';`';

drop table if exists form_fields cascade;
create table form_fields (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  form_id int not null references forms(id) on delete cascade,
  name text not null,
  description text check (char_length(description) < 500),
  type form_field_type not null,
  is_required boolean not null default false,
  export_id text not null,
  position int not null default 1 check (position > 0),
  component_settings jsonb not null default '{}'::jsonb check (char_length(component_settings::text) < 10000)
);

create index on form_fields (form_id);


comment on column form_fields.name is 'Question label';
comment on column form_fields.description is 'Question description. Max length 500 characters';
comment on column form_fields.export_id is 'Column name in csv export, property name in reporting tools. Keep stable to avoid breaking reports';
comment on column form_fields.position is 'Determines order of fields in the form';
comment on column form_fields.component_settings is 'Field type-specific configuration passed to UI components';

grant select on form_fields to anon;
grant update (name, description, type, is_required, export_id, position, component_settings) on form_fields to seasketch_user;
grant insert on form_fields to seasketch_user;
grant delete on form_fields to seasketch_user;
alter table form_fields enable row level security;


drop type if exists field_rule_operator cascade;
create type field_rule_operator as enum (
  '<',
  '>',
  '=',
  '!=',
  'is blank',
  'contains'
);

drop table if exists form_conditional_rendering_rules cascade;
create table form_conditional_rendering_rules (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  field_id int not null references form_fields(id) check (field_id != predicate_field_id),
  predicate_field_id int not null references form_fields(id) check (field_id != predicate_field_id),
  value text,
  operator field_rule_operator not null default '='
);

create index on form_conditional_rendering_rules (field_id);

comment on constraint form_fields_form_id_fkey on form_fields is '@simpleCollections only';
comment on table form_conditional_rendering_rules is '
@omit all
';
comment on constraint form_conditional_rendering_rules_field_id_fkey on form_conditional_rendering_rules is '
@foreignFieldName conditionalRenderingRules
@simpleCollections only
';

grant select on form_conditional_rendering_rules to anon;
grant update (field_id, predicate_field_id, value, operator) on form_conditional_rendering_rules to seasketch_user;
grant insert on form_conditional_rendering_rules to seasketch_user;
grant delete on form_conditional_rendering_rules to seasketch_user;
alter table form_conditional_rendering_rules enable row level security;

create policy form_conditional_rendering_rules_select on form_conditional_rendering_rules for select to anon using (true);

create or replace function project_id_for_form_id (fid int)
  returns int
  security definer
  language sql
  stable
  as $$
    select project_id from (
      select 
        sketch_classes.project_id 
      from 
        sketch_classes 
      where 
        sketch_classes.id = (select sketch_class_id from forms where forms.id = fid)
      union
        select
          surveys.project_id
        from
          surveys
        where
          surveys.id = (select survey_id from forms where forms.id = fid)
    ) as foo where project_id is not null
  $$;

grant execute on function project_id_for_form_id to anon;
comment on function project_id_for_form_id is '@omit';


create or replace function project_id_from_field_id (fid int)
  returns int
  language sql
  stable
  as $$
    select project_id_for_form_id((select form_id from form_fields where form_fields.id = fid))
  $$;

grant execute on function project_id_from_field_id to anon;
comment on function project_id_from_field_id is '@omit';

create policy form_conditional_rendering_rules_admin on form_conditional_rendering_rules for all to seasketch_user
  using (session_is_admin(project_id_from_field_id(field_id))) with check (session_is_admin(project_id_from_field_id(field_id)));

alter table forms enable row level security;

create policy forms_admin on forms for all to seasketch_user using (
  session_is_admin((select project_id from sketch_classes where id = sketch_class_id or id = survey_id))
) with check (
  session_is_admin((select project_id from sketch_classes where id = sketch_class_id or id = survey_id))
);

create or replace function session_can_access_form (fid int)
  returns boolean
  language sql
  security definer
  stable
  as $$
    select session_is_admin((select project_id_for_form_id(fid))) or 
    (
      session_has_project_access((select project_id_for_form_id(fid))) and (
        session_on_acl((
          select 
            id 
          from 
            access_control_lists 
          where 
            access_control_lists.sketch_class_id = sketch_class_id
        )) or (
          exists(
            select
              id
            from
              surveys
            where
              id = (select survey_id from forms where forms.id = fid) and
              (
                is_disabled = false and (
                  access_type = 'PUBLIC' or session_in_group(survey_group_ids(surveys.id))
                )
              )
          )
        )
      )
    )
  $$;

grant execute on function session_can_access_form to anon;
comment on function session_can_access_form is '@omit';

create policy forms_user_select on forms for select to anon using (
  session_can_access_form(id)
);

create policy form_fields_admin on form_fields for all to seasketch_user using (
  session_is_admin(project_id_for_form_id(form_id))
) with check (
  session_is_admin(project_id_for_form_id(form_id))
);

create policy forms_fields_select on form_fields for select to anon using (
  session_can_access_form(form_id)
);

create or replace function initialize_blank_sketch_class_form(sketch_class_id int)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
    begin
      if session_is_admin((select project_id from sketch_classes where id = sketch_class_id)) = false then
        raise exception 'Must be project admin';
      end if;
      insert into forms (sketch_class_id) values (sketch_class_id) returning * into form;
      return form;
    end
  $$;

create or replace function initialize_blank_survey_form(survey_id int)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
    begin
      if session_is_admin((select project_id from surveys where id = survey_id)) = false then
        raise exception 'Must be project admin';
      end if;
      insert into forms (survey_id) values (survey_id) returning * into form;
      return form;
    end
  $$;


create or replace function initialize_sketch_class_form_from_template(sketch_class_id int, template_id int)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
    begin
      if session_is_admin((select project_id from sketch_classes where id = sketch_class_id)) = false then
        raise exception 'Must be project admin';
      end if;
      insert into forms (sketch_class_id) values (sketch_class_id) returning * into form;
      insert into 
        form_fields (
          form_id, 
          name, 
          description, 
          type, 
          is_required, 
          export_id, 
          position, 
          component_settings
        )
      select 
        form.id, 
        name, 
        description, 
        type, 
        is_required, 
        export_id, 
        position, 
        component_settings
      from
        form_fields
      where
        form_fields.form_id = template_id;
      return form;
    end
  $$;

create or replace function initialize_survey_form_from_template(survey_id int, template_id int)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
    begin
      if session_is_admin((select project_id from surveys where id = survey_id)) = false then
        raise exception 'Must be project admin';
      end if;
      insert into forms (survey_id) values (survey_id) returning * into form;
      insert into 
        form_fields (
          form_id, 
          name, 
          description, 
          type, 
          is_required, 
          export_id, 
          position, 
          component_settings
        )
      select 
        form.id, 
        name, 
        description, 
        type, 
        is_required, 
        export_id, 
        position, 
        component_settings
      from
        form_fields
      where
        form_fields.form_id = template_id;
      return form;
    end
  $$;

grant execute on function initialize_sketch_class_form_from_template(int, int) to seasketch_user;
grant execute on function initialize_blank_sketch_class_form(int) to seasketch_user;
grant execute on function initialize_survey_form_from_template(int, int) to seasketch_user;
grant execute on function initialize_blank_survey_form(int) to seasketch_user;

create or replace function create_form_template_from_sketch_class("sketchClassId" int, "templateName" text, template_type form_template_type)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
      original_id int;
    begin
      select id into original_id from forms where sketch_class_id = "sketchClassId";
      insert into forms (sketch_class_id, is_template, template_name, template_type) values (null, true, "templateName", template_type) returning * into form;
      insert into 
        form_fields (
          form_id, 
          name, 
          description, 
          type, 
          is_required, 
          export_id, 
          position, 
          component_settings
        ) 
      select 
        form.id, 
        name, 
        description, 
        type, 
        is_required, 
        export_id, 
        position, 
        component_settings
      from
        form_fields
      where
        form_id = original_id;
      return form;
    end
  $$;

grant execute on function create_form_template_from_sketch_class to seasketch_superuser;

create or replace function create_form_template_from_survey("surveyId" int, "templateName" text, template_type form_template_type)
  returns forms
  security definer
  language plpgsql
  as $$
    declare
      form forms;
      original_id int;
    begin
      select id into original_id from forms where survey_id = "surveyId";
      insert into forms (survey_id, is_template, template_name, template_type) values (null, true, "templateName", template_type) returning * into form;
      insert into 
        form_fields (
          form_id, 
          name, 
          description, 
          type, 
          is_required, 
          export_id, 
          position, 
          component_settings
        ) 
      select 
        form.id, 
        name, 
        description, 
        type, 
        is_required, 
        export_id, 
        position, 
        component_settings
      from
        form_fields
      where
        form_id = original_id;
      return form;
    end
  $$;

grant execute on function create_form_template_from_survey to seasketch_superuser;


create or replace function set_form_field_order ("fieldIds" int[])
  returns setof form_fields
  security definer
  language plpgsql
  as $$
    declare
      project_id int;
      sketch_class_id int;
      survey_id int;
      formid int;
      pos int;
      field record;
    begin
      select
        form_fields.form_id
      into
        formid
      from
        form_fields
      where
        id = any("fieldIds")
      limit 1;
      -- raise exception if session is not an admin
      select
        forms.sketch_class_id
        , forms.survey_id
      into
        sketch_class_id
        , survey_id
      from
        forms
      where
        forms.id = formid;
      if sketch_class_id is not null then
        select
          sketch_classes.project_id
        into
          project_id
        from
          sketch_classes
        where
          id = sketch_class_id;
      end if;
      if survey_id is not null then
        select
          surveys.project_id
        into
          project_id
        from
          surveys
        where
          id = survey_id;
      end if;
      if session_is_admin(project_id) = false then
        raise exception 'Must be project admin';
      end if;
      pos = 1;
      -- select fields in order of fieldIDs
      -- loop through each, setting a position
      for field in select * from form_fields where form_id = formid order by array_position("fieldIds", id) loop
        update form_fields set position = pos where id = field.id;
        pos = pos + 1;
      end loop;
      -- return all the fields in this form
      return query select * from form_fields where form_fields.form_id = form_id order by position asc;
    end
  $$;

grant execute on function set_form_field_order to seasketch_user;

create or replace function before_survey_update()
  returns trigger 
  language plpgsql
  volatile
  AS $$
  begin
    if NEW.is_disabled = false and not exists(select * from forms where survey_id = NEW.id) then
      raise exception 'A blank or template form must be assigned to this survey before publishing.';
    end if;
    return new;
  end;
$$;

create trigger before_survey_update_trigger
  before insert or update on surveys
  for each row
  execute procedure before_survey_update();


create or replace function before_survey_invited_groups_insert()
  returns trigger 
  language plpgsql
  volatile
  AS $$
  begin
    if not exists (select id from project_groups where id = NEW.group_id and project_id = (select project_id from surveys where id = NEW.survey_id)) then
      raise exception 'Surveys may only invite participant groups from the same project';
    end if;
    return new;
  end;
$$;

create trigger before_survey_invited_groups_insert_trigger
  before insert on survey_invited_groups
  for each row
  execute procedure before_survey_invited_groups_insert();

grant select on survey_responses to seasketch_user;

grant update (data, is_draft) on survey_responses to seasketch_user;
grant insert on survey_responses to seasketch_user;
grant delete on survey_responses to seasketch_user;

alter table survey_responses enable row level security;

create policy survey_responses_select on survey_responses for select to seasketch_user using (
  -- owned by user
  it_me(user_id) or (
    -- project_admin and survey is submitted
    is_draft = false and
    session_is_admin((select project_id from surveys where surveys.id = survey_id))
  )
);

-- only authors can create new responses
create policy survey_responses_insert on survey_responses for insert to seasketch_user with check (it_me(user_id));

create policy survey_responses_delete on survey_responses for delete to seasketch_user using (
  it_me(user_id) or session_is_admin((select project_id from surveys where surveys.id = survey_id))
);

create policy survey_responses_update on survey_responses for update to seasketch_user using (
  it_me(user_id)
) with check (
  it_me(user_id)
);

create or replace function before_response_update()
  returns trigger 
  language plpgsql
  security definer
  volatile
  AS $$
  begin
    NEW.updated_at = now();
    if OLD.user_id != NEW.user_id then
      raise exception 'Cannot change userid';
    end if;
    if it_me(OLD.user_id) then
      if OLD.is_draft = false then
        raise exception 'Cannot edit submitted responses. Contact an admin and ask them to put your response into draft mode';
      end if;
    else
      if not session_is_admin((select project_id from surveys where surveys.id = OLD.survey_id)) then
        raise exception 'Must be a project administrator';
      else
        if OLD.is_draft != false or NEW.is_draft != true then
          raise exception 'Admins can only put responses back into draft mode';
        end if;
      end if;
    end if;
    return NEW;
  end;
$$;

create trigger before_response_update_trigger
  before update on survey_responses
  for each row
  execute procedure before_response_update();

create or replace function make_response_draft("responseId" int)
  returns survey_responses
  language plpgsql
  security definer
  volatile
  as $$
    declare
      r survey_responses;
    begin
      if session_is_admin((select project_id from surveys where id = (select survey_id from survey_responses where id = "responseId"))) then
        update survey_responses set is_draft = true where id = "responseId" returning * into r;
        return r;
      else
        raise exception 'Must be a project admin';
      end if;
    end;
$$;

grant execute on function make_response_draft to seasketch_user;
  


create or replace function surveys_submitted_response_count (survey surveys)
  returns int
  language sql
  stable
  as $$
    select count(*)::int from survey_responses where survey_id = survey.id and is_draft = false;
$$;

grant execute on function surveys_submitted_response_count to seasketch_user;

create or replace function before_survey_delete()
  returns trigger 
  security definer
  language plpgsql
  volatile
  AS $$
  declare
    num int;
  begin
    select count(*)::int from survey_responses into num where survey_id = OLD.id and (user_id is null or user_id != current_setting('session.user_id', TRUE)::integer);
    if num >= 5 then
      raise exception 'Preventing deletion. Survey has 5 or more responses from other users. Contact support@seasketch.org or simply disable survey.';
    end if;
    return NEW;
  end;
$$;

create trigger before_survey_delete_trigger
  before delete on surveys
  for each row
  execute procedure before_survey_delete();

create extension if not exists pgcrypto;

create or replace function before_survey_response_insert()
  returns trigger 
  security definer
  language plpgsql
  volatile
  AS $$
  declare
    existing survey_response_network_addresses;
  begin
    if current_setting('session.request_ip', true) is not null then
      update
        survey_response_network_addresses
      set num_responses = num_responses + 1
      where
        ip_hash = crypt(
          current_setting('session.request_ip', true) || NEW.survey_id::text, 
          ip_hash
        )
      returning
        *
      into 
        existing;
      if existing is not null then
        NEW.is_duplicate_ip = true;
      else
        insert into survey_response_network_addresses (
          survey_id, 
          ip_hash
        ) values (
          NEW.survey_id,
          crypt(
            current_setting('session.request_ip', true) || NEW.survey_id::text, 
            gen_salt('bf')
          )
        );
      end if;
    end if;
    return NEW;
  end;
$$;

create trigger before_survey_response_insert_trigger
  before insert on survey_responses
  for each row
  execute procedure before_survey_response_insert();

-- Returns user_id
drop function if exists confirm_project_invite;
create function confirm_project_invite(invite_id int)
  returns int
  security definer
  language plpgsql
  as $$
    declare
      userid int;
      project_invite project_invites;
    begin
      select current_setting('session.user_id')::int into userid;
      if userid is null then
        raise exception 'Not signed in';
      end if;
      if (select current_setting('session.escalate_privileges', true)) != 'on' then
        raise exception 'Permission denied';
      end if;
      if exists (select id from project_invites where id = invite_id and was_used = true) then
        raise exception 'Invite has already been used';
      end if;
      -- set was_used to true
      -- set user_id on project_invite
      update project_invites set user_id = userid, was_used = true where id = invite_id returning * into project_invite;
      if project_invite is null then
        raise exception 'Cannot find invite with id %', invite_id;
      end if;
      -- create project participant record, respecting make_admin setting
      insert into project_participants (
        user_id, 
        project_id, 
        is_admin, 
        approved,
        share_profile,
        requested_at
      ) values (
        userid,
        project_invite.project_id,
        project_invite.make_admin,
        true,
        false,
        now()
      ) on conflict on constraint project_participants_pkey
      do update
        set approved = true,
        is_admin = (project_participants.is_admin or project_invite.make_admin);
      -- add any group access permissions
      insert into project_group_members (group_id, user_id)
      select group_id, userid from 
        project_invite_groups
      where
        project_invite_groups.invite_id = project_invite.id;
      return userid;
    end;
  $$;

grant execute on function confirm_project_invite to anon;
comment on function confirm_project_invite is '@omit';

create or replace function confirm_project_invite_with_verified_email("projectId" int)
  returns int
  security definer
  language plpgsql
  as $$
    begin
      -- check that there is a user logged in with a verified email
      if nullif(current_setting('session.user_id', TRUE), '')::int is not null and nullif(current_setting('session.canonical_email', TRUE), '')::text is not null and nullif(current_setting('session.email_verified', TRUE), '')::boolean is true then
        -- check if there is an invite that matches that email
        if exists(select 1 from project_invites where email = current_setting('session.canonical_email', TRUE) and exists(select 1 from invite_emails where status != 'QUEUED' and project_invite_id = project_invites.id)) then
          -- if so, run confirm_project_invite(invite_id)
          return (select confirm_project_invite((select id from project_invites where email = current_setting('session.canonical_email', TRUE))));
        else
          raise exception 'No sent invite matching your email found';
        end if;
      else
        raise exception 'Must be logged in with a verified email';
      end if;
    end;
  $$;

grant execute on function confirm_project_invite_with_verified_email to seasketch_user;
comment on function confirm_project_invite_with_verified_email is '
Users can confirm project invites without clicking thru an email if they are registered for SeaSketch and their verified email matches that of a project invite.
';

drop type if exists project_invite_details cascade;
create type project_invite_details as (
  admin boolean,
  fullname text,
  email text,
  project_id int,
  state invite_status
);

drop function if exists projects_invite;
create or replace function projects_invite(p projects)
  returns project_invites
  security definer
  language sql
  stable
  as $$
    select 
      *
    from 
      project_invites 
    where 
      project_id = p.id and
      nullif(current_setting('session.email_verified', TRUE), '')::boolean is true and
      email = current_setting('session.canonical_email', TRUE)::email and
      exists(
        select 1 from invite_emails 
        where status != 'QUEUED' and 
        project_invite_id = project_invites.id
      )
    limit 1;
  $$;

grant execute on function projects_invite to anon;
grant execute on function citext_eq to anon;

drop type if exists invite_stats cascade;
create type invite_stats as (
  status invite_status,
  count int
);

create or replace function projects_admin_count(p projects)
  returns int
  security definer
  language plpgsql
  stable
  as $$
    begin
      if session_is_admin(p.id) then
        return (select
            count(*) as count
          from
            project_participants
          where
            project_id = p.id and is_admin = true
        );
      else
        raise exception 'Must be project admin';
      end if;
    end;
  $$;

  grant execute on function projects_admin_count to seasketch_user;

create or replace function projects_invite_counts(p projects)
  returns setof invite_stats
  security definer
  language sql
  stable
  as $$
    select t::invite_stats from (
    select
        project_invites_status(project_invites.*)::invite_status as status,
        count(*) as count
      from
        project_invites
      where
        project_id = p.id and session_is_admin(p.id)
      group by
        status) as t;
  $$;

grant execute on function projects_invite_counts to seasketch_user;
comment on function projects_invite_counts is '
@simpleCollections only
Breakdown of number of invites per status. Used to display counts in overview listing of users, groups, and invites in the user administration dashboard.
';

comment on function projects_invite is '
Returns the project invitation for the current user session, if any. Will not appear until the invite has been sent. The system determines the relevant invite using the `canonical_email` claim in the user access token.

If the invite status is unconfirmed the client should accept it using the `confirmProjectInviteWithVerifiedEmail()` mutation. Details on how to work with user ingress and project invites [can be found on the wiki](https://github.com/seasketch/next/wiki/User-Ingress).
';

create or replace function projects_session_is_admin(p projects)
  returns boolean
  language sql
  security definer
  stable
  as $$
    select EXISTS (
      SELECT
        user_id
      FROM
        project_participants
      WHERE
        it_me(user_id)
        AND project_participants.is_admin = TRUE
        AND project_participants.project_id = p.id) or session_is_superuser()
  $$;

grant execute on function projects_session_is_admin to seasketch_user;
comment on function projects_session_is_admin is 'Returns true if the user has admin privileges on this project. Will return true even if the session email is not verified, but permissions will not work until it is.';

create or replace function projects_session_has_privileged_access(p projects)
  returns boolean
  language sql
  security definer
  stable
  as $$
    select projects_session_is_admin(p) or exists(select 1 from project_group_members where group_id = any (select id from project_groups where project_id = p.id) and it_me(user_id));
  $$;

grant execute on function projects_session_has_privileged_access to seasketch_user;

comment on function projects_session_has_privileged_access is '
Indicates whether current session should have special access or group privileges. These grants will not be active if the user does not have a verified email address.

Clients should check for situations where a user access token has a false `email_verified` cliam paired with privileged access. If that is the case they should prompt users to confirm their email address.
';

comment on constraint invite_emails_project_invite_id_fkey on invite_emails is '@simpleCollections only';
comment on column project_invites.make_admin is 'User will be made an admin of the project if true. They will not be given special access until their email is verified.';

comment on function current_project is '
The current SeaSketch Project, which is determined by the `referer` or `x-ss-slug` request headers. Most queries used by the app should be rooted on this field.
';

comment on constraint sketch_folders_user_id_fkey on sketch_folders is '@omit';

comment on table surveys is '
@simpleCollections only
@omit all
';

comment on table survey_responses is '
@omit all
';

comment on table sketches is '
@omit all,many
';

comment on table form_fields is '
@omit all
';

create index on survey_invites (user_id);
create index on survey_invites (survey_id);
create index on survey_responses (user_id);
create index on project_invites (project_id);
create index on project_invites (user_id);
CREATE INDEX ON "public"."project_invite_groups"("group_id");

create or replace function project_invites_groups(invite project_invites)
  returns setof project_groups
  language sql
  stable
  as $$
    select * from project_groups where id = any (select group_id from project_invite_groups where invite_id = invite.id);
  $$;

grant execute on function project_invites_groups to seasketch_user;

comment on function project_invites_groups is '@simpleCollections only';


create or replace function projects_admins(p projects)
  returns setof users
  language sql
  stable
  as $$
    select 
      users.* 
    from 
      project_participants
    inner join
      users
    on
      project_participants.user_id = users.id
    where
      project_participants.is_admin = true and
      (
        project_participants.approved = true or
        exists(select 1 from projects where id = project_participants.project_id and projects.access_control = 'public')
      )
    ;
  $$;

grant execute on function projects_admins to seasketch_user;
comment on function projects_admins is '@simpleCollections only';

create or replace function confirm_onboarded()
  returns users
  language sql
  security definer
  as $$
    update users set onboarded = now() where it_me(id) = true returning *;
$$;

grant execute on function confirm_onboarded to seasketch_user;
comment on function confirm_onboarded is '
Confirm that a new user has seen any onboarding materials. Updates User.onboarded date.
';

CREATE or replace FUNCTION public.session_is_admin("projectId" integer) RETURNS boolean
    LANGUAGE sql SECURITY DEFINER
    AS $$
    select session_is_superuser() or (
      current_setting('session.email_verified', true) = 'true' and
      is_admin("projectId", nullif(current_setting('session.user_id', TRUE), '')::integer));
$$;

CREATE OR REPLACE FUNCTION public.session_on_acl(acl_id integer) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    with acl as (
      select type, project_id from access_control_lists where id = acl_id
    )
    select exists(select 1 from acl where type = 'public') or
    session_is_admin((select project_id from access_control_lists where id = acl_id)) or
    (
      exists(select 1 from acl where type = 'group') and 
      current_setting('session.user_id', TRUE) != '' and 
      current_setting('session.email_verified', true) = 'true' and
      exists (
        select 1 from access_control_list_groups 
          where access_control_list_id = acl_id and group_id in (
            select group_id from project_group_members where user_id = nullif(current_setting('session.user_id', TRUE), '')::integer
          )
      )
    )
  $$;


CREATE OR REPLACE FUNCTION public.session_is_approved_participant(pid integer) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    select has_session() and EXISTS (
      SELECT 
        1
      FROM
        project_participants
      WHERE (
        it_me(project_participants.user_id) and
        project_participants.project_id = pid
      ) AND project_participants.approved = TRUE AND
      current_setting('session.email_verified', true) = 'true'
    )
  $$;

COMMENT ON FUNCTION public.my_folders("projectId" integer) IS '
@omit
';

COMMENT ON FUNCTION public.my_sketches("projectId" integer) IS '
@omit
';

comment on function can_digitize is '@omit';

comment on function me is 'Access the current session''s User. The user is determined by the access token embedded in the `Authorization` header.';

comment on table forums is '@omit all';

comment on table invite_emails is '@omit all';
comment on table survey_invites is '@omit all';

COMMENT ON TABLE public.projects IS '
@omit delete
SeaSketch Project type. This root type contains most of the fields and queries
needed to drive the application.
';

comment on column users.onboarded is '
Indicates whether the user has seen post-registration information. Can be 
updated with `confirmOnboarded()` mutation. 

Since this field is a date, it could
hypothetically be reset as terms of service are updated, though it may be better
to add a new property to track that.
';

comment on function users_participation_status is '@omit';
comment on function users_is_admin is '@omit';

comment on constraint project_invites_user_id_fkey on project_invites is '@omit';
comment on constraint survey_invites_user_id_fkey on survey_invites is '@omit';
comment on constraint survey_responses_user_id_fkey on survey_responses is '@omit';

comment on function users_is_approved is '@omit';

create or replace function projects_session_participation_status(p projects)
  returns participation_status
  language sql
  stable
  as $$
    select users_participation_status(users.*, p.id) from users where it_me(users.id);
$$;

grant execute on function projects_session_participation_status to seasketch_user;

COMMENT ON TABLE public.users IS '
@omit all
The SeaSketch User type is quite sparse since authentication is handled by Auth0
and we store no personal information unless the user explicitly adds it to the
user `Profile`.

During operation of the system, users identify themselves using bearer tokens. 
These tokens contain ephemeral information like `canonical_email` which can be
used to accept project invite tokens.
';

COMMENT ON TABLE public.user_profiles IS '@omit all
@name profile
Personal information that users have contributed. This information is only 
accessible directly to admins on projects where the user has chosen to share the
information (via the `joinProject()` mutation).

Regular SeaSketch users can access user profiles thru accessor fields on shared
content like forum posts if they have been shared, but regular users have no 
means of listing out all profiles in bulk.
';

comment on column projects.slug is 'Short identifier for the project used in the url. This property cannot be changed after project creation.';
comment on function projects_url is 'Project url will resolve to `https://seasketch.org/{slug}/`';
comment on column projects.logo_url is 'URL referencing an image that will be used to represent the project. Will be displayed at 48x48 pixels and must be a public url.';
comment on column projects.is_featured is 'Featured projects may be given prominent placement on the homepage. This property can only be modified by superusers.';
comment on column projects.is_listed is 'Project admins can decide whether their project will be displayed on the public project listing via Query.projectsConnection.';
comment on column projects.access_control is 'Admins can control whether a project is public, invite-only, or admins-only.';
comment on column projects.description is 'Should be a short length in order to fit in the project header.';
comment on function projects_session_participation_status is '
Indicates whether the current session is an active participant in the project.

  * `NONE` indicates that they are not a participant, and the client may need 
    to prompt the user to join in order to be added to relevant user groups.
  * `PENDING_APPROVAL` indicates they have requested access already to an 
    `INVITE_ONLY` project and have yet to be approved by an administrator.
  * `PARTICIPANT_SHARED_PROFILE` means they are an approved participant with a
    shared user profile. They should be able to post to discussion forums.
  * `PARTICIPANT_HIDDEN_PROFILE` indicates the user has chosen not to share 
    their user profile. They will be able to access group-related content but 
    they will not be able to post information to the forums.

Users can manage their project access using the `joinProject()` and 
`leaveProject()` mutations. Admins can use `approveParticipant()` in invite-only
projects. Clients should make clear that joining a project means sharing 
information included in their user profile, which should at a minimum contain 
their name.
';

-- TODO: update projects_session_participation_status to add state where user has not shared their profile

COMMENT ON TABLE public.sketch_folders IS '
@omit all
SketchFolders can be used by users to organize their sketches. Collection-type
sketches can be used to organize sketches as well, but they are limited in that 
they cannot be nested, and also represent specific management semantics. Folders
can be used by users to arbitrarily organize their Sketches.
';

comment on column sketch_folders.folder_id is 'The parent folder, if any.';
comment on column sketch_folders.collection_id is 'The parent sketch collection, if any. Folders can only have a single parent entity.';

COMMENT ON TABLE public.project_groups IS '@name groups
@omit all,filter
@simpleCollections only
User groups designated by the project administrators. User groups can be used to
assign access control privileges to users. 

Note that only admins have access to groups, or direct knowlege of what groups a
user belongs to. If an admin wanted to create an *Assholes* group they are 
free to do so.
';

comment on column project_groups.name is 'Label for the group.';

comment on constraint survey_invited_groups_group_id_fkey on survey_invited_groups is '@omit';

COMMENT ON FUNCTION public.projects_participants IS '
@simpleCollections only
All users who have opted into participating in the project, sharing 
their profile with project administrators.

If the project is invite-only, users who have not been approved will not appear
in this list. Those users can be accessed via `unapprovedParticipants()`
';

CREATE OR REPLACE FUNCTION public.projects_participants(p public.projects, order_by public.participant_sort_by DEFAULT 'NAME'::public.participant_sort_by, direction public.sort_by_direction DEFAULT 'ASC'::public.sort_by_direction) RETURNS SETOF public.users
    LANGUAGE sql STABLE
    AS $$
  SELECT
    users.*
  FROM
    users
    INNER JOIN project_participants ON (project_participants.user_id = users.id)
    INNER JOIN user_profiles ON (user_profiles.user_id = users.id)
  WHERE
    project_participants.project_id = p.id and
    (project_participants.approved = true or p.access_control = 'public'::project_access_control_setting)
  ORDER BY
    CASE WHEN direction = 'ASC' THEN
      CASE order_by
      WHEN 'NAME' THEN
        user_profiles.fullname
      WHEN 'EMAIL' THEN
        user_profiles.email
      END
    END ASC,
    CASE WHEN direction = 'DESC' THEN
      CASE order_by
      WHEN 'NAME' THEN
        user_profiles.fullname
      WHEN 'EMAIL' THEN
        user_profiles.email
      END
    END DESC
$$;

CREATE OR REPLACE FUNCTION public.projects_participant_count(p public.projects) RETURNS integer
    LANGUAGE sql STABLE
    AS $$
  SELECT
    COALESCE((
      SELECT
        count(*)::int FROM project_participants
    WHERE
      project_id = p.id and (project_participants.approved = true or p.access_control = 'public'::project_access_control_setting)), 0)
$$;



DROP TYPE IF EXISTS public.participation_status cascade;
CREATE TYPE public.participation_status AS ENUM (
    'none',
    'pending_approval',
    'participant_shared_profile',
    'participant_hidden_profile'
);

CREATE OR REPLACE FUNCTION public.users_participation_status(u public.users, "projectId" integer) RETURNS public.participation_status
    LANGUAGE sql STABLE
    AS $$
  select case when exists(
    select 
      1 
    from 
      project_participants 
    where 
      project_participants.user_id = u.id and 
      project_participants.project_id = "projectId"
  ) then 
    case when exists(
      select
        project_participants.approved,
        projects.access_control
      from 
        project_participants
      inner join
        projects
      on
        project_participants.project_id = projects.id
      where
        project_participants.user_id = u.id and
        project_participants.project_id = "projectId" and
        (project_participants.approved = true or access_control = 'public')
    ) then 
      case when exists (
        select 1 from project_participants where user_id = u.id and project_id = "projectId" and share_profile = true
      ) then
        'participant_shared_profile'::participation_status
      else
        'participant_hidden_profile'::participation_status
      end
    else
      'pending_approval'::participation_status
    end
  else
    'none'::participation_status
  end
$$;

create or replace function projects_session_participation_status(p projects)
  returns participation_status
  language sql
  stable
  as $$
    select users_participation_status(users.*, p.id) from users where it_me(users.id);
$$;

grant execute on function projects_session_participation_status to seasketch_user;

CREATE OR REPLACE FUNCTION public.projects_unapproved_participants(p public.projects, order_by public.participant_sort_by DEFAULT 'NAME'::public.participant_sort_by, direction public.sort_by_direction DEFAULT 'ASC'::public.sort_by_direction) RETURNS SETOF public.users
    LANGUAGE sql STABLE
    AS $$
  SELECT
    users.*
  FROM
    users
    INNER JOIN project_participants ON (project_participants.user_id = users.id)
    INNER JOIN user_profiles ON (user_profiles.user_id = users.id)
  WHERE
    project_participants.project_id = p.id and
    project_participants.share_profile = true and
    project_participants.approved = false and 
    p.access_control != 'public'::project_access_control_setting
  ORDER BY
    CASE WHEN direction = 'ASC' THEN
      CASE order_by
      WHEN 'NAME' THEN
        user_profiles.fullname
      WHEN 'EMAIL' THEN
        user_profiles.email
      END
    END ASC,
    CASE WHEN direction = 'DESC' THEN
      CASE order_by
      WHEN 'NAME' THEN
        user_profiles.fullname
      WHEN 'EMAIL' THEN
        user_profiles.email
      END
    END DESC
$$;

grant execute on function projects_unapproved_participants to seasketch_user;

comment on function projects_unapproved_participants is '
@simpleCollections only
For invite-only projects. List all pending participation requests.

Users can be approved using the `approveParticipant()` mutation.
';

GRANT ALL ON FUNCTION public.users_participation_status(u public.users, "projectId" integer) TO seasketch_user;

drop function if exists projects_unapproved_participant_count;
create function projects_unapproved_participant_count(p projects)
  returns int
  language sql
  stable
  as $$
    select count(*)::int from project_participants where project_id = p.id and approved = false and share_profile = true and p.access_control != 'public'::project_access_control_setting;
$$;

grant execute on function projects_unapproved_participant_count to seasketch_user;

comment on function projects_unapproved_participant_count is '
Number of users who have outstanding access requests. Only relevant for invite-only projects.
';
