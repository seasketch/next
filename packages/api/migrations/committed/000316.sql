--! Previous: sha1:9eb15c93c4ae2332846400a7c7750a68865026f6
--! Hash: sha1:5aeaa1d0852a80c50ec3a257279c2e64623ad0a7

-- Enter migration here
create table if not exists deleted_data_upload_outputs (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  remote text not null,
  deleted_at timestamp with time zone not null default now(),
  data_upload_output_data jsonb not null
);

drop trigger if exists _500_gql_after_deleted__data_upload_outputs on data_upload_outputs;

-- Create a trigger to copy deleted data upload outputs to a separate table
-- Only populate a record if there are no other data_upload_output records
-- with a matching value for remote
CREATE OR REPLACE FUNCTION public.after_deleted__data_upload_outputs() RETURNS trigger
  LANGUAGE plpgsql SECURITY DEFINER
  as $$
  BEGIN
    -- Check to see if there are any other data_upload_output records with the same remote value
    if not exists (
      select 1 from data_upload_outputs where remote = OLD.remote and id != OLD.id
    ) then
      insert into deleted_data_upload_outputs (remote, data_upload_output_data) values (OLD.remote, row_to_json(OLD));
    end if;
    return OLD;
  END;
  $$;

CREATE TRIGGER _500_gql_after_deleted__data_upload_outputs AFTER DELETE ON data_upload_outputs FOR EACH ROW EXECUTE FUNCTION public.after_deleted__data_upload_outputs();

alter table data_upload_outputs drop constraint if exists data_upload_outputs_data_source_id_fkey;

ALTER TABLE data_upload_outputs
  ADD CONSTRAINT data_upload_outputs_data_source_id_fkey 
  FOREIGN KEY (data_source_id) 
  REFERENCES data_sources(id) 
  ON DELETE CASCADE;


alter table data_upload_outputs drop constraint if exists data_upload_outputs_project_id_fkey;

ALTER TABLE data_upload_outputs
  ADD CONSTRAINT data_upload_outputs_project_id_fkey 
  FOREIGN KEY (project_id) 
  REFERENCES projects(id) 
  ON DELETE CASCADE;

delete from data_upload_outputs where data_source_id is null;
