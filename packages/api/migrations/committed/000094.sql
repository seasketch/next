--! Previous: sha1:f53442653217c540a0200876ad61c0bd83d68938
--! Hash: sha1:08a44a7377c671dc44094ddfbfee68075ec88e98

alter table form_element_types add column if not exists supported_operators field_rule_operator[] not null default '{}';

update form_element_types set supported_operators = '{"is blank"}' where component_name = 'ShortText';
update form_element_types set supported_operators = '{"is blank"}' where component_name = 'TextArea';
update form_element_types set supported_operators = '{"is blank"}' where component_name = 'Name';
update form_element_types set supported_operators = '{"is blank"}' where component_name = 'Email';
update form_element_types set supported_operators = '{"=", "!=", ">", "<", "is blank"}' where component_name = 'Rating';
update form_element_types set supported_operators = '{"=", "!=", ">", "<", "is blank"}' where component_name = 'Number';
update form_element_types set supported_operators = '{"=", "is blank"}' where component_name = 'YesNo';
update form_element_types set supported_operators = '{"=", "!=", "is blank"}' where component_name = 'ComboBox';
update form_element_types set supported_operators = '{"=", "!=", "contains"}' where component_name = 'MultipleChoice';

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'form_logic_command') THEN
        create type form_logic_command as enum ('JUMP', 'SHOW', 'HIDE');
    END IF;
END
$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'form_logic_operator') THEN
        create type form_logic_operator as enum ('AND', 'OR');
    END IF;
END
$$;



drop table if exists form_logic_rules cascade;
create table if not exists form_logic_rules (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  form_element_id int not null references form_elements (id) on delete cascade,
  boolean_operator form_logic_operator not null default 'OR',
  command form_logic_command not null,
  jump_to_id int references form_elements(id) on delete cascade,
  position int not null
);

create table if not exists form_logic_conditions (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  rule_id int not null references form_logic_rules (id),
  subject_id int not null references form_elements(id) on delete cascade,
  operator field_rule_operator not null default '='::field_rule_operator,
  value jsonb
);


grant select on form_logic_rules to anon;
grant select on form_logic_conditions to anon;
grant all on form_logic_rules to seasketch_user;
grant all on form_logic_conditions to seasketch_user;

comment on table form_logic_rules is '
@omit all
Form logic rules can be used to hide or show FormElements based on the values of 
preceeding fields in a SketchClass. They can also define page jump logic within a Survey.
';

comment on table form_logic_conditions is '
@omit all
Conditions are nested within FormLogicRules. In many cases there may be
only a single condition, but in others the FormLogicRule.booleanOperator
property defines how they are applied.
';

create or replace function forms_logic_rules(form forms)
  returns setof form_logic_rules
  language sql
  stable
  security definer
  as $$
    select * from form_logic_rules where form_element_id in (
      select id from form_elements where form_id = form.id
    ) order by position asc;
  $$;

grant execute on function forms_logic_rules to anon;

comment on function forms_logic_rules is '
@simpleCollections only
';

create or replace function form_logic_rules_conditions(rule form_logic_rules)
  returns setof form_logic_conditions
  language sql
  stable
  security definer
  as $$
    select * from form_logic_conditions where rule_id = rule.id;
  $$;

grant execute on function form_logic_rules_conditions to anon;
comment on function form_logic_rules_conditions is '
@simpleCollections only
';

-- Logic to enforce jump_to_id being set if form_logic_command is 'JUMP'
-- Add before-insert trigger to set an appropriate position on form_logic_rules
create or replace function before_insert_or_update_form_logic_rules_100() returns trigger
  language plpgsql
  security definer
  as $$
  begin
    IF NEW.command = 'JUMP' THEN
      IF NEW.jump_to_id is null THEN
        raise exception 'jump_to_id must be set if command=JUMP';
      END IF;
    ELSE
      IF NEW.jump_to_id is not null then
        raise exception 'jump_to_id must be null if command != JUMP';
      end if;
    END IF;
    IF NEW.position is null then
      NEW.position = (select coalesce(max(position), 0) + 1 from form_logic_rules where form_element_id in (select id from form_elements where form_id = (select form_id from form_elements where id = NEW.form_element_id)));
      -- raise exception 'position is null %', NEW.position;
    end if;
    return NEW;
  end;
$$;

DROP TRIGGER IF EXISTS before_insert_or_update_form_logic_rules_100_trigger on form_logic_rules;
CREATE TRIGGER before_insert_or_update_form_logic_rules_100_trigger BEFORE INSERT OR UPDATE ON public.form_logic_rules FOR EACH ROW EXECUTE FUNCTION public.before_insert_or_update_form_logic_rules_100();



-- Add row-level security rules
--   only project admins can edit
--   anyone can read
alter table form_logic_rules enable row level security;
alter table form_logic_conditions enable row level security;


drop policy if exists form_logic_rules_unprivileged on form_logic_rules;
create policy form_logic_rules_unprivileged on form_logic_rules for select using (true);
drop policy if exists form_logic_conditions_unprivileged on form_logic_conditions;
create policy form_logic_conditions_unprivileged on form_logic_conditions for select using (true); 

drop policy if exists form_logic_rules_admin on form_logic_rules;
CREATE POLICY form_logic_rules_admin ON form_logic_rules TO seasketch_user USING (public.session_is_admin(public.project_id_from_field_id(form_element_id))) WITH CHECK (public.session_is_admin(public.project_id_from_field_id(form_element_id)));

drop policy if exists form_logic_conditions_admin on form_logic_conditions;
CREATE POLICY form_logic_conditions_admin ON form_logic_conditions TO seasketch_user USING (
  session_is_admin(
    project_id_from_field_id((
      select form_element_id from form_logic_rules where id = rule_id
    ))
  )
) WITH CHECK (
  session_is_admin(
    project_id_from_field_id((
      select form_element_id from form_logic_rules where id = rule_id
    ))
  )
);


-- enforce that operators can only be on that the subject field supports
create or replace function before_insert_or_update_form_logic_conditions_100() returns trigger
  language plpgsql
  security definer
  as $$
  declare
    form_element_type_id text;
    is_supported boolean;
  begin
    select type_id into form_element_type_id from form_elements where id = NEW.subject_id;
    select ARRAY[NEW.operator] && supported_operators into is_supported from form_element_types where component_name = form_element_type_id limit 1;
    if is_supported = false then
      raise exception 'Unsupported operator "%" for type %', NEW.operator, form_element_type_id;
    end if;
    return NEW;
  end;
$$;

DROP TRIGGER IF EXISTS before_insert_or_update_form_logic_conditions_100_trigger on form_logic_conditions;
CREATE TRIGGER before_insert_or_update_form_logic_conditions_100_trigger BEFORE INSERT OR UPDATE ON public.form_logic_conditions FOR EACH ROW EXECUTE FUNCTION public.before_insert_or_update_form_logic_conditions_100();

-- add function to reset postions on form_logic_rules

CREATE or replace FUNCTION set_form_logic_rule_order("ruleIds" integer[]) 
  RETURNS SETOF form_logic_rules
  LANGUAGE plpgsql SECURITY DEFINER
  AS $$
  declare
    form_ids int[];
    form_elementid int;
    pos int;
    rule record;
  begin
    select array_agg(form_id) into form_ids from form_elements where id in (
      select form_element_id from form_logic_rules where id = any("ruleIds")
    );
    if array_length(form_ids, 1) > 1 then
      raise exception 'Can only change rule order for a single form at one time';
    end if;
    select form_element_id into form_elementid from form_logic_rules where id = any("ruleIds") limit 1;
    
    if session_is_admin(project_id_from_field_id(form_elementid)) then
      pos = 1;
      -- select rules in order of ruleIds
      -- loop through each, setting a position
      for rule in select * from form_logic_rules where form_element_id in (select id from form_elements where form_id = any(form_ids)) order by array_position("ruleIds", id) loop
        update form_logic_rules set position = pos where id = rule.id;
        pos = pos + 1;
      end loop;
      -- return all the fields in this form
      return query select * from form_logic_rules where form_logic_rules.form_element_id in (select id from form_elements where form_id = any(form_ids)) order by position asc;
    else
      raise exception 'Permission denied';
    end if;
  end
$$;

grant execute on function set_form_logic_rule_order to seasketch_user;
