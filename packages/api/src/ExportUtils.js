var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/ts-invariant/lib/invariant.js
var require_invariant = __commonJS({
  "node_modules/ts-invariant/lib/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = require_tslib();
    var genericMessage = "Invariant Violation";
    var _a = Object.setPrototypeOf;
    var setPrototypeOf = _a === void 0 ? function(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    } : _a;
    var InvariantError = function(_super) {
      tslib.__extends(InvariantError2, _super);
      function InvariantError2(message) {
        if (message === void 0) {
          message = genericMessage;
        }
        var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError2.prototype);
        return _this;
      }
      return InvariantError2;
    }(Error);
    function invariant(condition, message) {
      if (!condition) {
        throw new InvariantError(message);
      }
    }
    var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
    var verbosityLevel = verbosityLevels.indexOf("log");
    function wrapConsoleMethod(name) {
      return function() {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
          var method = console[name] || console.log;
          return method.apply(console, arguments);
        }
      };
    }
    (function(invariant2) {
      invariant2.debug = wrapConsoleMethod("debug");
      invariant2.log = wrapConsoleMethod("log");
      invariant2.warn = wrapConsoleMethod("warn");
      invariant2.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    function setVerbosity(level) {
      var old = verbosityLevels[verbosityLevel];
      verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
      return old;
    }
    var invariant$1 = invariant;
    exports.InvariantError = InvariantError;
    exports["default"] = invariant$1;
    exports.invariant = invariant;
    exports.setVerbosity = setVerbosity;
  }
});

// node_modules/ts-invariant/process/main.js
var require_main = __commonJS({
  "node_modules/ts-invariant/process/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function maybe(thunk) {
      try {
        return thunk();
      } catch (_) {
      }
    }
    var safeGlobal = maybe(function() {
      return globalThis;
    }) || maybe(function() {
      return window;
    }) || maybe(function() {
      return self;
    }) || maybe(function() {
      return global;
    }) || maybe(function() {
      return Function("return this")();
    });
    var needToRemove = false;
    function install() {
      if (safeGlobal && !maybe(function() {
        return process.env.NODE_ENV;
      }) && !maybe(function() {
        return process;
      })) {
        Object.defineProperty(safeGlobal, "process", {
          value: {
            env: {
              NODE_ENV: "production"
            }
          },
          configurable: true,
          enumerable: false,
          writable: true
        });
        needToRemove = true;
      }
    }
    install();
    function remove() {
      if (needToRemove) {
        delete safeGlobal.process;
        needToRemove = false;
      }
    }
    exports.install = install;
    exports.remove = remove;
  }
});

// node_modules/graphql/version.js
var require_version = __commonJS({
  "node_modules/graphql/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.versionInfo = exports.version = void 0;
    var version = "15.6.1";
    exports.version = version;
    var versionInfo = Object.freeze({
      major: 15,
      minor: 6,
      patch: 1,
      preReleaseTag: null
    });
    exports.versionInfo = versionInfo;
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/graphql/jsutils/isPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPromise;
    function isPromise(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isObjectLike;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObjectLike(value) {
      return _typeof(value) == "object" && value !== null;
    }
  }
});

// node_modules/graphql/polyfills/symbols.js
var require_symbols = __commonJS({
  "node_modules/graphql/polyfills/symbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = void 0;
    var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
    exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
    var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
    exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
    var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
    exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getLocation = getLocation;
    function getLocation(source, position) {
      var lineRegexp = /\r\n|[\n\r]/g;
      var line = 1;
      var column = position + 1;
      var match;
      while ((match = lineRegexp.exec(source.body)) && match.index < position) {
        line += 1;
        column = position + 1 - (match.index + match[0].length);
      }
      return {
        line,
        column
      };
    }
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printLocation = printLocation;
    exports.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
    }
    function printSourceLocation(source, sourceLocation) {
      var firstLineColumnOffset = source.locationOffset.column - 1;
      var body = whitespace(firstLineColumnOffset) + source.body;
      var lineIndex = sourceLocation.line - 1;
      var lineOffset = source.locationOffset.line - 1;
      var lineNum = sourceLocation.line + lineOffset;
      var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      var columnNum = sourceLocation.column + columnOffset;
      var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
      var lines = body.split(/\r\n|[\n\r]/g);
      var locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        var subLineIndex = Math.floor(columnNum / 80);
        var subLineColumnNum = columnNum % 80;
        var subLines = [];
        for (var i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
          return ["", subLine];
        }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
      }
      return locationStr + printPrefixedLines([
        ["".concat(lineNum - 1), lines[lineIndex - 1]],
        ["".concat(lineNum), locationLine],
        ["", whitespace(columnNum - 1) + "^"],
        ["".concat(lineNum + 1), lines[lineIndex + 1]]
      ]);
    }
    function printPrefixedLines(lines) {
      var existingLines = lines.filter(function(_ref) {
        var _ = _ref[0], line = _ref[1];
        return line !== void 0;
      });
      var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
        var prefix = _ref2[0];
        return prefix.length;
      }));
      return existingLines.map(function(_ref3) {
        var prefix = _ref3[0], line = _ref3[1];
        return leftPad(padLen, prefix) + (line ? " | " + line : " |");
      }).join("\n");
    }
    function whitespace(len) {
      return Array(len + 1).join(" ");
    }
    function leftPad(len, str) {
      return whitespace(len - str.length) + str;
    }
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printError = printError;
    exports.GraphQLError = void 0;
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _symbols = require_symbols();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var GraphQLError = /* @__PURE__ */ function(_Error) {
      _inherits(GraphQLError2, _Error);
      var _super = _createSuper(GraphQLError2);
      function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
        var _locations2, _source2, _positions2, _extensions2;
        var _this;
        _classCallCheck(this, GraphQLError2);
        _this = _super.call(this, message);
        var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : void 0 : nodes ? [nodes] : void 0;
        var _source = source;
        if (!_source && _nodes) {
          var _nodes$0$loc;
          _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
        }
        var _positions = positions;
        if (!_positions && _nodes) {
          _positions = _nodes.reduce(function(list, node) {
            if (node.loc) {
              list.push(node.loc.start);
            }
            return list;
          }, []);
        }
        if (_positions && _positions.length === 0) {
          _positions = void 0;
        }
        var _locations;
        if (positions && source) {
          _locations = positions.map(function(pos) {
            return (0, _location.getLocation)(source, pos);
          });
        } else if (_nodes) {
          _locations = _nodes.reduce(function(list, node) {
            if (node.loc) {
              list.push((0, _location.getLocation)(node.loc.source, node.loc.start));
            }
            return list;
          }, []);
        }
        var _extensions = extensions;
        if (_extensions == null && originalError != null) {
          var originalExtensions = originalError.extensions;
          if ((0, _isObjectLike.default)(originalExtensions)) {
            _extensions = originalExtensions;
          }
        }
        Object.defineProperties(_assertThisInitialized(_this), {
          name: {
            value: "GraphQLError"
          },
          message: {
            value: message,
            enumerable: true,
            writable: true
          },
          locations: {
            value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : void 0,
            enumerable: _locations != null
          },
          path: {
            value: path !== null && path !== void 0 ? path : void 0,
            enumerable: path != null
          },
          nodes: {
            value: _nodes !== null && _nodes !== void 0 ? _nodes : void 0
          },
          source: {
            value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : void 0
          },
          positions: {
            value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : void 0
          },
          originalError: {
            value: originalError
          },
          extensions: {
            value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : void 0,
            enumerable: _extensions != null
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
          return _possibleConstructorReturn(_this);
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
        } else {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
        return _this;
      }
      _createClass(GraphQLError2, [{
        key: "toString",
        value: function toString() {
          return printError(this);
        }
      }, {
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "Object";
        }
      }]);
      return GraphQLError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    exports.GraphQLError = GraphQLError;
    function printError(error) {
      var output = error.message;
      if (error.nodes) {
        for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
          var node = _error$nodes2[_i2];
          if (node.loc) {
            output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
          }
        }
      } else if (error.source && error.locations) {
        for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
          var location = _error$locations2[_i4];
          output += "\n\n" + (0, _printLocation.printSourceLocation)(error.source, location);
        }
      }
      return output;
    }
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
    }
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Kind = void 0;
    var Kind = Object.freeze({
      NAME: "Name",
      DOCUMENT: "Document",
      OPERATION_DEFINITION: "OperationDefinition",
      VARIABLE_DEFINITION: "VariableDefinition",
      SELECTION_SET: "SelectionSet",
      FIELD: "Field",
      ARGUMENT: "Argument",
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_FRAGMENT: "InlineFragment",
      FRAGMENT_DEFINITION: "FragmentDefinition",
      VARIABLE: "Variable",
      INT: "IntValue",
      FLOAT: "FloatValue",
      STRING: "StringValue",
      BOOLEAN: "BooleanValue",
      NULL: "NullValue",
      ENUM: "EnumValue",
      LIST: "ListValue",
      OBJECT: "ObjectValue",
      OBJECT_FIELD: "ObjectField",
      DIRECTIVE: "Directive",
      NAMED_TYPE: "NamedType",
      LIST_TYPE: "ListType",
      NON_NULL_TYPE: "NonNullType",
      SCHEMA_DEFINITION: "SchemaDefinition",
      OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
      SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
      OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
      FIELD_DEFINITION: "FieldDefinition",
      INPUT_VALUE_DEFINITION: "InputValueDefinition",
      INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
      UNION_TYPE_DEFINITION: "UnionTypeDefinition",
      ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
      ENUM_VALUE_DEFINITION: "EnumValueDefinition",
      INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
      DIRECTIVE_DEFINITION: "DirectiveDefinition",
      SCHEMA_EXTENSION: "SchemaExtension",
      SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
      OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
      INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
      UNION_TYPE_EXTENSION: "UnionTypeExtension",
      ENUM_TYPE_EXTENSION: "EnumTypeExtension",
      INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    });
    exports.Kind = Kind;
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = invariant;
    function invariant(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
      }
    }
  }
});

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js
var require_nodejsCustomInspectSymbol = __commonJS({
  "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    var _default = nodejsCustomInspectSymbol;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/defineInspect.js
var require_defineInspect = __commonJS({
  "node_modules/graphql/jsutils/defineInspect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = defineInspect;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function defineInspect(classObject) {
      var fn = classObject.prototype.toJSON;
      typeof fn === "function" || (0, _invariant.default)(0);
      classObject.prototype.inspect = fn;
      if (_nodejsCustomInspectSymbol.default) {
        classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;
      }
    }
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isNode = isNode;
    exports.Token = exports.Location = void 0;
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = /* @__PURE__ */ function() {
      function Location2(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      var _proto = Location2.prototype;
      _proto.toJSON = function toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      };
      return Location2;
    }();
    exports.Location = Location;
    (0, _defineInspect.default)(Location);
    var Token = /* @__PURE__ */ function() {
      function Token2(kind, start, end, line, column, prev, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = prev;
        this.next = null;
      }
      var _proto2 = Token2.prototype;
      _proto2.toJSON = function toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      };
      return Token2;
    }();
    exports.Token = Token;
    (0, _defineInspect.default)(Token);
    function isNode(maybeNode) {
      return maybeNode != null && typeof maybeNode.kind === "string";
    }
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TokenKind = void 0;
    var TokenKind = Object.freeze({
      SOF: "<SOF>",
      EOF: "<EOF>",
      BANG: "!",
      DOLLAR: "$",
      AMP: "&",
      PAREN_L: "(",
      PAREN_R: ")",
      SPREAD: "...",
      COLON: ":",
      EQUALS: "=",
      AT: "@",
      BRACKET_L: "[",
      BRACKET_R: "]",
      BRACE_L: "{",
      PIPE: "|",
      BRACE_R: "}",
      NAME: "Name",
      INT: "Int",
      FLOAT: "Float",
      STRING: "String",
      BLOCK_STRING: "BlockString",
      COMMENT: "Comment"
    });
    exports.TokenKind = TokenKind;
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inspect;
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect(value) {
      return formatValue(value, []);
    }
    function formatValue(value, seenValues) {
      switch (_typeof(value)) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? "[function ".concat(value.name, "]") : "[function]";
        case "object":
          if (value === null) {
            return "null";
          }
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (previouslySeenValues.indexOf(value) !== -1) {
        return "[Circular]";
      }
      var seenValues = [].concat(previouslySeenValues, [value]);
      var customInspectFn = getCustomFn(value);
      if (customInspectFn !== void 0) {
        var customValue = customInspectFn.call(value);
        if (customValue !== value) {
          return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function formatObject(object, seenValues) {
      var keys = Object.keys(object);
      if (keys.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      var properties = keys.map(function(key) {
        var value = formatValue(object[key], seenValues);
        return key + ": " + value;
      });
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      var len = Math.min(MAX_ARRAY_LENGTH, array.length);
      var remaining = array.length - len;
      var items = [];
      for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push("... ".concat(remaining, " more items"));
      }
      return "[" + items.join(", ") + "]";
    }
    function getCustomFn(object) {
      var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];
      if (typeof customInspectFn === "function") {
        return customInspectFn;
      }
      if (typeof object.inspect === "function") {
        return object.inspect;
      }
    }
    function getObjectTag(object) {
      var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        var name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = devAssert;
    function devAssert(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var _default = process.env.NODE_ENV === "production" ? function instanceOf(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (_typeof(value) === "object" && value !== null) {
        var _value$constructor;
        var className = constructor.prototype[Symbol.toStringTag];
        var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          var stringifiedValue = (0, _inspect.default)(value);
          throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
        }
      }
      return false;
    };
    exports.default = _default;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSource = isSource;
    exports.Source = void 0;
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Source = /* @__PURE__ */ function() {
      function Source2(body) {
        var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
        var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          line: 1,
          column: 1
        };
        typeof body === "string" || (0, _devAssert.default)(0, "Body must be a string. Received: ".concat((0, _inspect.default)(body), "."));
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.default)(0, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, _devAssert.default)(0, "column in locationOffset is 1-indexed and must be positive.");
      }
      _createClass(Source2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "Source";
        }
      }]);
      return Source2;
    }();
    exports.Source = Source;
    function isSource(source) {
      return (0, _instanceOf.default)(source, Source);
    }
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DirectiveLocation = void 0;
    var DirectiveLocation = Object.freeze({
      QUERY: "QUERY",
      MUTATION: "MUTATION",
      SUBSCRIPTION: "SUBSCRIPTION",
      FIELD: "FIELD",
      FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
      FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
      INLINE_FRAGMENT: "INLINE_FRAGMENT",
      VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
      SCHEMA: "SCHEMA",
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      FIELD_DEFINITION: "FIELD_DEFINITION",
      ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      ENUM_VALUE: "ENUM_VALUE",
      INPUT_OBJECT: "INPUT_OBJECT",
      INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    });
    exports.DirectiveLocation = DirectiveLocation;
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dedentBlockStringValue = dedentBlockStringValue;
    exports.getBlockStringIndentation = getBlockStringIndentation;
    exports.printBlockString = printBlockString;
    function dedentBlockStringValue(rawString) {
      var lines = rawString.split(/\r\n|[\n\r]/g);
      var commonIndent = getBlockStringIndentation(rawString);
      if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      var startLine = 0;
      while (startLine < lines.length && isBlank(lines[startLine])) {
        ++startLine;
      }
      var endLine = lines.length;
      while (endLine > startLine && isBlank(lines[endLine - 1])) {
        --endLine;
      }
      return lines.slice(startLine, endLine).join("\n");
    }
    function isBlank(str) {
      for (var i = 0; i < str.length; ++i) {
        if (str[i] !== " " && str[i] !== "	") {
          return false;
        }
      }
      return true;
    }
    function getBlockStringIndentation(value) {
      var _commonIndent;
      var isFirstLine = true;
      var isEmptyLine = true;
      var indent = 0;
      var commonIndent = null;
      for (var i = 0; i < value.length; ++i) {
        switch (value.charCodeAt(i)) {
          case 13:
            if (value.charCodeAt(i + 1) === 10) {
              ++i;
            }
          case 10:
            isFirstLine = false;
            isEmptyLine = true;
            indent = 0;
            break;
          case 9:
          case 32:
            ++indent;
            break;
          default:
            if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
              commonIndent = indent;
            }
            isEmptyLine = false;
        }
      }
      return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
    }
    function printBlockString(value) {
      var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isSingleLine = value.indexOf("\n") === -1;
      var hasLeadingSpace = value[0] === " " || value[0] === "	";
      var hasTrailingQuote = value[value.length - 1] === '"';
      var hasTrailingSlash = value[value.length - 1] === "\\";
      var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
      var result = "";
      if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
        result += "\n" + indentation;
      }
      result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
      if (printAsMultipleLines) {
        result += "\n";
      }
      return '"""' + result.replace(/"""/g, '\\"""') + '"""';
    }
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
    exports.Lexer = void 0;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _blockString = require_blockString();
    var Lexer = /* @__PURE__ */ function() {
      function Lexer2(source) {
        var startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      var _proto = Lexer2.prototype;
      _proto.advance = function advance() {
        this.lastToken = this.token;
        var token = this.token = this.lookahead();
        return token;
      };
      _proto.lookahead = function lookahead() {
        var token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            var _token$next;
            token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      };
      return Lexer2;
    }();
    exports.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    function printCharCode(code) {
      return isNaN(code) ? _tokenKind.TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
    }
    function readToken(lexer, prev) {
      var source = lexer.source;
      var body = source.body;
      var bodyLength = body.length;
      var pos = prev.end;
      while (pos < bodyLength) {
        var code = body.charCodeAt(pos);
        var _line = lexer.line;
        var _col = 1 + pos - lexer.lineStart;
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++pos;
            continue;
          case 10:
            ++pos;
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 13:
            if (body.charCodeAt(pos + 1) === 10) {
              pos += 2;
            } else {
              ++pos;
            }
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 33:
            return new _ast.Token(_tokenKind.TokenKind.BANG, pos, pos + 1, _line, _col, prev);
          case 35:
            return readComment(source, pos, _line, _col, prev);
          case 36:
            return new _ast.Token(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
          case 38:
            return new _ast.Token(_tokenKind.TokenKind.AMP, pos, pos + 1, _line, _col, prev);
          case 40:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
          case 41:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
          case 46:
            if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
              return new _ast.Token(_tokenKind.TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
            }
            break;
          case 58:
            return new _ast.Token(_tokenKind.TokenKind.COLON, pos, pos + 1, _line, _col, prev);
          case 61:
            return new _ast.Token(_tokenKind.TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
          case 64:
            return new _ast.Token(_tokenKind.TokenKind.AT, pos, pos + 1, _line, _col, prev);
          case 91:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
          case 93:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
          case 123:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
          case 124:
            return new _ast.Token(_tokenKind.TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
          case 125:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
          case 34:
            if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
              return readBlockString(source, pos, _line, _col, prev, lexer);
            }
            return readString(source, pos, _line, _col, prev);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return readNumber(source, pos, code, _line, _col, prev);
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 95:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            return readName(source, pos, _line, _col, prev);
        }
        throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
      }
      var line = lexer.line;
      var col = 1 + pos - lexer.lineStart;
      return new _ast.Token(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
    }
    function unexpectedCharacterMessage(code) {
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
      }
      if (code === 39) {
        return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
      }
      return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
    }
    function readComment(source, start, line, col, prev) {
      var body = source.body;
      var code;
      var position = start;
      do {
        code = body.charCodeAt(++position);
      } while (!isNaN(code) && (code > 31 || code === 9));
      return new _ast.Token(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
    }
    function readNumber(source, start, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position = start;
      var isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if (code >= 48 && code <= 57) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || isNameStart(code)) {
        throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
      }
      return new _ast.Token(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
    }
    function readDigits(source, start, firstCode) {
      var body = source.body;
      var position = start;
      var code = firstCode;
      if (code >= 48 && code <= 57) {
        do {
          code = body.charCodeAt(++position);
        } while (code >= 48 && code <= 57);
        return position;
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    function readString(source, start, line, col, prev) {
      var body = source.body;
      var position = start + 1;
      var chunkStart = position;
      var code = 0;
      var value = "";
      while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return new _ast.Token(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);
        }
        if (code < 32 && code !== 9) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        ++position;
        if (code === 92) {
          value += body.slice(chunkStart, position - 1);
          code = body.charCodeAt(position);
          switch (code) {
            case 34:
              value += '"';
              break;
            case 47:
              value += "/";
              break;
            case 92:
              value += "\\";
              break;
            case 98:
              value += "\b";
              break;
            case 102:
              value += "\f";
              break;
            case 110:
              value += "\n";
              break;
            case 114:
              value += "\r";
              break;
            case 116:
              value += "	";
              break;
            case 117: {
              var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
              if (charCode < 0) {
                var invalidSequence = body.slice(position + 1, position + 5);
                throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
              }
              value += String.fromCharCode(charCode);
              position += 4;
              break;
            }
            default:
              throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }
          ++position;
          chunkStart = position;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
    }
    function readBlockString(source, start, line, col, prev, lexer) {
      var body = source.body;
      var position = start + 3;
      var chunkStart = position;
      var code = 0;
      var rawValue = "";
      while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          rawValue += body.slice(chunkStart, position);
          return new _ast.Token(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
        }
        if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        if (code === 10) {
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          rawValue += body.slice(chunkStart, position) + '"""';
          position += 4;
          chunkStart = position;
        } else {
          ++position;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
    }
    function uniCharCode(a, b, c, d) {
      return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
    }
    function char2hex(a) {
      return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
    }
    function readName(source, start, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position = start + 1;
      var code = 0;
      while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
        ++position;
      }
      return new _ast.Token(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
    }
    function isNameStart(code) {
      return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parse = parse;
    exports.parseValue = parseValue;
    exports.parseType = parseType;
    exports.Parser = void 0;
    var _syntaxError = require_syntaxError();
    var _kinds = require_kinds();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _source = require_source();
    var _directiveLocation = require_directiveLocation();
    var _lexer = require_lexer();
    function parse(source, options) {
      var parser = new Parser(source, options);
      return parser.parseDocument();
    }
    function parseValue(source, options) {
      var parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseType(source, options) {
      var parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(source, options) {
        var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
      }
      var _proto = Parser2.prototype;
      _proto.parseName = function parseName() {
        var token = this.expectToken(_tokenKind.TokenKind.NAME);
        return {
          kind: _kinds.Kind.NAME,
          value: token.value,
          loc: this.loc(token)
        };
      };
      _proto.parseDocument = function parseDocument() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
          loc: this.loc(start)
        };
      };
      _proto.parseDefinition = function parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          switch (this._lexer.token.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "schema":
            case "scalar":
            case "type":
            case "interface":
            case "union":
            case "enum":
            case "input":
            case "directive":
              return this.parseTypeSystemDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        } else if (this.peekDescription()) {
          return this.parseTypeSystemDefinition();
        }
        throw this.unexpected();
      };
      _proto.parseOperationDefinition = function parseOperationDefinition() {
        var start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: "query",
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        var operation = this.parseOperationType();
        var name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseOperationType = function parseOperationType() {
        var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return "query";
          case "mutation":
            return "mutation";
          case "subscription":
            return "subscription";
        }
        throw this.unexpected(operationToken);
      };
      _proto.parseVariableDefinitions = function parseVariableDefinitions() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseVariableDefinition = function parseVariableDefinition() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
          directives: this.parseDirectives(true),
          loc: this.loc(start)
        };
      };
      _proto.parseVariable = function parseVariable() {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseSelectionSet = function parseSelectionSet() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseSelection = function parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      };
      _proto.parseField = function parseField() {
        var start = this._lexer.token;
        var nameOrAlias = this.parseName();
        var alias;
        var name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
          loc: this.loc(start)
        };
      };
      _proto.parseArguments = function parseArguments(isConst) {
        var item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseArgument = function parseArgument() {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(false),
          loc: this.loc(start)
        };
      };
      _proto.parseConstArgument = function parseConstArgument() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.ARGUMENT,
          name: this.parseName(),
          value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
          loc: this.loc(start)
        };
      };
      _proto.parseFragment = function parseFragment() {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        var hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false),
            loc: this.loc(start)
          };
        }
        return {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentDefinition = function parseFragmentDefinition() {
        var _this$_options;
        var start = this._lexer.token;
        this.expectKeyword("fragment");
        if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
          return {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        return {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentName = function parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      };
      _proto.parseValueLiteral = function parseValueLiteral(isConst) {
        var token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.INT,
              value: token.value,
              loc: this.loc(token)
            };
          case _tokenKind.TokenKind.FLOAT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.FLOAT,
              value: token.value,
              loc: this.loc(token)
            };
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this._lexer.advance();
            switch (token.value) {
              case "true":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true,
                  loc: this.loc(token)
                };
              case "false":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false,
                  loc: this.loc(token)
                };
              case "null":
                return {
                  kind: _kinds.Kind.NULL,
                  loc: this.loc(token)
                };
              default:
                return {
                  kind: _kinds.Kind.ENUM,
                  value: token.value,
                  loc: this.loc(token)
                };
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (!isConst) {
              return this.parseVariable();
            }
            break;
        }
        throw this.unexpected();
      };
      _proto.parseStringLiteral = function parseStringLiteral() {
        var token = this._lexer.token;
        this._lexer.advance();
        return {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
          loc: this.loc(token)
        };
      };
      _proto.parseList = function parseList(isConst) {
        var _this = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this.parseValueLiteral(isConst);
        };
        return {
          kind: _kinds.Kind.LIST,
          values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObject = function parseObject(isConst) {
        var _this2 = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this2.parseObjectField(isConst);
        };
        return {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObjectField = function parseObjectField(isConst) {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseDirectives = function parseDirectives(isConst) {
        var directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      };
      _proto.parseDirective = function parseDirective(isConst) {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeReference = function parseTypeReference() {
        var start = this._lexer.token;
        var type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          type = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = {
            kind: _kinds.Kind.LIST_TYPE,
            type,
            loc: this.loc(start)
          };
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type,
            loc: this.loc(start)
          };
        }
        return type;
      };
      _proto.parseNamedType = function parseNamedType() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
        var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.peekDescription = function peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      };
      _proto.parseDescription = function parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      };
      _proto.parseSchemaDefinition = function parseSchemaDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        return {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
        var start = this._lexer.token;
        var operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseNamedType();
        return {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("scalar");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("type");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
        var _this$_options2;
        if (!this.expectOptionalKeyword("implements")) {
          return [];
        }
        if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
          var types = [];
          this.expectOptionalToken(_tokenKind.TokenKind.AMP);
          do {
            types.push(this.parseNamedType());
          } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || this.peek(_tokenKind.TokenKind.NAME));
          return types;
        }
        return this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType);
      };
      _proto.parseFieldsDefinition = function parseFieldsDefinition() {
        var _this$_options3;
        if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
          this._lexer.advance();
          this._lexer.advance();
          return [];
        }
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseFieldDefinition = function parseFieldDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseArgumentDefs = function parseArgumentDefs() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseInputValueDef = function parseInputValueDef() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseValueLiteral(true);
        }
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("interface");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("union");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        return {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      };
      _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("enum");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        return {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("input");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
        var keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.parseSchemaExtension = function parseSchemaExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        var repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        var locations = this.parseDirectiveLocations();
        return {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveLocations = function parseDirectiveLocations() {
        return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
      };
      _proto.parseDirectiveLocation = function parseDirectiveLocation() {
        var start = this._lexer.token;
        var name = this.parseName();
        if (_directiveLocation.DirectiveLocation[name.value] !== void 0) {
          return name;
        }
        throw this.unexpected(start);
      };
      _proto.loc = function loc(startToken) {
        var _this$_options4;
        if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
          return new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
      };
      _proto.peek = function peek(kind) {
        return this._lexer.token.kind === kind;
      };
      _proto.expectToken = function expectToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
      };
      _proto.expectOptionalToken = function expectOptionalToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        return void 0;
      };
      _proto.expectKeyword = function expectKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
        } else {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
        }
      };
      _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
          return true;
        }
        return false;
      };
      _proto.unexpected = function unexpected(atToken) {
        var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
      };
      _proto.any = function any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      };
      _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          var nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      };
      _proto.many = function many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      };
      _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      };
      return Parser2;
    }();
    exports.Parser = Parser;
    function getTokenDesc(token) {
      var value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
    }
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? '"'.concat(kind, '"') : kind;
    }
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/graphql/language/visitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.visit = visit;
    exports.visitInParallel = visitInParallel;
    exports.getVisitFn = getVisitFn;
    exports.BREAK = exports.QueryDocumentKeys = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    var _ast = require_ast();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
      InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports.QueryDocumentKeys = QueryDocumentKeys;
    var BREAK = Object.freeze({});
    exports.BREAK = BREAK;
    function visit(root, visitor) {
      var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
      var stack = void 0;
      var inArray = Array.isArray(root);
      var keys = [root];
      var index = -1;
      var edits = [];
      var node = void 0;
      var key = void 0;
      var parent = void 0;
      var path = [];
      var ancestors = [];
      var newRoot = root;
      do {
        index++;
        var isLeaving = index === keys.length;
        var isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
            } else {
              var clone = {};
              for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
                var k = _Object$keys2[_i2];
                clone[k] = node[k];
              }
              node = clone;
            }
            var editOffset = 0;
            for (var ii = 0; ii < edits.length; ii++) {
              var editKey = edits[ii][0];
              var editValue = edits[ii][1];
              if (inArray) {
                editKey -= editOffset;
              }
              if (inArray && editValue === null) {
                node.splice(editKey, 1);
                editOffset++;
              } else {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else {
          key = parent ? inArray ? index : keys[index] : void 0;
          node = parent ? parent[key] : newRoot;
          if (node === null || node === void 0) {
            continue;
          }
          if (parent) {
            path.push(key);
          }
        }
        var result = void 0;
        if (!Array.isArray(node)) {
          if (!(0, _ast.isNode)(node)) {
            throw new Error("Invalid AST Node: ".concat((0, _inspect.default)(node), "."));
          }
          var visitFn = getVisitFn(visitor, node.kind, isLeaving);
          if (visitFn) {
            result = visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _visitorKeys$node$kin;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        newRoot = edits[edits.length - 1][1];
      }
      return newRoot;
    }
    function visitInParallel(visitors) {
      var skipping = new Array(visitors.length);
      return {
        enter: function enter(node) {
          for (var i = 0; i < visitors.length; i++) {
            if (skipping[i] == null) {
              var fn = getVisitFn(visitors[i], node.kind, false);
              if (fn) {
                var result = fn.apply(visitors[i], arguments);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          }
        },
        leave: function leave(node) {
          for (var i = 0; i < visitors.length; i++) {
            if (skipping[i] == null) {
              var fn = getVisitFn(visitors[i], node.kind, true);
              if (fn) {
                var result = fn.apply(visitors[i], arguments);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              }
            } else if (skipping[i] === node) {
              skipping[i] = null;
            }
          }
        }
      };
    }
    function getVisitFn(visitor, kind, isLeaving) {
      var kindVisitor = visitor[kind];
      if (kindVisitor) {
        if (!isLeaving && typeof kindVisitor === "function") {
          return kindVisitor;
        }
        var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
        if (typeof kindSpecificVisitor === "function") {
          return kindSpecificVisitor;
        }
      } else {
        var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
        if (specificVisitor) {
          if (typeof specificVisitor === "function") {
            return specificVisitor;
          }
          var specificKindVisitor = specificVisitor[kind];
          if (typeof specificKindVisitor === "function") {
            return specificKindVisitor;
          }
        }
      }
    }
  }
});

// node_modules/graphql/polyfills/find.js
var require_find = __commonJS({
  "node_modules/graphql/polyfills/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var find = Array.prototype.find ? function(list, predicate) {
      return Array.prototype.find.call(list, predicate);
    } : function(list, predicate) {
      for (var _i2 = 0; _i2 < list.length; _i2++) {
        var value = list[_i2];
        if (predicate(value)) {
          return value;
        }
      }
    };
    var _default = find;
    exports.default = _default;
  }
});

// node_modules/graphql/polyfills/objectValues.js
var require_objectValues = __commonJS({
  "node_modules/graphql/polyfills/objectValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var objectValues = Object.values || function(obj) {
      return Object.keys(obj).map(function(key) {
        return obj[key];
      });
    };
    var _default = objectValues;
    exports.default = _default;
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/graphql/error/locatedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.locatedError = locatedError;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      var originalError = rawOriginalError instanceof Error ? rawOriginalError : new Error("Unexpected error value: " + (0, _inspect.default)(rawOriginalError));
      if (Array.isArray(originalError.path)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);
    }
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/graphql/utilities/assertValidName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertValidName = assertValidName;
    exports.isValidNameError = isValidNameError;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _GraphQLError = require_GraphQLError();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    function assertValidName(name) {
      var error = isValidNameError(name);
      if (error) {
        throw error;
      }
      return name;
    }
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.default)(0, "Expected name to be a string.");
      if (name.length > 1 && name[0] === "_" && name[1] === "_") {
        return new _GraphQLError.GraphQLError('Name "'.concat(name, '" must not begin with "__", which is reserved by GraphQL introspection.'));
      }
      if (!NAME_RX.test(name)) {
        return new _GraphQLError.GraphQLError('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(name, '" does not.'));
      }
    }
  }
});

// node_modules/graphql/polyfills/objectEntries.js
var require_objectEntries = __commonJS({
  "node_modules/graphql/polyfills/objectEntries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var objectEntries = Object.entries || function(obj) {
      return Object.keys(obj).map(function(key) {
        return [key, obj[key]];
      });
    };
    var _default = objectEntries;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/graphql/jsutils/keyMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = keyMap;
    function keyMap(list, keyFn) {
      return list.reduce(function(map, item) {
        map[keyFn(item)] = item;
        return map;
      }, /* @__PURE__ */ Object.create(null));
    }
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/graphql/jsutils/mapValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mapValue;
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function mapValue(map, fn) {
      var result = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(map); _i2 < _objectEntries2.length; _i2++) {
        var _ref2 = _objectEntries2[_i2];
        var _key = _ref2[0];
        var _value = _ref2[1];
        result[_key] = fn(_value, _key);
      }
      return result;
    }
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/graphql/jsutils/toObjMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toObjMap;
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toObjMap(obj) {
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      var map = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(obj); _i2 < _objectEntries2.length; _i2++) {
        var _ref2 = _objectEntries2[_i2];
        var key = _ref2[0];
        var value = _ref2[1];
        map[key] = value;
      }
      return map;
    }
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/graphql/jsutils/keyValMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      return list.reduce(function(map, item) {
        map[keyFn(item)] = valFn(item);
        return map;
      }, /* @__PURE__ */ Object.create(null));
    }
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/graphql/jsutils/didYouMean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      var _ref = typeof firstArg === "string" ? [firstArg, secondArg] : [void 0, firstArg], subMessage = _ref[0], suggestionsArg = _ref[1];
      var message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      var suggestions = suggestionsArg.map(function(x) {
        return '"'.concat(x, '"');
      });
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      var selected = suggestions.slice(0, MAX_SUGGESTIONS);
      var lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/graphql/jsutils/identityFunc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = identityFunc;
    function identityFunc(x) {
      return x;
    }
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/graphql/jsutils/naturalCompare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = naturalCompare;
    function naturalCompare(aStr, bStr) {
      var aIdx = 0;
      var bIdx = 0;
      while (aIdx < aStr.length && bIdx < bStr.length) {
        var aChar = aStr.charCodeAt(aIdx);
        var bChar = bStr.charCodeAt(bIdx);
        if (isDigit(aChar) && isDigit(bChar)) {
          var aNum = 0;
          do {
            ++aIdx;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIdx);
          } while (isDigit(aChar) && aNum > 0);
          var bNum = 0;
          do {
            ++bIdx;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIdx);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIdx;
          ++bIdx;
        }
      }
      return aStr.length - bStr.length;
    }
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/graphql/jsutils/suggestionList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = suggestionList;
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function suggestionList(input, options) {
      var optionsByDistance = /* @__PURE__ */ Object.create(null);
      var lexicalDistance = new LexicalDistance(input);
      var threshold = Math.floor(input.length * 0.4) + 1;
      for (var _i2 = 0; _i2 < options.length; _i2++) {
        var option = options[_i2];
        var distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort(function(a, b) {
        var distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.default)(a, b);
      });
    }
    var LexicalDistance = /* @__PURE__ */ function() {
      function LexicalDistance2(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];
      }
      var _proto = LexicalDistance2.prototype;
      _proto.measure = function measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        var optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        var a = stringToArray(optionLowerCase);
        var b = this._inputArray;
        if (a.length < b.length) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var aLength = a.length;
        var bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        var rows = this._rows;
        for (var j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (var i = 1; i <= aLength; i++) {
          var upRow = rows[(i - 1) % 3];
          var currentRow = rows[i % 3];
          var smallestCell = currentRow[0] = i;
          for (var _j = 1; _j <= bLength; _j++) {
            var cost = a[i - 1] === b[_j - 1] ? 0 : 1;
            var currentCell = Math.min(upRow[_j] + 1, currentRow[_j - 1] + 1, upRow[_j - 1] + cost);
            if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {
              var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[_j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        var distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      };
      return LexicalDistance2;
    }();
    function stringToArray(str) {
      var strLength = str.length;
      var array = new Array(strLength);
      for (var i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/graphql/language/printer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.print = print;
    var _visitor = require_visitor();
    var _blockString = require_blockString();
    function print(ast) {
      return (0, _visitor.visit)(ast, {
        leave: printDocASTReducer
      });
    }
    var MAX_LINE_LENGTH = 80;
    var printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return "$" + node.name;
      },
      Document: function Document(node) {
        return join(node.definitions, "\n\n") + "\n";
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name = node.name;
        var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        var directives = join(node.directives, " ");
        var selectionSet = node.selectionSet;
        return !name && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], " ");
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable, type = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
        return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias, name = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
        var prefix = wrap("", alias, ": ") + name;
        var argsLine = prefix + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      },
      Argument: function Argument(_ref4) {
        var name = _ref4.name, value = _ref4.value;
        return name + ": " + value;
      },
      FragmentSpread: function FragmentSpread(_ref5) {
        var name = _ref5.name, directives = _ref5.directives;
        return "..." + name + wrap(" ", join(directives, " "));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
        return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
        return "fragment ".concat(name).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
      },
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value, isBlockString = _ref10.block;
        return isBlockString ? (0, _blockString.printBlockString)(value, key === "description" ? "" : "  ") : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? "true" : "false";
      },
      NullValue: function NullValue() {
        return "null";
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return "[" + join(values, ", ") + "]";
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields = _ref14.fields;
        return "{" + join(fields, ", ") + "}";
      },
      ObjectField: function ObjectField(_ref15) {
        var name = _ref15.name, value = _ref15.value;
        return name + ": " + value;
      },
      Directive: function Directive(_ref16) {
        var name = _ref16.name, args = _ref16.arguments;
        return "@" + name + wrap("(", join(args, ", "), ")");
      },
      NamedType: function NamedType(_ref17) {
        var name = _ref17.name;
        return name;
      },
      ListType: function ListType(_ref18) {
        var type = _ref18.type;
        return "[" + type + "]";
      },
      NonNullType: function NonNullType(_ref19) {
        var type = _ref19.type;
        return type + "!";
      },
      SchemaDefinition: addDescription(function(_ref20) {
        var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
        return join(["schema", join(directives, " "), block(operationTypes)], " ");
      }),
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation, type = _ref21.type;
        return operation + ": " + type;
      },
      ScalarTypeDefinition: addDescription(function(_ref22) {
        var name = _ref22.name, directives = _ref22.directives;
        return join(["scalar", name, join(directives, " ")], " ");
      }),
      ObjectTypeDefinition: addDescription(function(_ref23) {
        var name = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
        return join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      }),
      FieldDefinition: addDescription(function(_ref24) {
        var name = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
        return name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
      }),
      InputValueDefinition: addDescription(function(_ref25) {
        var name = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
        return join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
      }),
      InterfaceTypeDefinition: addDescription(function(_ref26) {
        var name = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
        return join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      }),
      UnionTypeDefinition: addDescription(function(_ref27) {
        var name = _ref27.name, directives = _ref27.directives, types = _ref27.types;
        return join(["union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      }),
      EnumTypeDefinition: addDescription(function(_ref28) {
        var name = _ref28.name, directives = _ref28.directives, values = _ref28.values;
        return join(["enum", name, join(directives, " "), block(values)], " ");
      }),
      EnumValueDefinition: addDescription(function(_ref29) {
        var name = _ref29.name, directives = _ref29.directives;
        return join([name, join(directives, " ")], " ");
      }),
      InputObjectTypeDefinition: addDescription(function(_ref30) {
        var name = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
        return join(["input", name, join(directives, " "), block(fields)], " ");
      }),
      DirectiveDefinition: addDescription(function(_ref31) {
        var name = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
        return "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
        return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name = _ref33.name, directives = _ref33.directives;
        return join(["extend scalar", name, join(directives, " ")], " ");
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
        return join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
        return join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name = _ref36.name, directives = _ref36.directives, types = _ref36.types;
        return join(["extend union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name = _ref37.name, directives = _ref37.directives, values = _ref37.values;
        return join(["extend enum", name, join(directives, " "), block(values)], " ");
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
        return join(["extend input", name, join(directives, " "), block(fields)], " ");
      }
    };
    function addDescription(cb) {
      return function(node) {
        return join([node.description, cb(node)], "\n");
      };
    }
    function join(maybeArray) {
      var _maybeArray$filter$jo;
      var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x) {
        return x;
      }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    function block(array) {
      return wrap("{\n", indent(join(array, "\n")), "\n}");
    }
    function wrap(start, maybeString) {
      var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    function indent(str) {
      return wrap("  ", str.replace(/\n/g, "\n  "));
    }
    function isMultiline(str) {
      return str.indexOf("\n") !== -1;
    }
    function hasMultilineItems(maybeArray) {
      return maybeArray != null && maybeArray.some(isMultiline);
    }
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valueFromASTUntyped = valueFromASTUntyped;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _kinds = require_kinds();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(function(node) {
            return valueFromASTUntyped(node, variables);
          });
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.default)(valueNode.fields, function(field) {
            return field.name.value;
          }, function(field) {
            return valueFromASTUntyped(field.value, variables);
          });
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
      (0, _invariant.default)(0, "Unexpected value node: " + (0, _inspect.default)(valueNode));
    }
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/graphql/type/definition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isType = isType;
    exports.assertType = assertType;
    exports.isScalarType = isScalarType;
    exports.assertScalarType = assertScalarType;
    exports.isObjectType = isObjectType;
    exports.assertObjectType = assertObjectType;
    exports.isInterfaceType = isInterfaceType;
    exports.assertInterfaceType = assertInterfaceType;
    exports.isUnionType = isUnionType;
    exports.assertUnionType = assertUnionType;
    exports.isEnumType = isEnumType;
    exports.assertEnumType = assertEnumType;
    exports.isInputObjectType = isInputObjectType;
    exports.assertInputObjectType = assertInputObjectType;
    exports.isListType = isListType;
    exports.assertListType = assertListType;
    exports.isNonNullType = isNonNullType;
    exports.assertNonNullType = assertNonNullType;
    exports.isInputType = isInputType;
    exports.assertInputType = assertInputType;
    exports.isOutputType = isOutputType;
    exports.assertOutputType = assertOutputType;
    exports.isLeafType = isLeafType;
    exports.assertLeafType = assertLeafType;
    exports.isCompositeType = isCompositeType;
    exports.assertCompositeType = assertCompositeType;
    exports.isAbstractType = isAbstractType;
    exports.assertAbstractType = assertAbstractType;
    exports.GraphQLList = GraphQLList;
    exports.GraphQLNonNull = GraphQLNonNull;
    exports.isWrappingType = isWrappingType;
    exports.assertWrappingType = assertWrappingType;
    exports.isNullableType = isNullableType;
    exports.assertNullableType = assertNullableType;
    exports.getNullableType = getNullableType;
    exports.isNamedType = isNamedType;
    exports.assertNamedType = assertNamedType;
    exports.getNamedType = getNamedType;
    exports.argsToArgsConfig = argsToArgsConfig;
    exports.isRequiredArgument = isRequiredArgument;
    exports.isRequiredInputField = isRequiredInputField;
    exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = void 0;
    var _objectEntries = _interopRequireDefault(require_objectEntries());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _mapValue = _interopRequireDefault(require_mapValue());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _identityFunc = _interopRequireDefault(require_identityFunc());
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
    }
    function assertType(type) {
      if (!isType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL type."));
      }
      return type;
    }
    function isScalarType(type) {
      return (0, _instanceOf.default)(type, GraphQLScalarType);
    }
    function assertScalarType(type) {
      if (!isScalarType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Scalar type."));
      }
      return type;
    }
    function isObjectType(type) {
      return (0, _instanceOf.default)(type, GraphQLObjectType);
    }
    function assertObjectType(type) {
      if (!isObjectType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Object type."));
      }
      return type;
    }
    function isInterfaceType(type) {
      return (0, _instanceOf.default)(type, GraphQLInterfaceType);
    }
    function assertInterfaceType(type) {
      if (!isInterfaceType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Interface type."));
      }
      return type;
    }
    function isUnionType(type) {
      return (0, _instanceOf.default)(type, GraphQLUnionType);
    }
    function assertUnionType(type) {
      if (!isUnionType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Union type."));
      }
      return type;
    }
    function isEnumType(type) {
      return (0, _instanceOf.default)(type, GraphQLEnumType);
    }
    function assertEnumType(type) {
      if (!isEnumType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Enum type."));
      }
      return type;
    }
    function isInputObjectType(type) {
      return (0, _instanceOf.default)(type, GraphQLInputObjectType);
    }
    function assertInputObjectType(type) {
      if (!isInputObjectType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Input Object type."));
      }
      return type;
    }
    function isListType(type) {
      return (0, _instanceOf.default)(type, GraphQLList);
    }
    function assertListType(type) {
      if (!isListType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL List type."));
      }
      return type;
    }
    function isNonNullType(type) {
      return (0, _instanceOf.default)(type, GraphQLNonNull);
    }
    function assertNonNullType(type) {
      if (!isNonNullType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Non-Null type."));
      }
      return type;
    }
    function isInputType(type) {
      return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
    }
    function assertInputType(type) {
      if (!isInputType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL input type."));
      }
      return type;
    }
    function isOutputType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
    }
    function assertOutputType(type) {
      if (!isOutputType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL output type."));
      }
      return type;
    }
    function isLeafType(type) {
      return isScalarType(type) || isEnumType(type);
    }
    function assertLeafType(type) {
      if (!isLeafType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL leaf type."));
      }
      return type;
    }
    function isCompositeType(type) {
      return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
    }
    function assertCompositeType(type) {
      if (!isCompositeType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL composite type."));
      }
      return type;
    }
    function isAbstractType(type) {
      return isInterfaceType(type) || isUnionType(type);
    }
    function assertAbstractType(type) {
      if (!isAbstractType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL abstract type."));
      }
      return type;
    }
    function GraphQLList(ofType) {
      if (this instanceof GraphQLList) {
        this.ofType = assertType(ofType);
      } else {
        return new GraphQLList(ofType);
      }
    }
    GraphQLList.prototype.toString = function toString() {
      return "[" + String(this.ofType) + "]";
    };
    GraphQLList.prototype.toJSON = function toJSON() {
      return this.toString();
    };
    Object.defineProperty(GraphQLList.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
      get: function get() {
        return "GraphQLList";
      }
    });
    (0, _defineInspect.default)(GraphQLList);
    function GraphQLNonNull(ofType) {
      if (this instanceof GraphQLNonNull) {
        this.ofType = assertNullableType(ofType);
      } else {
        return new GraphQLNonNull(ofType);
      }
    }
    GraphQLNonNull.prototype.toString = function toString() {
      return String(this.ofType) + "!";
    };
    GraphQLNonNull.prototype.toJSON = function toJSON() {
      return this.toString();
    };
    Object.defineProperty(GraphQLNonNull.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
      get: function get() {
        return "GraphQLNonNull";
      }
    });
    (0, _defineInspect.default)(GraphQLNonNull);
    function isWrappingType(type) {
      return isListType(type) || isNonNullType(type);
    }
    function assertWrappingType(type) {
      if (!isWrappingType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL wrapping type."));
      }
      return type;
    }
    function isNullableType(type) {
      return isType(type) && !isNonNullType(type);
    }
    function assertNullableType(type) {
      if (!isNullableType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL nullable type."));
      }
      return type;
    }
    function getNullableType(type) {
      if (type) {
        return isNonNullType(type) ? type.ofType : type;
      }
    }
    function isNamedType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
    }
    function assertNamedType(type) {
      if (!isNamedType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL named type."));
      }
      return type;
    }
    function getNamedType(type) {
      if (type) {
        var unwrappedType = type;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    function resolveThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    function undefineIfEmpty(arr) {
      return arr && arr.length > 0 ? arr : void 0;
    }
    var GraphQLScalarType = /* @__PURE__ */ function() {
      function GraphQLScalarType2(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral;
        var parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.default;
        this.name = config.name;
        this.description = config.description;
        this.specifiedByUrl = config.specifiedByUrl;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.default;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function(node, variables) {
          return parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
        };
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.specifiedByUrl == null || typeof config.specifiedByUrl === "string" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat((0, _inspect.default)(config.specifiedByUrl), "."));
        config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'));
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.'));
        }
      }
      var _proto = GraphQLScalarType2.prototype;
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          name: this.name,
          description: this.description,
          specifiedByUrl: this.specifiedByUrl,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []
        };
      };
      _proto.toString = function toString() {
        return this.name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLScalarType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLScalarType";
        }
      }]);
      return GraphQLScalarType2;
    }();
    exports.GraphQLScalarType = GraphQLScalarType;
    (0, _defineInspect.default)(GraphQLScalarType);
    var GraphQLObjectType = /* @__PURE__ */ function() {
      function GraphQLObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat((0, _inspect.default)(config.isTypeOf), "."));
      }
      var _proto2 = GraphQLObjectType2.prototype;
      _proto2.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto2.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto2.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes || []
        };
      };
      _proto2.toString = function toString() {
        return this.name;
      };
      _proto2.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLObjectType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLObjectType";
        }
      }]);
      return GraphQLObjectType2;
    }();
    exports.GraphQLObjectType = GraphQLObjectType;
    (0, _defineInspect.default)(GraphQLObjectType);
    function defineInterfaces(config) {
      var _resolveThunk;
      var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];
      Array.isArray(interfaces) || (0, _devAssert.default)(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
      return interfaces;
    }
    function defineFieldMap(config) {
      var fieldMap = resolveThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
      return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object."));
        !("isDeprecated" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, ' should provide "deprecationReason" instead of "isDeprecated".'));
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat((0, _inspect.default)(fieldConfig.resolve), "."));
        var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
        var args = (0, _objectEntries.default)(argsConfig).map(function(_ref) {
          var argName = _ref[0], argConfig = _ref[1];
          return {
            name: argName,
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
            astNode: argConfig.astNode
          };
        });
        return {
          name: fieldName,
          description: fieldConfig.description,
          type: fieldConfig.type,
          args,
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          isDeprecated: fieldConfig.deprecationReason != null,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isPlainObj(obj) {
      return (0, _isObjectLike.default)(obj) && !Array.isArray(obj);
    }
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.default)(fields, function(field) {
        return {
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        };
      });
    }
    function argsToArgsConfig(args) {
      return (0, _keyValMap.default)(args, function(arg) {
        return arg.name;
      }, function(arg) {
        return {
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        };
      });
    }
    function isRequiredArgument(arg) {
      return isNonNullType(arg.type) && arg.defaultValue === void 0;
    }
    var GraphQLInterfaceType = /* @__PURE__ */ function() {
      function GraphQLInterfaceType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
      }
      var _proto3 = GraphQLInterfaceType2.prototype;
      _proto3.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto3.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto3.toConfig = function toConfig() {
        var _this$extensionASTNod2;
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []
        };
      };
      _proto3.toString = function toString() {
        return this.name;
      };
      _proto3.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLInterfaceType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLInterfaceType";
        }
      }]);
      return GraphQLInterfaceType2;
    }();
    exports.GraphQLInterfaceType = GraphQLInterfaceType;
    (0, _defineInspect.default)(GraphQLInterfaceType);
    var GraphQLUnionType = /* @__PURE__ */ function() {
      function GraphQLUnionType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._types = defineTypes.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
      }
      var _proto4 = GraphQLUnionType2.prototype;
      _proto4.getTypes = function getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      };
      _proto4.toConfig = function toConfig() {
        var _this$extensionASTNod3;
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []
        };
      };
      _proto4.toString = function toString() {
        return this.name;
      };
      _proto4.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLUnionType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLUnionType";
        }
      }]);
      return GraphQLUnionType2;
    }();
    exports.GraphQLUnionType = GraphQLUnionType;
    (0, _defineInspect.default)(GraphQLUnionType);
    function defineTypes(config) {
      var types = resolveThunk(config.types);
      Array.isArray(types) || (0, _devAssert.default)(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
      return types;
    }
    var GraphQLEnumType = /* @__PURE__ */ function() {
      function GraphQLEnumType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(this._values.map(function(enumValue) {
          return [enumValue.value, enumValue];
        }));
        this._nameLookup = (0, _keyMap.default)(this._values, function(value) {
          return value.name;
        });
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      }
      var _proto5 = GraphQLEnumType2.prototype;
      _proto5.getValues = function getValues() {
        return this._values;
      };
      _proto5.getValue = function getValue(name) {
        return this._nameLookup[name];
      };
      _proto5.serialize = function serialize(outputValue) {
        var enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent value: ').concat((0, _inspect.default)(outputValue)));
        }
        return enumValue.name;
      };
      _proto5.parseValue = function parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          var valueStr = (0, _inspect.default)(inputValue);
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr));
        }
        var enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError('Value "'.concat(inputValue, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, inputValue));
        }
        return enumValue.value;
      };
      _proto5.parseLiteral = function parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          var valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr), valueNode);
        }
        var enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          var _valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError('Value "'.concat(_valueStr, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, _valueStr), valueNode);
        }
        return enumValue.value;
      };
      _proto5.toConfig = function toConfig() {
        var _this$extensionASTNod4;
        var values = (0, _keyValMap.default)(this.getValues(), function(value) {
          return value.name;
        }, function(value) {
          return {
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []
        };
      };
      _proto5.toString = function toString() {
        return this.name;
      };
      _proto5.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLEnumType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLEnumType";
        }
      }]);
      return GraphQLEnumType2;
    }();
    exports.GraphQLEnumType = GraphQLEnumType;
    (0, _defineInspect.default)(GraphQLEnumType);
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      var allNames = enumType.getValues().map(function(value) {
        return value.name;
      });
      var suggestedValues = (0, _suggestionList.default)(unknownValueStr, allNames);
      return (0, _didYouMean.default)("the enum value", suggestedValues);
    }
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.default)(0, "".concat(typeName, " values must be an object with value names as keys."));
      return (0, _objectEntries.default)(valueMap).map(function(_ref2) {
        var valueName = _ref2[0], valueConfig = _ref2[1];
        isPlainObj(valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat((0, _inspect.default)(valueConfig), "."));
        !("isDeprecated" in valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' should provide "deprecationReason" instead of "isDeprecated".'));
        return {
          name: valueName,
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          isDeprecated: valueConfig.deprecationReason != null,
          deprecationReason: valueConfig.deprecationReason,
          extensions: valueConfig.extensions && (0, _toObjMap.default)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    var GraphQLInputObjectType = /* @__PURE__ */ function() {
      function GraphQLInputObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineInputFieldMap.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      }
      var _proto6 = GraphQLInputObjectType2.prototype;
      _proto6.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto6.toConfig = function toConfig() {
        var _this$extensionASTNod5;
        var fields = (0, _mapValue.default)(this.getFields(), function(field) {
          return {
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []
        };
      };
      _proto6.toString = function toString() {
        return this.name;
      };
      _proto6.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLInputObjectType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLInputObjectType";
        }
      }]);
      return GraphQLInputObjectType2;
    }();
    exports.GraphQLInputObjectType = GraphQLInputObjectType;
    (0, _defineInspect.default)(GraphQLInputObjectType);
    function defineInputFieldMap(config) {
      var fieldMap = resolveThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
      return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
        !("resolve" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
        return {
          name: fieldName,
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isRequiredInputField(field) {
      return isNonNullType(field.type) && field.defaultValue === void 0;
    }
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/graphql/utilities/typeComparators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isEqualType = isEqualType;
    exports.isTypeSubTypeOf = isTypeSubTypeOf;
    exports.doTypesOverlap = doTypesOverlap;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    function doTypesOverlap(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some(function(type) {
            return schema.isSubType(typeB, type);
          });
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
  }
});

// node_modules/graphql/polyfills/arrayFrom.js
var require_arrayFrom = __commonJS({
  "node_modules/graphql/polyfills/arrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _symbols = require_symbols();
    var arrayFrom = Array.from || function(obj, mapFn, thisArg) {
      if (obj == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }
      var iteratorMethod = obj[_symbols.SYMBOL_ITERATOR];
      if (typeof iteratorMethod === "function") {
        var iterator = iteratorMethod.call(obj);
        var result = [];
        var step;
        for (var i = 0; !(step = iterator.next()).done; ++i) {
          result.push(mapFn.call(thisArg, step.value, i));
          if (i > 9999999) {
            throw new TypeError("Near-infinite iteration.");
          }
        }
        return result;
      }
      var length = obj.length;
      if (typeof length === "number" && length >= 0 && length % 1 === 0) {
        var _result = [];
        for (var _i = 0; _i < length; ++_i) {
          if (Object.prototype.hasOwnProperty.call(obj, _i)) {
            _result.push(mapFn.call(thisArg, obj[_i], _i));
          }
        }
        return _result;
      }
      return [];
    };
    var _default = arrayFrom;
    exports.default = _default;
  }
});

// node_modules/graphql/polyfills/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/graphql/polyfills/isFinite.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isFinitePolyfill = Number.isFinite || function(value) {
      return typeof value === "number" && isFinite(value);
    };
    var _default = isFinitePolyfill;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/safeArrayFrom.js
var require_safeArrayFrom = __commonJS({
  "node_modules/graphql/jsutils/safeArrayFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = safeArrayFrom;
    var _symbols = require_symbols();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function safeArrayFrom(collection) {
      var mapFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(item) {
        return item;
      };
      if (collection == null || _typeof(collection) !== "object") {
        return null;
      }
      if (Array.isArray(collection)) {
        return collection.map(mapFn);
      }
      var iteratorMethod = collection[_symbols.SYMBOL_ITERATOR];
      if (typeof iteratorMethod === "function") {
        var iterator = iteratorMethod.call(collection);
        var result = [];
        var step;
        for (var i = 0; !(step = iterator.next()).done; ++i) {
          result.push(mapFn(step.value, i));
        }
        return result;
      }
      var length = collection.length;
      if (typeof length === "number" && length >= 0 && length % 1 === 0) {
        var _result = [];
        for (var _i = 0; _i < length; ++_i) {
          if (!Object.prototype.hasOwnProperty.call(collection, _i)) {
            return null;
          }
          _result.push(mapFn(collection[String(_i)], _i));
        }
        return _result;
      }
      return null;
    }
  }
});

// node_modules/graphql/polyfills/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/graphql/polyfills/isInteger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isInteger = Number.isInteger || function(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    var _default = isInteger;
    exports.default = _default;
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/graphql/type/scalars.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSpecifiedScalarType = isSpecifiedScalarType;
    exports.specifiedScalarTypes = exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = void 0;
    var _isFinite = _interopRequireDefault(require_isFinite());
    var _isInteger = _interopRequireDefault(require_isInteger());
    var _inspect = _interopRequireDefault(require_inspect());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX_INT = 2147483647;
    var MIN_INT = -2147483648;
    function serializeInt(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      var num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (!(0, _isInteger.default)(num)) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(coercedValue)));
      }
      if (num > MAX_INT || num < MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.default)(coercedValue));
      }
      return num;
    }
    function coerceInt(inputValue) {
      if (!(0, _isInteger.default)(inputValue)) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(inputValue)));
      }
      if (inputValue > MAX_INT || inputValue < MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(inputValue));
      }
      return inputValue;
    }
    var GraphQLInt = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize: serializeInt,
      parseValue: coerceInt,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        var num = parseInt(valueNode.value, 10);
        if (num > MAX_INT || num < MIN_INT) {
          throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(valueNode.value), valueNode);
        }
        return num;
      }
    });
    exports.GraphQLInt = GraphQLInt;
    function serializeFloat(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      var num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (!(0, _isFinite.default)(num)) {
        throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(coercedValue)));
      }
      return num;
    }
    function coerceFloat(inputValue) {
      if (!(0, _isFinite.default)(inputValue)) {
        throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLFloat = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize: serializeFloat,
      parseValue: coerceFloat,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return parseFloat(valueNode.value);
      }
    });
    exports.GraphQLFloat = GraphQLFloat;
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.default)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          var valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.default)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
    function serializeString(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (typeof coercedValue === "boolean") {
        return coercedValue ? "true" : "false";
      }
      if ((0, _isFinite.default)(coercedValue)) {
        return coercedValue.toString();
      }
      throw new _GraphQLError.GraphQLError("String cannot represent value: ".concat((0, _inspect.default)(outputValue)));
    }
    function coerceString(inputValue) {
      if (typeof inputValue !== "string") {
        throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLString = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize: serializeString,
      parseValue: coerceString,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLString = GraphQLString;
    function serializeBoolean(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue;
      }
      if ((0, _isFinite.default)(coercedValue)) {
        return coercedValue !== 0;
      }
      throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(coercedValue)));
    }
    function coerceBoolean(inputValue) {
      if (typeof inputValue !== "boolean") {
        throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLBoolean = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize: serializeBoolean,
      parseValue: coerceBoolean,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLBoolean = GraphQLBoolean;
    function serializeID(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if ((0, _isInteger.default)(coercedValue)) {
        return String(coercedValue);
      }
      throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(outputValue)));
    }
    function coerceID(inputValue) {
      if (typeof inputValue === "string") {
        return inputValue;
      }
      if ((0, _isInteger.default)(inputValue)) {
        return inputValue.toString();
      }
      throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(inputValue)));
    }
    var GraphQLID = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize: serializeID,
      parseValue: coerceID,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLID = GraphQLID;
    var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
    exports.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType(type) {
      return specifiedScalarTypes.some(function(_ref) {
        var name = _ref.name;
        return type.name === name;
      });
    }
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/graphql/utilities/astFromValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.astFromValue = astFromValue;
    var _isFinite = _interopRequireDefault(require_isFinite());
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _kinds = require_kinds();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function astFromValue(value, type) {
      if ((0, _definition.isNonNullType)(type)) {
        var astValue = astFromValue(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        var items = (0, _safeArrayFrom.default)(value);
        if (items != null) {
          var valuesNodes = [];
          for (var _i2 = 0; _i2 < items.length; _i2++) {
            var item = items[_i2];
            var itemNode = astFromValue(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.default)(value)) {
          return null;
        }
        var fieldNodes = [];
        for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {
          var field = _objectValues2[_i4];
          var fieldValue = astFromValue(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type)) {
        var serialized = type.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && (0, _isFinite.default)(serialized)) {
          var stringNum = String(serialized);
          return integerStringRegExp.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError("Cannot convert value to AST: ".concat((0, _inspect.default)(serialized), "."));
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/graphql/type/introspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIntrospectionType = isIntrospectionType;
    exports.introspectionTypes = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = void 0;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _printer = require_printer();
    var _directiveLocation = require_directiveLocation();
    var _astFromValue = require_astFromValue();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: function fields() {
        return {
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(schema) {
              return schema.description;
            }
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
            resolve: function resolve(schema) {
              return (0, _objectValues.default)(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve(schema) {
              return schema.getQueryType();
            }
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: function resolve(schema) {
              return schema.getMutationType();
            }
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: function resolve(schema) {
              return schema.getSubscriptionType();
            }
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
            resolve: function resolve(schema) {
              return schema.getDirectives();
            }
          }
        };
      }
    });
    exports.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve(directive) {
              return directive.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(directive) {
              return directive.description;
            }
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve(directive) {
              return directive.isRepeatable;
            }
          },
          locations: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
            resolve: function resolve(directive) {
              return directive.locations;
            }
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve(field, _ref) {
              var includeDeprecated = _ref.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          }
        };
      }
    });
    exports.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: function fields() {
        return {
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve: function resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.default)(0, 'Unexpected type: "'.concat((0, _inspect.default)(type), '".'));
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: function resolve(type) {
              return type.name !== void 0 ? type.name : void 0;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(type) {
              return type.description !== void 0 ? type.description : void 0;
            }
          },
          specifiedByUrl: {
            type: _scalars.GraphQLString,
            resolve: function resolve(obj) {
              return obj.specifiedByUrl !== void 0 ? obj.specifiedByUrl : void 0;
            }
          },
          fields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve(type, _ref2) {
              var includeDeprecated = _ref2.includeDeprecated;
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                var fields2 = (0, _objectValues.default)(type.getFields());
                return includeDeprecated ? fields2 : fields2.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve: function resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve: function resolve(type, _args, _context, _ref3) {
              var schema = _ref3.schema;
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve(type, _ref4) {
              var includeDeprecated = _ref4.includeDeprecated;
              if ((0, _definition.isEnumType)(type)) {
                var values = type.getValues();
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve(type, _ref5) {
              var includeDeprecated = _ref5.includeDeprecated;
              if ((0, _definition.isInputObjectType)(type)) {
                var values = (0, _objectValues.default)(type.getFields());
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: function resolve(type) {
              return type.ofType !== void 0 ? type.ofType : void 0;
            }
          }
        };
      }
    });
    exports.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve(field) {
              return field.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(field) {
              return field.description;
            }
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve(field, _ref6) {
              var includeDeprecated = _ref6.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve(field) {
              return field.type;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve(field) {
              return field.deprecationReason;
            }
          }
        };
      }
    });
    exports.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve(inputValue) {
              return inputValue.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(inputValue) {
              return inputValue.description;
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve(inputValue) {
              return inputValue.type;
            }
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve: function resolve(inputValue) {
              var type = inputValue.type, defaultValue = inputValue.defaultValue;
              var valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve(obj) {
              return obj.deprecationReason;
            }
          }
        };
      }
    });
    exports.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve(enumValue) {
              return enumValue.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve(enumValue) {
              return enumValue.description;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve(enumValue) {
              return enumValue.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve(enumValue) {
              return enumValue.deprecationReason;
            }
          }
        };
      }
    });
    exports.__EnumValue = __EnumValue;
    var TypeKind = Object.freeze({
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      INPUT_OBJECT: "INPUT_OBJECT",
      LIST: "LIST",
      NON_NULL: "NON_NULL"
    });
    exports.TypeKind = TypeKind;
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: function resolve(_source, _args, _context, _ref7) {
        var schema = _ref7.schema;
        return schema;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [{
        name: "name",
        description: void 0,
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: void 0,
        astNode: void 0
      }],
      resolve: function resolve(_source, _ref8, _context, _ref9) {
        var name = _ref8.name;
        var schema = _ref9.schema;
        return schema.getType(name);
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: function resolve(_source, _args, _context, _ref10) {
        var parentType = _ref10.parentType;
        return parentType.name;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
    var introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
    exports.introspectionTypes = introspectionTypes;
    function isIntrospectionType(type) {
      return introspectionTypes.some(function(_ref11) {
        var name = _ref11.name;
        return type.name === name;
      });
    }
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/graphql/type/directives.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDirective = isDirective;
    exports.assertDirective = assertDirective;
    exports.isSpecifiedDirective = isSpecifiedDirective;
    exports.specifiedDirectives = exports.GraphQLSpecifiedByDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = void 0;
    var _objectEntries = _interopRequireDefault(require_objectEntries());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    var _directiveLocation = require_directiveLocation();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isDirective(directive) {
      return (0, _instanceOf.default)(directive, GraphQLDirective);
    }
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error("Expected ".concat((0, _inspect.default)(directive), " to be a GraphQL directive."));
      }
      return directive;
    }
    var GraphQLDirective = /* @__PURE__ */ function() {
      function GraphQLDirective2(config) {
        var _config$isRepeatable, _config$args;
        this.name = config.name;
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        config.name || (0, _devAssert.default)(0, "Directive must be named.");
        Array.isArray(config.locations) || (0, _devAssert.default)(0, "@".concat(config.name, " locations must be an Array."));
        var args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.default)(args) && !Array.isArray(args) || (0, _devAssert.default)(0, "@".concat(config.name, " args must be an object with argument names as keys."));
        this.args = (0, _objectEntries.default)(args).map(function(_ref) {
          var argName = _ref[0], argConfig = _ref[1];
          return {
            name: argName,
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
            astNode: argConfig.astNode
          };
        });
      }
      var _proto = GraphQLDirective2.prototype;
      _proto.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      };
      _proto.toString = function toString() {
        return "@" + this.name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLDirective2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLDirective";
        }
      }]);
      return GraphQLDirective2;
    }();
    exports.GraphQLDirective = GraphQLDirective;
    (0, _defineInspect.default)(GraphQLDirective);
    var GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
    var GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports.GraphQLSkipDirective = GraphQLSkipDirective;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [_directiveLocation.DirectiveLocation.FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION, _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ENUM_VALUE],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
    var GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behaviour of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behaviour of this scalar."
        }
      }
    });
    exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective]);
    exports.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective(directive) {
      return specifiedDirectives.some(function(_ref2) {
        var name = _ref2.name;
        return name === directive.name;
      });
    }
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/graphql/type/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSchema = isSchema;
    exports.assertSchema = assertSchema;
    exports.GraphQLSchema = void 0;
    var _find = _interopRequireDefault(require_find());
    var _arrayFrom3 = _interopRequireDefault(require_arrayFrom());
    var _objectValues5 = _interopRequireDefault(require_objectValues());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isSchema(schema) {
      return (0, _instanceOf.default)(schema, GraphQLSchema);
    }
    function assertSchema(schema) {
      if (!isSchema(schema)) {
        throw new Error("Expected ".concat((0, _inspect.default)(schema), " to be a GraphQL schema."));
      }
      return schema;
    }
    var GraphQLSchema = /* @__PURE__ */ function() {
      function GraphQLSchema2(config) {
        var _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.default)(config) || (0, _devAssert.default)(0, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || (0, _devAssert.default)(0, '"types" must be Array if provided but got: '.concat((0, _inspect.default)(config.types), "."));
        !config.directives || Array.isArray(config.directives) || (0, _devAssert.default)(0, '"directives" must be Array if provided but got: ' + "".concat((0, _inspect.default)(config.directives), "."));
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = config.extensionASTNodes;
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        var allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
            var type = _config$types2[_i2];
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {
          var directive = _this$_directives2[_i4];
          if ((0, _directives.isDirective)(directive)) {
            for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
              var arg = _directive$args2[_i6];
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (var _i8 = 0, _arrayFrom2 = (0, _arrayFrom3.default)(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {
          var namedType = _arrayFrom2[_i8];
          if (namedType == null) {
            continue;
          }
          var typeName = namedType.name;
          typeName || (0, _devAssert.default)(0, "One of the provided types for building the Schema is missing a name.");
          if (this._typeMap[typeName] !== void 0) {
            throw new Error('Schema must contain uniquely named types but contains multiple types named "'.concat(typeName, '".'));
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {
              var iface = _namedType$getInterfa2[_i10];
              if ((0, _definition.isInterfaceType)(iface)) {
                var implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {
              var _iface = _namedType$getInterfa4[_i12];
              if ((0, _definition.isInterfaceType)(_iface)) {
                var _implementations = this._implementationsMap[_iface.name];
                if (_implementations === void 0) {
                  _implementations = this._implementationsMap[_iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                _implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      var _proto = GraphQLSchema2.prototype;
      _proto.getQueryType = function getQueryType() {
        return this._queryType;
      };
      _proto.getMutationType = function getMutationType() {
        return this._mutationType;
      };
      _proto.getSubscriptionType = function getSubscriptionType() {
        return this._subscriptionType;
      };
      _proto.getTypeMap = function getTypeMap() {
        return this._typeMap;
      };
      _proto.getType = function getType(name) {
        return this.getTypeMap()[name];
      };
      _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      };
      _proto.getImplementations = function getImplementations(interfaceType) {
        var implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      };
      _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
        return this.isSubType(abstractType, possibleType);
      };
      _proto.isSubType = function isSubType(abstractType, maybeSubType) {
        var map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {
              var type = _abstractType$getType2[_i14];
              map[type.name] = true;
            }
          } else {
            var implementations = this.getImplementations(abstractType);
            for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {
              var _type = _implementations$obje2[_i16];
              map[_type.name] = true;
            }
            for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {
              var _type2 = _implementations$inte2[_i18];
              map[_type2.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      };
      _proto.getDirectives = function getDirectives() {
        return this._directives;
      };
      _proto.getDirective = function getDirective(name) {
        return (0, _find.default)(this.getDirectives(), function(directive) {
          return directive.name === name;
        });
      };
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: (0, _objectValues5.default)(this.getTypeMap()),
          directives: this.getDirectives().slice(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],
          assumeValid: this.__validationErrors !== void 0
        };
      };
      _createClass(GraphQLSchema2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLSchema";
        }
      }]);
      return GraphQLSchema2;
    }();
    exports.GraphQLSchema = GraphQLSchema;
    function collectReferencedTypes(type, typeSet) {
      var namedType = (0, _definition.getNamedType)(type);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {
            var memberType = _namedType$getTypes2[_i20];
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {
            var interfaceType = _namedType$getInterfa6[_i22];
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (var _i24 = 0, _objectValues2 = (0, _objectValues5.default)(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {
            var field = _objectValues2[_i24];
            collectReferencedTypes(field.type, typeSet);
            for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {
              var arg = _field$args2[_i26];
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (var _i28 = 0, _objectValues4 = (0, _objectValues5.default)(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {
            var _field = _objectValues4[_i28];
            collectReferencedTypes(_field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/graphql/type/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validateSchema = validateSchema;
    exports.assertValidSchema = assertValidSchema;
    var _find = _interopRequireDefault(require_find());
    var _objectValues5 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _assertValidName = require_assertValidName();
    var _typeComparators = require_typeComparators();
    var _schema = require_schema();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validateSchema(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      var context = new SchemaValidationContext(schema);
      validateRootTypes(context);
      validateDirectives(context);
      validateTypes(context);
      var errors = context.getErrors();
      schema.__validationErrors = errors;
      return errors;
    }
    function assertValidSchema(schema) {
      var errors = validateSchema(schema);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
          return error.message;
        }).join("\n\n"));
      }
    }
    var SchemaValidationContext = /* @__PURE__ */ function() {
      function SchemaValidationContext2(schema) {
        this._errors = [];
        this.schema = schema;
      }
      var _proto = SchemaValidationContext2.prototype;
      _proto.reportError = function reportError(message, nodes) {
        var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this.addError(new _GraphQLError.GraphQLError(message, _nodes));
      };
      _proto.addError = function addError(error) {
        this._errors.push(error);
      };
      _proto.getErrors = function getErrors() {
        return this._errors;
      };
      return SchemaValidationContext2;
    }();
    function validateRootTypes(context) {
      var schema = context.schema;
      var queryType = schema.getQueryType();
      if (!queryType) {
        context.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError("Query root type must be Object type, it cannot be ".concat((0, _inspect.default)(queryType), "."), (_getOperationTypeNode = getOperationTypeNode(schema, "query")) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
      }
      var mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError("Mutation root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(mutationType), "."), (_getOperationTypeNode2 = getOperationTypeNode(schema, "mutation")) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError("Subscription root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(subscriptionType), "."), (_getOperationTypeNode3 = getOperationTypeNode(schema, "subscription")) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
      }
    }
    function getOperationTypeNode(schema, operation) {
      var operationNodes = getAllSubNodes(schema, function(node2) {
        return node2.operationTypes;
      });
      for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {
        var node = operationNodes[_i2];
        if (node.operation === operation) {
          return node.type;
        }
      }
      return void 0;
    }
    function validateDirectives(context) {
      for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {
        var directive = _context$schema$getDi2[_i4];
        if (!(0, _directives.isDirective)(directive)) {
          context.reportError("Expected directive but got: ".concat((0, _inspect.default)(directive), "."), directive === null || directive === void 0 ? void 0 : directive.astNode);
          continue;
        }
        validateName(context, directive);
        for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
          var arg = _directive$args2[_i6];
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context.reportError("The type of @".concat(directive.name, "(").concat(arg.name, ":) must be Input Type ") + "but got: ".concat((0, _inspect.default)(arg.type), "."), arg.astNode);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context.reportError("Required argument @".concat(directive.name, "(").concat(arg.name, ":) cannot be deprecated."), [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
            ]);
          }
        }
      }
    }
    function validateName(context, node) {
      var error = (0, _assertValidName.isValidNameError)(node.name);
      if (error) {
        context.addError((0, _locatedError.locatedError)(error, node.astNode));
      }
    }
    function validateTypes(context) {
      var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
      var typeMap = context.schema.getTypeMap();
      for (var _i8 = 0, _objectValues2 = (0, _objectValues5.default)(typeMap); _i8 < _objectValues2.length; _i8++) {
        var type = _objectValues2[_i8];
        if (!(0, _definition.isNamedType)(type)) {
          context.reportError("Expected GraphQL named type but got: ".concat((0, _inspect.default)(type), "."), type.astNode);
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type)) {
          validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
          validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
          validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
          validateInputFields(context, type);
          validateInputObjectCircularRefs(type);
        }
      }
    }
    function validateFields(context, type) {
      var fields = (0, _objectValues5.default)(type.getFields());
      if (fields.length === 0) {
        context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
      }
      for (var _i10 = 0; _i10 < fields.length; _i10++) {
        var field = fields[_i10];
        validateName(context, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
        }
        for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {
          var arg = _field$args2[_i12];
          var argName = arg.name;
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat((0, _inspect.default)(arg.type), "."), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context.reportError("Required argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) cannot be deprecated."), [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
            ]);
          }
        }
      }
    }
    function validateInterfaces(context, type) {
      var ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {
        var iface = _type$getInterfaces2[_i14];
        if (!(0, _definition.isInterfaceType)(iface)) {
          context.reportError("Type ".concat((0, _inspect.default)(type), " must only implement Interface types, ") + "it cannot implement ".concat((0, _inspect.default)(iface), "."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (type === iface) {
          context.reportError("Type ".concat(type.name, " cannot implement itself because it would create a circular reference."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context.reportError("Type ".concat(type.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
      }
    }
    function validateTypeImplementsInterface(context, type, iface) {
      var typeFieldMap = type.getFields();
      for (var _i16 = 0, _objectValues4 = (0, _objectValues5.default)(iface.getFields()); _i16 < _objectValues4.length; _i16++) {
        var ifaceField = _objectValues4[_i16];
        var fieldName = ifaceField.name;
        var typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(type.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(type)));
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
          var _ifaceField$astNode, _typeField$astNode;
          context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat((0, _inspect.default)(ifaceField.type), " but ").concat(type.name, ".").concat(fieldName, " ") + "is type ".concat((0, _inspect.default)(typeField.type), "."), [
            (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
            (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
          ]);
        }
        var _loop = function _loop3(_i182, _ifaceField$args22) {
          var ifaceArg = _ifaceField$args22[_i182];
          var argName = ifaceArg.name;
          var typeArg = (0, _find.default)(typeField.args, function(arg) {
            return arg.name === argName;
          });
          if (!typeArg) {
            context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(type.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, typeField.astNode]);
            return "continue";
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat((0, _inspect.default)(ifaceArg.type), " but ") + "".concat(type.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat((0, _inspect.default)(typeArg.type), "."), [
              (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
              (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
            ]);
          }
        };
        for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {
          var _ret = _loop(_i18, _ifaceField$args2);
          if (_ret === "continue")
            continue;
        }
        var _loop2 = function _loop22(_i202, _typeField$args22) {
          var typeArg = _typeField$args22[_i202];
          var argName = typeArg.name;
          var ifaceArg = (0, _find.default)(ifaceField.args, function(arg) {
            return arg.name === argName;
          });
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context.reportError("Object field ".concat(type.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [typeArg.astNode, ifaceField.astNode]);
          }
        };
        for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {
          _loop2(_i20, _typeField$args2);
        }
      }
    }
    function validateTypeImplementsAncestors(context, type, iface) {
      var ifaceInterfaces = type.getInterfaces();
      for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {
        var transitive = _iface$getInterfaces2[_i22];
        if (ifaceInterfaces.indexOf(transitive) === -1) {
          context.reportError(transitive === type ? "Type ".concat(type.name, " cannot implement ").concat(iface.name, " because it would create a circular reference.") : "Type ".concat(type.name, " must implement ").concat(transitive.name, " because it is implemented by ").concat(iface.name, "."), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));
        }
      }
    }
    function validateUnionMembers(context, union) {
      var memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
      }
      var includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {
        var memberType = memberTypes[_i24];
        if (includedTypeNames[memberType.name]) {
          context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat((0, _inspect.default)(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
        }
      }
    }
    function validateEnumValues(context, enumType) {
      var enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
      }
      for (var _i26 = 0; _i26 < enumValues.length; _i26++) {
        var enumValue = enumValues[_i26];
        var valueName = enumValue.name;
        validateName(context, enumValue);
        if (valueName === "true" || valueName === "false" || valueName === "null") {
          context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
        }
      }
    }
    function validateInputFields(context, inputObj) {
      var fields = (0, _objectValues5.default)(inputObj.getFields());
      if (fields.length === 0) {
        context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
      }
      for (var _i28 = 0; _i28 < fields.length; _i28++) {
        var field = fields[_i28];
        validateName(context, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context.reportError("Required input field ".concat(inputObj.name, ".").concat(field.name, " cannot be deprecated."), [
            getDeprecatedDirectiveNode(field.astNode),
            (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
          ]);
        }
      }
    }
    function createInputObjectCircularRefsValidator(context) {
      var visitedTypes = /* @__PURE__ */ Object.create(null);
      var fieldPath = [];
      var fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        var fields = (0, _objectValues5.default)(inputObj.getFields());
        for (var _i30 = 0; _i30 < fields.length; _i30++) {
          var field = fields[_i30];
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            var fieldType = field.type.ofType;
            var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              var cyclePath = fieldPath.slice(cycleIndex);
              var pathStr = cyclePath.map(function(fieldObj) {
                return fieldObj.name;
              }).join(".");
              context.reportError('Cannot reference Input Object "'.concat(fieldType.name, '" within itself through a series of non-null fields: "').concat(pathStr, '".'), cyclePath.map(function(fieldObj) {
                return fieldObj.astNode;
              }));
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
    }
    function getAllNodes(object) {
      var astNode = object.astNode, extensionASTNodes = object.extensionASTNodes;
      return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];
    }
    function getAllSubNodes(object, getter) {
      var subNodes = [];
      for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {
        var _getter;
        var node = _getAllNodes2[_i32];
        subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);
      }
      return subNodes;
    }
    function getAllImplementsInterfaceNodes(type, iface) {
      return getAllSubNodes(type, function(typeNode) {
        return typeNode.interfaces;
      }).filter(function(ifaceNode) {
        return ifaceNode.name.value === iface.name;
      });
    }
    function getUnionMemberTypeNodes(union, typeName) {
      return getAllSubNodes(union, function(unionNode) {
        return unionNode.types;
      }).filter(function(typeNode) {
        return typeNode.name.value === typeName;
      });
    }
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function(node) {
        return node.name.value === _directives.GraphQLDeprecatedDirective.name;
      });
    }
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/graphql/utilities/typeFromAST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeFromAST = typeFromAST;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _kinds = require_kinds();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function typeFromAST(schema, typeNode) {
      var innerType;
      if (typeNode.kind === _kinds.Kind.LIST_TYPE) {
        innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLList(innerType);
      }
      if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {
        innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLNonNull(innerType);
      }
      if (typeNode.kind === _kinds.Kind.NAMED_TYPE) {
        return schema.getType(typeNode.name.value);
      }
      (0, _invariant.default)(0, "Unexpected type node: " + (0, _inspect.default)(typeNode));
    }
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/graphql/utilities/TypeInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.visitWithTypeInfo = visitWithTypeInfo;
    exports.TypeInfo = void 0;
    var _find = _interopRequireDefault(require_find());
    var _kinds = require_kinds();
    var _ast = require_ast();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TypeInfo = /* @__PURE__ */ function() {
      function TypeInfo2(schema, getFieldDefFn, initialType) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      var _proto = TypeInfo2.prototype;
      _proto.getType = function getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      };
      _proto.getParentType = function getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      };
      _proto.getInputType = function getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      };
      _proto.getParentInputType = function getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      };
      _proto.getFieldDef = function getFieldDef2() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      };
      _proto.getDefaultValue = function getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      };
      _proto.getDirective = function getDirective() {
        return this._directive;
      };
      _proto.getArgument = function getArgument() {
        return this._argument;
      };
      _proto.getEnumValue = function getEnumValue() {
        return this._enumValue;
      };
      _proto.enter = function enter(node) {
        var schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            var namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : void 0);
            break;
          }
          case _kinds.Kind.FIELD: {
            var parentType = this.getParentType();
            var fieldDef;
            var fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : void 0);
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            var type;
            switch (node.operation) {
              case "query":
                type = schema.getQueryType();
                break;
              case "mutation":
                type = schema.getMutationType();
                break;
              case "subscription":
                type = schema.getSubscriptionType();
                break;
            }
            this._typeStack.push((0, _definition.isObjectType)(type) ? type : void 0);
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            var typeConditionAST = node.typeCondition;
            var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : void 0);
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : void 0);
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            var argDef;
            var argType;
            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = (0, _find.default)(fieldOrDirective.args, function(arg) {
                return arg.name === node.name.value;
              });
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : void 0);
            break;
          }
          case _kinds.Kind.LIST: {
            var listType = (0, _definition.getNullableType)(this.getInputType());
            var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : void 0);
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            var objectType = (0, _definition.getNamedType)(this.getInputType());
            var inputFieldType;
            var inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0);
            break;
          }
          case _kinds.Kind.ENUM: {
            var enumType = (0, _definition.getNamedType)(this.getInputType());
            var enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
        }
      };
      _proto.leave = function leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
        }
      };
      return TypeInfo2;
    }();
    exports.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      var name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter: function enter(node) {
          typeInfo.enter(node);
          var fn = (0, _visitor.getVisitFn)(visitor, node.kind, false);
          if (fn) {
            var result = fn.apply(visitor, arguments);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave: function leave(node) {
          var fn = (0, _visitor.getVisitFn)(visitor, node.kind, true);
          var result;
          if (fn) {
            result = fn.apply(visitor, arguments);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/graphql/language/predicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDefinitionNode = isDefinitionNode;
    exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports.isSelectionNode = isSelectionNode;
    exports.isValueNode = isValueNode;
    exports.isTypeNode = isTypeNode;
    exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports.isTypeDefinitionNode = isTypeDefinitionNode;
    exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports.isTypeExtensionNode = isTypeExtensionNode;
    var _kinds = require_kinds();
    function isDefinitionNode(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context) {
      return {
        Document: function Document(node) {
          for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {
            var definition = _node$definitions2[_i2];
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              var defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context.reportError(new _GraphQLError.GraphQLError("The ".concat(defName, " definition is not executable."), definition));
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context) {
      var knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: function OperationDefinition(node) {
          var operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context.reportError(new _GraphQLError.GraphQLError('There can be only one operation named "'.concat(operationName.value, '".'), [knownOperationNames[operationName.value], operationName]));
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: function FragmentDefinition() {
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context) {
      var operationCount = 0;
      return {
        Document: function Document(node) {
          operationCount = node.definitions.filter(function(definition) {
            return definition.kind === _kinds.Kind.OPERATION_DEFINITION;
          }).length;
        },
        OperationDefinition: function OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    function SingleFieldSubscriptionsRule(context) {
      return {
        OperationDefinition: function OperationDefinition(node) {
          if (node.operation === "subscription") {
            if (node.selectionSet.selections.length !== 1) {
              context.reportError(new _GraphQLError.GraphQLError(node.name ? 'Subscription "'.concat(node.name.value, '" must select only one top level field.') : "Anonymous Subscription must select only one top level field.", node.selectionSet.selections.slice(1)));
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function KnownTypeNamesRule(context) {
      var schema = context.getSchema();
      var existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      var definedTypes = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
      return {
        NamedType: function NamedType(node, _1, parent, _2, ancestors) {
          var typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            var isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && isStandardTypeName(typeName)) {
              return;
            }
            var suggestedTypes = (0, _suggestionList.default)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
            context.reportError(new _GraphQLError.GraphQLError('Unknown type "'.concat(typeName, '".') + (0, _didYouMean.default)(suggestedTypes), node));
          }
        }
      };
    }
    var standardTypeNames = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes).map(function(type) {
      return type.name;
    });
    function isStandardTypeName(typeName) {
      return standardTypeNames.indexOf(typeName) !== -1;
    }
    function isSDLNode(value) {
      return !Array.isArray(value) && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context) {
      return {
        InlineFragment: function InlineFragment(node) {
          var typeCondition = node.typeCondition;
          if (typeCondition) {
            var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
              var typeStr = (0, _printer.print)(typeCondition);
              context.reportError(new _GraphQLError.GraphQLError('Fragment cannot condition on non composite type "'.concat(typeStr, '".'), typeCondition));
            }
          }
        },
        FragmentDefinition: function FragmentDefinition(node) {
          var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
          if (type && !(0, _definition.isCompositeType)(type)) {
            var typeStr = (0, _printer.print)(node.typeCondition);
            context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(node.name.value, '" cannot condition on non composite type "').concat(typeStr, '".'), node.typeCondition));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context) {
      return {
        VariableDefinition: function VariableDefinition(node) {
          var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
          if (type && !(0, _definition.isInputType)(type)) {
            var variableName = node.variable.name.value;
            var typeName = (0, _printer.print)(node.type);
            context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(variableName, '" cannot be non-input type "').concat(typeName, '".'), node.type));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ScalarLeafsRule(context) {
      return {
        Field: function Field(node) {
          var type = context.getType();
          var selectionSet = node.selectionSet;
          if (type) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
              if (selectionSet) {
                var fieldName = node.name.value;
                var typeStr = (0, _inspect.default)(type);
                context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" must not have a selection since type "').concat(typeStr, '" has no subfields.'), selectionSet));
              }
            } else if (!selectionSet) {
              var _fieldName = node.name.value;
              var _typeStr = (0, _inspect.default)(type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(_fieldName, '" of type "').concat(_typeStr, '" must have a selection of subfields. Did you mean "').concat(_fieldName, ' { ... }"?'), node));
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _arrayFrom = _interopRequireDefault(require_arrayFrom());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function FieldsOnCorrectTypeRule(context) {
      return {
        Field: function Field(node) {
          var type = context.getParentType();
          if (type) {
            var fieldDef = context.getFieldDef();
            if (!fieldDef) {
              var schema = context.getSchema();
              var fieldName = node.name.value;
              var suggestion = (0, _didYouMean.default)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
              if (suggestion === "") {
                suggestion = (0, _didYouMean.default)(getSuggestedFieldNames(type, fieldName));
              }
              context.reportError(new _GraphQLError.GraphQLError('Cannot query field "'.concat(fieldName, '" on type "').concat(type.name, '".') + suggestion, node));
            }
          }
        }
      };
    }
    function getSuggestedTypeNames(schema, type, fieldName) {
      if (!(0, _definition.isAbstractType)(type)) {
        return [];
      }
      var suggestedTypes = /* @__PURE__ */ new Set();
      var usageCount = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {
        var possibleType = _schema$getPossibleTy2[_i2];
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {
          var _usageCount$possibleI;
          var possibleInterface = _possibleType$getInte2[_i4];
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return (0, _arrayFrom.default)(suggestedTypes).sort(function(typeA, typeB) {
        var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.default)(typeA.name, typeB.name);
      }).map(function(x) {
        return x.name;
      });
    }
    function getSuggestedFieldNames(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        var possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.default)(fieldName, possibleFieldNames);
      }
      return [];
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context) {
      var knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          var fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one fragment named "'.concat(fragmentName, '".'), [knownFragmentNames[fragmentName], node.name]));
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context) {
      return {
        FragmentSpread: function FragmentSpread(node) {
          var fragmentName = node.name.value;
          var fragment = context.getFragment(fragmentName);
          if (!fragment) {
            context.reportError(new _GraphQLError.GraphQLError('Unknown fragment "'.concat(fragmentName, '".'), node.name));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context) {
      var operationDefs = [];
      var fragmentDefs = [];
      return {
        OperationDefinition: function OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave: function leave() {
            var fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {
              var operation = operationDefs[_i2];
              for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {
                var fragment = _context$getRecursive2[_i4];
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {
              var fragmentDef = fragmentDefs[_i6];
              var fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" is never used.'), fragmentDef));
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _typeComparators = require_typeComparators();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function PossibleFragmentSpreadsRule(context) {
      return {
        InlineFragment: function InlineFragment(node) {
          var fragType = context.getType();
          var parentType = context.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            var parentTypeStr = (0, _inspect.default)(parentType);
            var fragTypeStr = (0, _inspect.default)(fragType);
            context.reportError(new _GraphQLError.GraphQLError('Fragment cannot be spread here as objects of type "'.concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
          }
        },
        FragmentSpread: function FragmentSpread(node) {
          var fragName = node.name.value;
          var fragType = getFragmentType(context, fragName);
          var parentType = context.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            var parentTypeStr = (0, _inspect.default)(parentType);
            var fragTypeStr = (0, _inspect.default)(fragType);
            context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" cannot be spread here as objects of type "').concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
          }
        }
      };
    }
    function getFragmentType(context, name) {
      var frag = context.getFragment(name);
      if (frag) {
        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
        if ((0, _definition.isCompositeType)(type)) {
          return type;
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context) {
      var visitedFrags = /* @__PURE__ */ Object.create(null);
      var spreadPath = [];
      var spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        var fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {
          var spreadNode = spreadNodes[_i2];
          var spreadName = spreadNode.name.value;
          var cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            var spreadFragment = context.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            var cyclePath = spreadPath.slice(cycleIndex);
            var viaPath = cyclePath.slice(0, -1).map(function(s) {
              return '"' + s.name.value + '"';
            }).join(", ");
            context.reportError(new _GraphQLError.GraphQLError('Cannot spread fragment "'.concat(spreadName, '" within itself') + (viaPath !== "" ? " via ".concat(viaPath, ".") : "."), cyclePath));
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context) {
      var knownVariableNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          knownVariableNames = /* @__PURE__ */ Object.create(null);
        },
        VariableDefinition: function VariableDefinition(node) {
          var variableName = node.variable.name.value;
          if (knownVariableNames[variableName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one variable named "$'.concat(variableName, '".'), [knownVariableNames[variableName], node.variable.name]));
          } else {
            knownVariableNames[variableName] = node.variable.name;
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context) {
      var variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter: function enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave: function leave(operation) {
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              var varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(varName, '" is not defined by operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(varName, '" is not defined.'), [node, operation]));
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context) {
      var variableDefs = [];
      return {
        OperationDefinition: {
          enter: function enter() {
            variableDefs = [];
          },
          leave: function leave(operation) {
            var variableNameUsed = /* @__PURE__ */ Object.create(null);
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              variableNameUsed[node.name.value] = true;
            }
            for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {
              var variableDef = _variableDefs2[_i4];
              var variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(variableName, '" is never used in operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(variableName, '" is never used.'), variableDef));
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directiveLocation = require_directiveLocation();
    var _directives = require_directives();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function KnownDirectivesRule(context) {
      var locationsMap = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        locationsMap[directive.name] = directive.locations;
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map(function(name) {
            return name.value;
          });
        }
      }
      return {
        Directive: function Directive(node, _key, _parent, _path, ancestors) {
          var name = node.name.value;
          var locations = locationsMap[name];
          if (!locations) {
            context.reportError(new _GraphQLError.GraphQLError('Unknown directive "@'.concat(name, '".'), node));
            return;
          }
          var candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
            context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(name, '" may not be used on ').concat(candidateLocation, "."), node));
          }
        }
      };
    }
    function getDirectiveLocationForASTPath(ancestors) {
      var appliedTo = ancestors[ancestors.length - 1];
      !Array.isArray(appliedTo) || (0, _invariant.default)(0);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          var parentNode = ancestors[ancestors.length - 3];
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
      }
    }
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case "query":
          return _directiveLocation.DirectiveLocation.QUERY;
        case "mutation":
          return _directiveLocation.DirectiveLocation.MUTATION;
        case "subscription":
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
      (0, _invariant.default)(0, "Unexpected operation: " + (0, _inspect.default)(operation));
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context) {
      var uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      var schemaDirectives = /* @__PURE__ */ Object.create(null);
      var typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        enter: function enter(node) {
          if (node.directives == null) {
            return;
          }
          var seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            var typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {
            var _directive = _node$directives2[_i6];
            var directiveName = _directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context.reportError(new _GraphQLError.GraphQLError('The directive "@'.concat(directiveName, '" can only be used once at this location.'), [seenDirectives[directiveName], _directive]));
              } else {
                seenDirectives[directiveName] = _directive;
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
    exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function KnownArgumentNamesRule(context) {
      return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
        Argument: function Argument(argNode) {
          var argDef = context.getArgument();
          var fieldDef = context.getFieldDef();
          var parentType = context.getParentType();
          if (!argDef && fieldDef && parentType) {
            var argName = argNode.name.value;
            var knownArgsNames = fieldDef.args.map(function(arg) {
              return arg.name;
            });
            var suggestions = (0, _suggestionList.default)(argName, knownArgsNames);
            context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on field "').concat(parentType.name, ".").concat(fieldDef.name, '".') + (0, _didYouMean.default)(suggestions), argNode));
          }
        }
      });
    }
    function KnownArgumentNamesOnDirectivesRule(context) {
      var directiveArgs = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        directiveArgs[directive.name] = directive.args.map(function(arg) {
          return arg.name;
        });
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map(function(arg) {
            return arg.name.value;
          });
        }
      }
      return {
        Directive: function Directive(directiveNode) {
          var directiveName = directiveNode.name.value;
          var knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {
              var argNode = _directiveNode$argume2[_i6];
              var argName = argNode.name.value;
              if (knownArgs.indexOf(argName) === -1) {
                var suggestions = (0, _suggestionList.default)(argName, knownArgs);
                context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on directive "@').concat(directiveName, '".') + (0, _didYouMean.default)(suggestions), argNode));
              }
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context) {
      var knownArgNames = /* @__PURE__ */ Object.create(null);
      return {
        Field: function Field() {
          knownArgNames = /* @__PURE__ */ Object.create(null);
        },
        Directive: function Directive() {
          knownArgNames = /* @__PURE__ */ Object.create(null);
        },
        Argument: function Argument(node) {
          var argName = node.name.value;
          if (knownArgNames[argName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one argument named "'.concat(argName, '".'), [knownArgNames[argName], node.name]));
          } else {
            knownArgNames[argName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ValuesOfCorrectTypeRule(context) {
      return {
        ListValue: function ListValue(node) {
          var type = (0, _definition.getNullableType)(context.getParentInputType());
          if (!(0, _definition.isListType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
        },
        ObjectValue: function ObjectValue(node) {
          var type = (0, _definition.getNamedType)(context.getInputType());
          if (!(0, _definition.isInputObjectType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
          var fieldNodeMap = (0, _keyMap.default)(node.fields, function(field) {
            return field.name.value;
          });
          for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i2 < _objectValues2.length; _i2++) {
            var fieldDef = _objectValues2[_i2];
            var fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              var typeStr = (0, _inspect.default)(fieldDef.type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(type.name, ".").concat(fieldDef.name, '" of required type "').concat(typeStr, '" was not provided.'), node));
            }
          }
        },
        ObjectField: function ObjectField(node) {
          var parentType = (0, _definition.getNamedType)(context.getParentInputType());
          var fieldType = context.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(node.name.value, '" is not defined by type "').concat(parentType.name, '".') + (0, _didYouMean.default)(suggestions), node));
          }
        },
        NullValue: function NullValue(node) {
          var type = context.getInputType();
          if ((0, _definition.isNonNullType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat((0, _inspect.default)(type), '", found ').concat((0, _printer.print)(node), "."), node));
          }
        },
        EnumValue: function EnumValue(node) {
          return isValidValueNode(context, node);
        },
        IntValue: function IntValue(node) {
          return isValidValueNode(context, node);
        },
        FloatValue: function FloatValue(node) {
          return isValidValueNode(context, node);
        },
        StringValue: function StringValue(node) {
          return isValidValueNode(context, node);
        },
        BooleanValue: function BooleanValue(node) {
          return isValidValueNode(context, node);
        }
      };
    }
    function isValidValueNode(context, node) {
      var locationType = context.getInputType();
      if (!locationType) {
        return;
      }
      var type = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type)) {
        var typeStr = (0, _inspect.default)(locationType);
        context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
        return;
      }
      try {
        var parseResult = type.parseLiteral(node, void 0);
        if (parseResult === void 0) {
          var _typeStr = (0, _inspect.default)(locationType);
          context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
        }
      } catch (error) {
        var _typeStr2 = (0, _inspect.default)(locationType);
        if (error instanceof _GraphQLError.GraphQLError) {
          context.reportError(error);
        } else {
          context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr2, '", found ').concat((0, _printer.print)(node), "; ") + error.message, node, void 0, void 0, void 0, error));
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ProvidedRequiredArgumentsRule(context) {
      return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
        Field: {
          leave: function leave(fieldNode) {
            var _fieldNode$arguments;
            var fieldDef = context.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
            var argNodeMap = (0, _keyMap.default)(argNodes, function(arg) {
              return arg.name.value;
            });
            for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {
              var argDef = _fieldDef$args2[_i2];
              var argNode = argNodeMap[argDef.name];
              if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {
                var argTypeStr = (0, _inspect.default)(argDef.type);
                context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldDef.name, '" argument "').concat(argDef.name, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), fieldNode));
              }
            }
          }
        }
      });
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
      var requiredArgsMap = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {
        var directive = definedDirectives[_i4];
        requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function(arg) {
          return arg.name;
        });
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {
        var def = astDefinitions[_i6];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.default)(argNodes.filter(isRequiredArgumentNode), function(arg) {
            return arg.name.value;
          });
        }
      }
      return {
        Directive: {
          leave: function leave(directiveNode) {
            var directiveName = directiveNode.name.value;
            var requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              var argNodeMap = (0, _keyMap.default)(_argNodes, function(arg) {
                return arg.name.value;
              });
              for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {
                var argName = _Object$keys2[_i8];
                if (!argNodeMap[argName]) {
                  var argType = requiredArgs[argName].type;
                  var argTypeStr = (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType);
                  context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" argument "').concat(argName, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), directiveNode));
                }
              }
            }
          }
        }
      };
    }
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _typeComparators = require_typeComparators();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function VariablesInAllowedPositionRule(context) {
      var varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter: function enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave: function leave(operation) {
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              var type = _ref2.type;
              var defaultValue = _ref2.defaultValue;
              var varName = node.name.value;
              var varDef = varDefMap[varName];
              if (varDef && type) {
                var schema = context.getSchema();
                var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                  var varTypeStr = (0, _inspect.default)(varType);
                  var typeStr = (0, _inspect.default)(type);
                  context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of type "').concat(varTypeStr, '" used in position expecting type "').concat(typeStr, '".'), [varDef, node]));
                }
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        var hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        var nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _find = _interopRequireDefault(require_find());
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(function(_ref) {
          var responseName = _ref[0], subReason = _ref[1];
          return 'subfields "'.concat(responseName, '" conflict because ') + reasonMessage(subReason);
        }).join(" and ");
      }
      return reason;
    }
    function OverlappingFieldsCanBeMergedRule(context) {
      var comparedFragmentPairs = new PairSet();
      var cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet: function SelectionSet(selectionSet) {
          var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
          for (var _i2 = 0; _i2 < conflicts.length; _i2++) {
            var _ref3 = conflicts[_i2];
            var _ref2$ = _ref3[0];
            var responseName = _ref2$[0];
            var reason = _ref2$[1];
            var fields1 = _ref3[1];
            var fields2 = _ref3[2];
            var reasonMsg = reasonMessage(reason);
            context.reportError(new _GraphQLError.GraphQLError('Fields "'.concat(responseName, '" conflict because ').concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields2)));
          }
        }
      };
    }
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
      var conflicts = [];
      var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
      collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
      if (fragmentNames.length !== 0) {
        for (var i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
          for (var j = i + 1; j < fragmentNames.length; j++) {
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
          }
        }
      }
      return conflicts;
    }
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      var fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
      for (var i = 0; i < fragmentNames2.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
      }
    }
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      var fragment1 = context.getFragment(fragmentName1);
      var fragment2 = context.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
      var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      for (var j = 0; j < fragmentNames2.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
      }
      for (var i = 0; i < fragmentNames1.length; i++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
      }
    }
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      var conflicts = [];
      var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
      var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      if (fragmentNames2.length !== 0) {
        for (var j = 0; j < fragmentNames2.length; j++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
        }
      }
      if (fragmentNames1.length !== 0) {
        for (var i = 0; i < fragmentNames1.length; i++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
        }
      }
      for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {
        for (var _j = 0; _j < fragmentNames2.length; _j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
        }
      }
      return conflicts;
    }
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
      for (var _i5 = 0, _objectEntries2 = (0, _objectEntries3.default)(fieldMap); _i5 < _objectEntries2.length; _i5++) {
        var _ref5 = _objectEntries2[_i5];
        var responseName = _ref5[0];
        var fields = _ref5[1];
        if (fields.length > 1) {
          for (var i = 0; i < fields.length; i++) {
            for (var j = i + 1; j < fields.length; j++) {
              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {
        var responseName = _Object$keys2[_i7];
        var fields2 = fieldMap2[responseName];
        if (fields2) {
          var fields1 = fieldMap1[responseName];
          for (var i = 0; i < fields1.length; i++) {
            for (var j = 0; j < fields2.length; j++) {
              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
      var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
      var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        var _node1$arguments, _node2$arguments;
        var name1 = node1.name.value;
        var name2 = node2.name.value;
        if (name1 !== name2) {
          return [[responseName, '"'.concat(name1, '" and "').concat(name2, '" are different fields')], [node1], [node2]];
        }
        var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : [];
        var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : [];
        if (!sameArguments(args1, args2)) {
          return [[responseName, "they have differing arguments"], [node1], [node2]];
        }
      }
      var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [[responseName, 'they return conflicting types "'.concat((0, _inspect.default)(type1), '" and "').concat((0, _inspect.default)(type2), '"')], [node1], [node2]];
      }
      var selectionSet1 = node1.selectionSet;
      var selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    function sameArguments(arguments1, arguments2) {
      if (arguments1.length !== arguments2.length) {
        return false;
      }
      return arguments1.every(function(argument1) {
        var argument2 = (0, _find.default)(arguments2, function(argument) {
          return argument.name.value === argument1.name.value;
        });
        if (!argument2) {
          return false;
        }
        return sameValue(argument1.value, argument2.value);
      });
    }
    function sameValue(value1, value2) {
      return (0, _printer.print)(value1) === (0, _printer.print)(value2);
    }
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      var cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (!cached) {
        var nodeAndDefs = /* @__PURE__ */ Object.create(null);
        var fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        cached = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, cached);
      }
      return cached;
    }
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
      var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
      return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
    }
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {
        var selection = _selectionSet$selecti2[_i9];
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            var fieldName = selection.name.value;
            var fieldDef = void 0;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            var responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            var typeCondition = selection.typeCondition;
            var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
            break;
          }
        }
      }
    }
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [[responseName, conflicts.map(function(_ref6) {
          var reason = _ref6[0];
          return reason;
        })], conflicts.reduce(function(allFields, _ref7) {
          var fields1 = _ref7[1];
          return allFields.concat(fields1);
        }, [node1]), conflicts.reduce(function(allFields, _ref8) {
          var fields2 = _ref8[2];
          return allFields.concat(fields2);
        }, [node2])];
      }
    }
    var PairSet = /* @__PURE__ */ function() {
      function PairSet2() {
        this._data = /* @__PURE__ */ Object.create(null);
      }
      var _proto = PairSet2.prototype;
      _proto.has = function has(a, b, areMutuallyExclusive) {
        var first = this._data[a];
        var result = first && first[b];
        if (result === void 0) {
          return false;
        }
        if (areMutuallyExclusive === false) {
          return result === false;
        }
        return true;
      };
      _proto.add = function add(a, b, areMutuallyExclusive) {
        this._pairSetAdd(a, b, areMutuallyExclusive);
        this._pairSetAdd(b, a, areMutuallyExclusive);
      };
      _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {
        var map = this._data[a];
        if (!map) {
          map = /* @__PURE__ */ Object.create(null);
          this._data[a] = map;
        }
        map[b] = areMutuallyExclusive;
      };
      return PairSet2;
    }();
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context) {
      var knownNameStack = [];
      var knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter: function enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave: function leave() {
            knownNames = knownNameStack.pop();
          }
        },
        ObjectField: function ObjectField(node) {
          var fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one input field named "'.concat(fieldName, '".'), [knownNames[fieldName], node.name]));
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context) {
      var _ref, _ref2, _oldSchema$astNode;
      var oldSchema = context.getSchema();
      var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      var schemaDefinitionsCount = 0;
      return {
        SchemaDefinition: function SchemaDefinition(node) {
          if (alreadyDefined) {
            context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", node));
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", node));
          }
          ++schemaDefinitionsCount;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context) {
      var schema = context.getSchema();
      var definedOperationTypes = /* @__PURE__ */ Object.create(null);
      var existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {
          var operationType = operationTypesNodes[_i2];
          var operation = operationType.operation;
          var alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context.reportError(new _GraphQLError.GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
          } else if (alreadyDefinedOperationType) {
            context.reportError(new _GraphQLError.GraphQLError("There can be only one ".concat(operation, " type in schema."), [alreadyDefinedOperationType, operationType]));
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context) {
      var knownTypeNames = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        var typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context.reportError(new _GraphQLError.GraphQLError('Type "'.concat(typeName, '" already exists in the schema. It cannot also be defined in this type definition.'), node.name));
          return;
        }
        if (knownTypeNames[typeName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one type named "'.concat(typeName, '".'), [knownTypeNames[typeName], node.name]));
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context) {
      var schema = context.getSchema();
      var existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      var knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        var typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        var valueNames = knownValueNames[typeName];
        for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {
          var valueDef = valueNodes[_i2];
          var valueName = valueDef.name.value;
          var existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" already exists in the schema. It cannot also be defined in this type extension.'), valueDef.name));
          } else if (valueNames[valueName]) {
            context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" can only be defined once.'), [valueNames[valueName], valueDef.name]));
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context) {
      var schema = context.getSchema();
      var existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      var knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        var typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        var fieldNames = knownFieldNames[typeName];
        for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {
          var fieldDef = fieldNodes[_i2];
          var fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" already exists in the schema. It cannot also be defined in this type extension.'), fieldDef.name));
          } else if (fieldNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" can only be defined once.'), [fieldNames[fieldName], fieldDef.name]));
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
    }
    function hasField(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context) {
      var knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      var schema = context.getSchema();
      return {
        DirectiveDefinition: function DirectiveDefinition(node) {
          var directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" already exists in the schema. It cannot be redefined.'), node.name));
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one directive named "@'.concat(directiveName, '".'), [knownDirectiveNames[directiveName], node.name]));
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _defKindToExtKind;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function PossibleTypeExtensionsRule(context) {
      var schema = context.getSchema();
      var definedTypes = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        var typeName = node.name.value;
        var defNode = definedTypes[typeName];
        var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        var expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            var kindStr = extensionKindToTypeName(node.kind);
            context.reportError(new _GraphQLError.GraphQLError("Cannot extend non-".concat(kindStr, ' type "').concat(typeName, '".'), defNode ? [defNode, node] : node));
          }
        } else {
          var allTypeNames = Object.keys(definedTypes);
          if (schema) {
            allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
          }
          var suggestedTypes = (0, _suggestionList.default)(typeName, allTypeNames);
          context.reportError(new _GraphQLError.GraphQLError('Cannot extend type "'.concat(typeName, '" because it is not defined.') + (0, _didYouMean.default)(suggestedTypes), node.name));
        }
      }
    }
    var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _kinds.Kind.SCALAR_TYPE_DEFINITION, _kinds.Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.OBJECT_TYPE_DEFINITION, _kinds.Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INTERFACE_TYPE_DEFINITION, _kinds.Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.UNION_TYPE_DEFINITION, _kinds.Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.ENUM_TYPE_DEFINITION, _kinds.Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
    function typeToExtKind(type) {
      if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
      }
      (0, _invariant.default)(0, "Unexpected kind: " + (0, _inspect.default)(kind));
    }
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/graphql/validation/specifiedRules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.specifiedSDLRules = exports.specifiedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var specifiedRules = Object.freeze([_ExecutableDefinitionsRule.ExecutableDefinitionsRule, _UniqueOperationNamesRule.UniqueOperationNamesRule, _LoneAnonymousOperationRule.LoneAnonymousOperationRule, _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule, _KnownTypeNamesRule.KnownTypeNamesRule, _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule, _VariablesAreInputTypesRule.VariablesAreInputTypesRule, _ScalarLeafsRule.ScalarLeafsRule, _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule, _UniqueFragmentNamesRule.UniqueFragmentNamesRule, _KnownFragmentNamesRule.KnownFragmentNamesRule, _NoUnusedFragmentsRule.NoUnusedFragmentsRule, _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule, _NoFragmentCyclesRule.NoFragmentCyclesRule, _UniqueVariableNamesRule.UniqueVariableNamesRule, _NoUndefinedVariablesRule.NoUndefinedVariablesRule, _NoUnusedVariablesRule.NoUnusedVariablesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _KnownArgumentNamesRule.KnownArgumentNamesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule, _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule, _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule]);
    exports.specifiedRules = specifiedRules;
    var specifiedSDLRules = Object.freeze([_LoneSchemaDefinitionRule.LoneSchemaDefinitionRule, _UniqueOperationTypesRule.UniqueOperationTypesRule, _UniqueTypeNamesRule.UniqueTypeNamesRule, _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule, _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule, _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule, _KnownTypeNamesRule.KnownTypeNamesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule, _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule]);
    exports.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/graphql/validation/ValidationContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var ASTValidationContext = /* @__PURE__ */ function() {
      function ASTValidationContext2(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      var _proto = ASTValidationContext2.prototype;
      _proto.reportError = function reportError(error) {
        this._onError(error);
      };
      _proto.getDocument = function getDocument() {
        return this._ast;
      };
      _proto.getFragment = function getFragment(name) {
        var fragments = this._fragments;
        if (!fragments) {
          this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
            if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              frags[statement.name.value] = statement;
            }
            return frags;
          }, /* @__PURE__ */ Object.create(null));
        }
        return fragments[name];
      };
      _proto.getFragmentSpreads = function getFragmentSpreads(node) {
        var spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          var setsToVisit = [node];
          while (setsToVisit.length !== 0) {
            var set = setsToVisit.pop();
            for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {
              var selection = _set$selections2[_i2];
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      };
      _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
        var fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          var collectedNames = /* @__PURE__ */ Object.create(null);
          var nodesToVisit = [operation.selectionSet];
          while (nodesToVisit.length !== 0) {
            var node = nodesToVisit.pop();
            for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {
              var spread = _this$getFragmentSpre2[_i4];
              var fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                var fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      };
      return ASTValidationContext2;
    }();
    exports.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = /* @__PURE__ */ function(_ASTValidationContext) {
      _inheritsLoose(SDLValidationContext2, _ASTValidationContext);
      function SDLValidationContext2(ast, schema, onError) {
        var _this;
        _this = _ASTValidationContext.call(this, ast, onError) || this;
        _this._schema = schema;
        return _this;
      }
      var _proto2 = SDLValidationContext2.prototype;
      _proto2.getSchema = function getSchema() {
        return this._schema;
      };
      return SDLValidationContext2;
    }(ASTValidationContext);
    exports.SDLValidationContext = SDLValidationContext;
    var ValidationContext = /* @__PURE__ */ function(_ASTValidationContext2) {
      _inheritsLoose(ValidationContext2, _ASTValidationContext2);
      function ValidationContext2(schema, ast, typeInfo, onError) {
        var _this2;
        _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
        _this2._schema = schema;
        _this2._typeInfo = typeInfo;
        _this2._variableUsages = /* @__PURE__ */ new Map();
        _this2._recursiveVariableUsages = /* @__PURE__ */ new Map();
        return _this2;
      }
      var _proto3 = ValidationContext2.prototype;
      _proto3.getSchema = function getSchema() {
        return this._schema;
      };
      _proto3.getVariableUsages = function getVariableUsages(node) {
        var usages = this._variableUsages.get(node);
        if (!usages) {
          var newUsages = [];
          var typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
            VariableDefinition: function VariableDefinition() {
              return false;
            },
            Variable: function Variable(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue()
              });
            }
          }));
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      };
      _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
        var usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {
            var frag = _this$getRecursivelyR2[_i6];
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      };
      _proto3.getType = function getType() {
        return this._typeInfo.getType();
      };
      _proto3.getParentType = function getParentType() {
        return this._typeInfo.getParentType();
      };
      _proto3.getInputType = function getInputType() {
        return this._typeInfo.getInputType();
      };
      _proto3.getParentInputType = function getParentInputType() {
        return this._typeInfo.getParentInputType();
      };
      _proto3.getFieldDef = function getFieldDef() {
        return this._typeInfo.getFieldDef();
      };
      _proto3.getDirective = function getDirective() {
        return this._typeInfo.getDirective();
      };
      _proto3.getArgument = function getArgument() {
        return this._typeInfo.getArgument();
      };
      _proto3.getEnumValue = function getEnumValue() {
        return this._typeInfo.getEnumValue();
      };
      return ValidationContext2;
    }(ASTValidationContext);
    exports.ValidationContext = ValidationContext;
  }
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/graphql/validation/validate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validate = validate;
    exports.validateSDL = validateSDL;
    exports.assertValidSDL = assertValidSDL;
    exports.assertValidSDLExtension = assertValidSDLExtension;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(schema, documentAST) {
      var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _specifiedRules.specifiedRules;
      var typeInfo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new _TypeInfo.TypeInfo(schema);
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        maxErrors: void 0
      };
      documentAST || (0, _devAssert.default)(0, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      var abortObj = Object.freeze({});
      var errors = [];
      var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, function(error) {
        if (options.maxErrors != null && errors.length >= options.maxErrors) {
          errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
          throw abortObj;
        }
        errors.push(error);
      });
      var visitor = (0, _visitor.visitInParallel)(rules.map(function(rule) {
        return rule(context);
      }));
      try {
        (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    function validateSDL(documentAST, schemaToExtend) {
      var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _specifiedRules.specifiedSDLRules;
      var errors = [];
      var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, function(error) {
        errors.push(error);
      });
      var visitors = rules.map(function(rule) {
        return rule(context);
      });
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    function assertValidSDL(documentAST) {
      var errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
          return error.message;
        }).join("\n\n"));
      }
    }
    function assertValidSDLExtension(documentAST, schema) {
      var errors = validateSDL(documentAST, schema);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error) {
          return error.message;
        }).join("\n\n"));
      }
    }
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/graphql/jsutils/memoize3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = memoize3;
    function memoize3(fn) {
      var cache0;
      return function memoized(a1, a2, a3) {
        if (!cache0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        var cache1 = cache0.get(a1);
        var cache2;
        if (cache1) {
          cache2 = cache1.get(a2);
          if (cache2) {
            var cachedValue = cache2.get(a3);
            if (cachedValue !== void 0) {
              return cachedValue;
            }
          }
        } else {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        var newValue = fn(a1, a2, a3);
        cache2.set(a3, newValue);
        return newValue;
      };
    }
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/graphql/jsutils/promiseReduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = promiseReduce;
    var _isPromise = _interopRequireDefault(require_isPromise());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function promiseReduce(values, callback, initialValue) {
      return values.reduce(function(previous, value) {
        return (0, _isPromise.default)(previous) ? previous.then(function(resolved) {
          return callback(resolved, value);
        }) : callback(previous, value);
      }, initialValue);
    }
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/graphql/jsutils/promiseForObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = promiseForObject;
    function promiseForObject(object) {
      var keys = Object.keys(object);
      var valuesAndPromises = keys.map(function(name) {
        return object[name];
      });
      return Promise.all(valuesAndPromises).then(function(values) {
        return values.reduce(function(resolvedObject, value, i) {
          resolvedObject[keys[i]] = value;
          return resolvedObject;
        }, /* @__PURE__ */ Object.create(null));
      });
    }
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/graphql/jsutils/Path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addPath = addPath;
    exports.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    function pathToArray(path) {
      var flattened = [];
      var curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/graphql/utilities/getOperationRootType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema, operation) {
      if (operation.operation === "query") {
        var queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", operation);
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        var mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", operation);
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        var subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", operation);
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", operation);
    }
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/graphql/jsutils/printPathArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = printPathArray;
    function printPathArray(path) {
      return path.map(function(key) {
        return typeof key === "number" ? "[" + key.toString() + "]" : "." + key;
      }).join("");
    }
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/graphql/utilities/valueFromAST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valueFromAST = valueFromAST;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _kinds = require_kinds();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function valueFromAST(valueNode, type, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        var variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        var variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST(valueNode, type.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          var coercedValues = [];
          for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
            var itemNode = _valueNode$values2[_i2];
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              var itemValue = valueFromAST(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        var coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        var coercedObj = /* @__PURE__ */ Object.create(null);
        var fieldNodes = (0, _keyMap.default)(valueNode.fields, function(field2) {
          return field2.name.value;
        });
        for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {
          var field = _objectValues2[_i4];
          var fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type)) {
        var result;
        try {
          result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/graphql/utilities/coerceInputValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.coerceInputValue = coerceInputValue;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _printPathArray = _interopRequireDefault(require_printPathArray());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function coerceInputValue(inputValue, type) {
      var onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOnError;
      return coerceInputValueImpl(inputValue, type, onError);
    }
    function defaultOnError(path, invalidValue, error) {
      var errorPrefix = "Invalid value " + (0, _inspect.default)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ' at "value'.concat((0, _printPathArray.default)(path), '"');
      }
      error.message = errorPrefix + ": " + error.message;
      throw error;
    }
    function coerceInputValueImpl(inputValue, type, onError, path) {
      if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected non-nullable type "'.concat((0, _inspect.default)(type), '" not to be null.')));
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        var coercedList = (0, _safeArrayFrom.default)(inputValue, function(itemValue, index) {
          var itemPath = (0, _Path.addPath)(path, index, void 0);
          return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
        });
        if (coercedList != null) {
          return coercedList;
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.default)(inputValue)) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '" to be an object.')));
          return;
        }
        var coercedValue = {};
        var fieldDefs = type.getFields();
        for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(fieldDefs); _i2 < _objectValues2.length; _i2++) {
          var field = _objectValues2[_i2];
          var fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              var typeStr = (0, _inspect.default)(field.type);
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(field.name, '" of required type "').concat(typeStr, '" was not provided.')));
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
        }
        for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {
          var fieldName = _Object$keys2[_i4];
          if (!fieldDefs[fieldName]) {
            var suggestions = (0, _suggestionList.default)(fieldName, Object.keys(type.getFields()));
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" is not defined by type "').concat(type.name, '".') + (0, _didYouMean.default)(suggestions)));
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type)) {
        var parseResult;
        try {
          parseResult = type.parseValue(inputValue);
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error);
          } else {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '". ') + error.message, void 0, void 0, void 0, void 0, error));
          }
          return;
        }
        if (parseResult === void 0) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '".')));
        }
        return parseResult;
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/graphql/execution/values.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getVariableValues = getVariableValues;
    exports.getArgumentValues = getArgumentValues;
    exports.getDirectiveValues = getDirectiveValues;
    var _find = _interopRequireDefault(require_find());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _printPathArray = _interopRequireDefault(require_printPathArray());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _coerceInputValue = require_coerceInputValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getVariableValues(schema, varDefNodes, inputs, options) {
      var errors = [];
      var maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
      try {
        var coerced = coerceVariableValues(schema, varDefNodes, inputs, function(error) {
          if (maxErrors != null && errors.length >= maxErrors) {
            throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
          }
          errors.push(error);
        });
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error) {
        errors.push(error);
      }
      return {
        errors
      };
    }
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      var coercedValues = {};
      var _loop = function _loop2(_i22) {
        var varDefNode = varDefNodes[_i22];
        var varName = varDefNode.variable.name.value;
        var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          var varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" expected value of type "').concat(varTypeStr, '" which cannot be used as an input type.'), varDefNode.type));
          return "continue";
        }
        if (!hasOwnProperty(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
          } else if ((0, _definition.isNonNullType)(varType)) {
            var _varTypeStr = (0, _inspect.default)(varType);
            onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of required type "').concat(_varTypeStr, '" was not provided.'), varDefNode));
          }
          return "continue";
        }
        var value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          var _varTypeStr2 = (0, _inspect.default)(varType);
          onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of non-null type "').concat(_varTypeStr2, '" must not be null.'), varDefNode));
          return "continue";
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, function(path, invalidValue, error) {
          var prefix = 'Variable "$'.concat(varName, '" got invalid value ') + (0, _inspect.default)(invalidValue);
          if (path.length > 0) {
            prefix += ' at "'.concat(varName).concat((0, _printPathArray.default)(path), '"');
          }
          onError(new _GraphQLError.GraphQLError(prefix + "; " + error.message, varDefNode, void 0, void 0, void 0, error.originalError));
        });
      };
      for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {
        var _ret = _loop(_i2);
        if (_ret === "continue")
          continue;
      }
      return coercedValues;
    }
    function getArgumentValues(def, node, variableValues) {
      var _node$arguments;
      var coercedValues = {};
      var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      var argNodeMap = (0, _keyMap.default)(argumentNodes, function(arg) {
        return arg.name.value;
      });
      for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
        var argDef = _def$args2[_i4];
        var name = argDef.name;
        var argType = argDef.type;
        var argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + "was not provided.", node);
          }
          continue;
        }
        var valueNode = argumentNode.value;
        var isNull = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          var variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + 'was provided the variable "$'.concat(variableName, '" which was not provided a runtime value.'), valueNode);
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of non-null type "').concat((0, _inspect.default)(argType), '" ') + "must not be null.", valueNode);
        }
        var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" has invalid value ').concat((0, _printer.print)(valueNode), "."), valueNode);
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    function getDirectiveValues(directiveDef, node, variableValues) {
      var directiveNode = node.directives && (0, _find.default)(node.directives, function(directive) {
        return directive.name.value === directiveDef.name;
      });
      if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
      }
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/graphql/execution/execute.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.execute = execute;
    exports.executeSync = executeSync;
    exports.assertValidExecutionArguments = assertValidExecutionArguments;
    exports.buildExecutionContext = buildExecutionContext;
    exports.collectFields = collectFields;
    exports.buildResolveInfo = buildResolveInfo;
    exports.getFieldDef = getFieldDef;
    exports.defaultFieldResolver = exports.defaultTypeResolver = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    var _memoize = _interopRequireDefault(require_memoize3());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _isPromise = _interopRequireDefault(require_isPromise());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _promiseReduce = _interopRequireDefault(require_promiseReduce());
    var _promiseForObject = _interopRequireDefault(require_promiseForObject());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _kinds = require_kinds();
    var _validate = require_validate();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _getOperationRootType = require_getOperationRootType();
    var _values = require_values();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({
        schema: argsOrSchema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
    function executeSync(args) {
      var result = executeImpl(args);
      if ((0, _isPromise.default)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function executeImpl(args) {
      var schema = args.schema, document = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
      assertValidExecutionArguments(schema, document, variableValues);
      var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver);
      if (Array.isArray(exeContext)) {
        return {
          errors: exeContext
        };
      }
      var data = executeOperation(exeContext, exeContext.operation, rootValue);
      return buildResponse(exeContext, data);
    }
    function buildResponse(exeContext, data) {
      if ((0, _isPromise.default)(data)) {
        return data.then(function(resolved) {
          return buildResponse(exeContext, resolved);
        });
      }
      return exeContext.errors.length === 0 ? {
        data
      } : {
        errors: exeContext.errors,
        data
      };
    }
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
      document || (0, _devAssert.default)(0, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.default)(rawVariableValues) || (0, _devAssert.default)(0, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
    }
    function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
      var _definition$name, _operation$variableDe;
      var operation;
      var fragments = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _document$definitions2 = document.definitions; _i2 < _document$definitions2.length; _i2++) {
        var definition = _document$definitions2[_i2];
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [new _GraphQLError.GraphQLError('Unknown operation named "'.concat(operationName, '".'))];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      var coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
      });
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        errors: []
      };
    }
    function executeOperation(exeContext, operation, rootValue) {
      var type = (0, _getOperationRootType.getOperationRootType)(exeContext.schema, operation);
      var fields = collectFields(exeContext, type, operation.selectionSet, /* @__PURE__ */ Object.create(null), /* @__PURE__ */ Object.create(null));
      var path = void 0;
      try {
        var result = operation.operation === "mutation" ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);
        if ((0, _isPromise.default)(result)) {
          return result.then(void 0, function(error) {
            exeContext.errors.push(error);
            return Promise.resolve(null);
          });
        }
        return result;
      } catch (error) {
        exeContext.errors.push(error);
        return null;
      }
    }
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.default)(Object.keys(fields), function(results, responseName) {
        var fieldNodes = fields[responseName];
        var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === void 0) {
          return results;
        }
        if ((0, _isPromise.default)(result)) {
          return result.then(function(resolvedResult) {
            results[responseName] = resolvedResult;
            return results;
          });
        }
        results[responseName] = result;
        return results;
      }, /* @__PURE__ */ Object.create(null));
    }
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      var results = /* @__PURE__ */ Object.create(null);
      var containsPromise = false;
      for (var _i4 = 0, _Object$keys2 = Object.keys(fields); _i4 < _Object$keys2.length; _i4++) {
        var responseName = _Object$keys2[_i4];
        var fieldNodes = fields[responseName];
        var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== void 0) {
          results[responseName] = result;
          if ((0, _isPromise.default)(result)) {
            containsPromise = true;
          }
        }
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.default)(results);
    }
    function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {
        var selection = _selectionSet$selecti2[_i6];
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode(exeContext, selection)) {
              continue;
            }
            var name = getFieldEntryKey(selection);
            if (!fields[name]) {
              fields[name] = [];
            }
            fields[name].push(selection);
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
              continue;
            }
            collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            var fragName = selection.name.value;
            if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
              continue;
            }
            visitedFragmentNames[fragName] = true;
            var fragment = exeContext.fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
              continue;
            }
            collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    function shouldIncludeNode(exeContext, node) {
      var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch(exeContext, fragment, type) {
      var typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return exeContext.schema.isSubType(conditionalType, type);
      }
      return false;
    }
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    function resolveField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      var fieldNode = fieldNodes[0];
      var fieldName = fieldNode.name.value;
      var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
      if (!fieldDef) {
        return;
      }
      var returnType = fieldDef.type;
      var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
      try {
        var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
        var _contextValue = exeContext.contextValue;
        var result = resolveFn(source, args, _contextValue, info);
        var completed;
        if ((0, _isPromise.default)(result)) {
          completed = result.then(function(resolved) {
            return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
          });
        } else {
          completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _isPromise.default)(completed)) {
          return completed.then(void 0, function(rawError) {
            var error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
            return handleFieldError(error2, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        var error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
        return handleFieldError(error, returnType, exeContext);
      }
    }
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    function handleFieldError(error, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error;
      }
      exeContext.errors.push(error);
      return null;
    }
    function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
          throw new Error("Cannot return null for non-nullable field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      (0, _invariant.default)(0, "Cannot complete value of unexpected output type: " + (0, _inspect.default)(returnType));
    }
    function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
      var itemType = returnType.ofType;
      var containsPromise = false;
      var completedResults = (0, _safeArrayFrom.default)(result, function(item, index) {
        var itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          var completedItem;
          if ((0, _isPromise.default)(item)) {
            completedItem = item.then(function(resolved) {
              return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);
            });
          } else {
            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
          }
          if ((0, _isPromise.default)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, function(rawError) {
              var error2 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
              return handleFieldError(error2, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          var error = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
          return handleFieldError(error, itemType, exeContext);
        }
      });
      if (completedResults == null) {
        throw new _GraphQLError.GraphQLError('Expected Iterable, but did not find one for field "'.concat(info.parentType.name, ".").concat(info.fieldName, '".'));
      }
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    function completeLeafValue(returnType, result) {
      var serializedResult = returnType.serialize(result);
      if (serializedResult === void 0) {
        throw new Error('Expected a value of type "'.concat((0, _inspect.default)(returnType), '" but ') + "received: ".concat((0, _inspect.default)(result)));
      }
      return serializedResult;
    }
    function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
      var _returnType$resolveTy;
      var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      var contextValue = exeContext.contextValue;
      var runtimeType = resolveTypeFn(result, contextValue, info, returnType);
      if ((0, _isPromise.default)(runtimeType)) {
        return runtimeType.then(function(resolvedRuntimeType) {
          return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
        });
      }
      return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    }
    function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
      if (runtimeTypeOrName == null) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '". Either the "').concat(returnType.name, '" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.'), fieldNodes);
      }
      var runtimeTypeName = (0, _definition.isNamedType)(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '" with ') + "value ".concat((0, _inspect.default)(result), ', received "').concat((0, _inspect.default)(runtimeTypeOrName), '".'));
      }
      var runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a type "').concat(runtimeTypeName, '" that does not exist inside schema.'), fieldNodes);
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a non-object type "').concat(runtimeTypeName, '".'), fieldNodes);
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError('Runtime Object type "'.concat(runtimeType.name, '" is not a possible type for "').concat(returnType.name, '".'), fieldNodes);
      }
      return runtimeType;
    }
    function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (returnType.isTypeOf) {
        var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.default)(isTypeOf)) {
          return isTypeOf.then(function(resolvedIsTypeOf) {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
    }
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError('Expected value of type "'.concat(returnType.name, '" but got: ').concat((0, _inspect.default)(result), "."), fieldNodes);
    }
    function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
      var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    var collectSubfields = (0, _memoize.default)(_collectSubfields);
    function _collectSubfields(exeContext, returnType, fieldNodes) {
      var subFieldNodes = /* @__PURE__ */ Object.create(null);
      var visitedFragmentNames = /* @__PURE__ */ Object.create(null);
      for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {
        var node = fieldNodes[_i8];
        if (node.selectionSet) {
          subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    }
    var defaultTypeResolver = function defaultTypeResolver2(value, contextValue, info, abstractType) {
      if ((0, _isObjectLike.default)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      var possibleTypes = info.schema.getPossibleTypes(abstractType);
      var promisedIsTypeOfResults = [];
      for (var i = 0; i < possibleTypes.length; i++) {
        var type = possibleTypes[i];
        if (type.isTypeOf) {
          var isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if ((0, _isPromise.default)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then(function(isTypeOfResults) {
          for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {
            if (isTypeOfResults[_i9]) {
              return possibleTypes[_i9].name;
            }
          }
        });
      }
    };
    exports.defaultTypeResolver = defaultTypeResolver;
    var defaultFieldResolver = function defaultFieldResolver2(source, args, contextValue, info) {
      if ((0, _isObjectLike.default)(source) || typeof source === "function") {
        var property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
    exports.defaultFieldResolver = defaultFieldResolver;
    function getFieldDef(schema, parentType, fieldName) {
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "node_modules/graphql/graphql.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.graphql = graphql;
    exports.graphqlSync = graphqlSync;
    var _isPromise = _interopRequireDefault(require_isPromise());
    var _parser = require_parser();
    var _validate = require_validate2();
    var _validate2 = require_validate();
    var _execute = require_execute();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      var _arguments = arguments;
      return new Promise(function(resolve) {
        return resolve(_arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
          schema: argsOrSchema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        }));
      });
    }
    function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
        schema: argsOrSchema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
      if ((0, _isPromise.default)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function graphqlImpl(args) {
      var schema = args.schema, source = args.source, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
      var schemaValidationErrors = (0, _validate2.validateSchema)(schema);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      var document;
      try {
        document = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      var validationErrors = (0, _validate.validate)(schema, document);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS({
  "node_modules/graphql/type/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isSchema", {
      enumerable: true,
      get: function get() {
        return _schema.isSchema;
      }
    });
    Object.defineProperty(exports, "assertSchema", {
      enumerable: true,
      get: function get() {
        return _schema.assertSchema;
      }
    });
    Object.defineProperty(exports, "GraphQLSchema", {
      enumerable: true,
      get: function get() {
        return _schema.GraphQLSchema;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function get() {
        return _definition.isType;
      }
    });
    Object.defineProperty(exports, "isScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.isScalarType;
      }
    });
    Object.defineProperty(exports, "isObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.isObjectType;
      }
    });
    Object.defineProperty(exports, "isInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.isInterfaceType;
      }
    });
    Object.defineProperty(exports, "isUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.isUnionType;
      }
    });
    Object.defineProperty(exports, "isEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.isEnumType;
      }
    });
    Object.defineProperty(exports, "isInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.isInputObjectType;
      }
    });
    Object.defineProperty(exports, "isListType", {
      enumerable: true,
      get: function get() {
        return _definition.isListType;
      }
    });
    Object.defineProperty(exports, "isNonNullType", {
      enumerable: true,
      get: function get() {
        return _definition.isNonNullType;
      }
    });
    Object.defineProperty(exports, "isInputType", {
      enumerable: true,
      get: function get() {
        return _definition.isInputType;
      }
    });
    Object.defineProperty(exports, "isOutputType", {
      enumerable: true,
      get: function get() {
        return _definition.isOutputType;
      }
    });
    Object.defineProperty(exports, "isLeafType", {
      enumerable: true,
      get: function get() {
        return _definition.isLeafType;
      }
    });
    Object.defineProperty(exports, "isCompositeType", {
      enumerable: true,
      get: function get() {
        return _definition.isCompositeType;
      }
    });
    Object.defineProperty(exports, "isAbstractType", {
      enumerable: true,
      get: function get() {
        return _definition.isAbstractType;
      }
    });
    Object.defineProperty(exports, "isWrappingType", {
      enumerable: true,
      get: function get() {
        return _definition.isWrappingType;
      }
    });
    Object.defineProperty(exports, "isNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.isNullableType;
      }
    });
    Object.defineProperty(exports, "isNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.isNamedType;
      }
    });
    Object.defineProperty(exports, "isRequiredArgument", {
      enumerable: true,
      get: function get() {
        return _definition.isRequiredArgument;
      }
    });
    Object.defineProperty(exports, "isRequiredInputField", {
      enumerable: true,
      get: function get() {
        return _definition.isRequiredInputField;
      }
    });
    Object.defineProperty(exports, "assertType", {
      enumerable: true,
      get: function get() {
        return _definition.assertType;
      }
    });
    Object.defineProperty(exports, "assertScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.assertScalarType;
      }
    });
    Object.defineProperty(exports, "assertObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.assertObjectType;
      }
    });
    Object.defineProperty(exports, "assertInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInterfaceType;
      }
    });
    Object.defineProperty(exports, "assertUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.assertUnionType;
      }
    });
    Object.defineProperty(exports, "assertEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.assertEnumType;
      }
    });
    Object.defineProperty(exports, "assertInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInputObjectType;
      }
    });
    Object.defineProperty(exports, "assertListType", {
      enumerable: true,
      get: function get() {
        return _definition.assertListType;
      }
    });
    Object.defineProperty(exports, "assertNonNullType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNonNullType;
      }
    });
    Object.defineProperty(exports, "assertInputType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInputType;
      }
    });
    Object.defineProperty(exports, "assertOutputType", {
      enumerable: true,
      get: function get() {
        return _definition.assertOutputType;
      }
    });
    Object.defineProperty(exports, "assertLeafType", {
      enumerable: true,
      get: function get() {
        return _definition.assertLeafType;
      }
    });
    Object.defineProperty(exports, "assertCompositeType", {
      enumerable: true,
      get: function get() {
        return _definition.assertCompositeType;
      }
    });
    Object.defineProperty(exports, "assertAbstractType", {
      enumerable: true,
      get: function get() {
        return _definition.assertAbstractType;
      }
    });
    Object.defineProperty(exports, "assertWrappingType", {
      enumerable: true,
      get: function get() {
        return _definition.assertWrappingType;
      }
    });
    Object.defineProperty(exports, "assertNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNullableType;
      }
    });
    Object.defineProperty(exports, "assertNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNamedType;
      }
    });
    Object.defineProperty(exports, "getNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.getNullableType;
      }
    });
    Object.defineProperty(exports, "getNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.getNamedType;
      }
    });
    Object.defineProperty(exports, "GraphQLScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports, "GraphQLObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports, "GraphQLUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports, "GraphQLEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports, "GraphQLInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLList", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLList;
      }
    });
    Object.defineProperty(exports, "GraphQLNonNull", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports, "isDirective", {
      enumerable: true,
      get: function get() {
        return _directives.isDirective;
      }
    });
    Object.defineProperty(exports, "assertDirective", {
      enumerable: true,
      get: function get() {
        return _directives.assertDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLDirective;
      }
    });
    Object.defineProperty(exports, "isSpecifiedDirective", {
      enumerable: true,
      get: function get() {
        return _directives.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports, "specifiedDirectives", {
      enumerable: true,
      get: function get() {
        return _directives.specifiedDirectives;
      }
    });
    Object.defineProperty(exports, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSkipDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function get() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports, "isSpecifiedScalarType", {
      enumerable: true,
      get: function get() {
        return _scalars.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports, "specifiedScalarTypes", {
      enumerable: true,
      get: function get() {
        return _scalars.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports, "GraphQLInt", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLInt;
      }
    });
    Object.defineProperty(exports, "GraphQLFloat", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLFloat;
      }
    });
    Object.defineProperty(exports, "GraphQLString", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLString;
      }
    });
    Object.defineProperty(exports, "GraphQLBoolean", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports, "GraphQLID", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLID;
      }
    });
    Object.defineProperty(exports, "isIntrospectionType", {
      enumerable: true,
      get: function get() {
        return _introspection.isIntrospectionType;
      }
    });
    Object.defineProperty(exports, "introspectionTypes", {
      enumerable: true,
      get: function get() {
        return _introspection.introspectionTypes;
      }
    });
    Object.defineProperty(exports, "__Schema", {
      enumerable: true,
      get: function get() {
        return _introspection.__Schema;
      }
    });
    Object.defineProperty(exports, "__Directive", {
      enumerable: true,
      get: function get() {
        return _introspection.__Directive;
      }
    });
    Object.defineProperty(exports, "__DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _introspection.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "__Type", {
      enumerable: true,
      get: function get() {
        return _introspection.__Type;
      }
    });
    Object.defineProperty(exports, "__Field", {
      enumerable: true,
      get: function get() {
        return _introspection.__Field;
      }
    });
    Object.defineProperty(exports, "__InputValue", {
      enumerable: true,
      get: function get() {
        return _introspection.__InputValue;
      }
    });
    Object.defineProperty(exports, "__EnumValue", {
      enumerable: true,
      get: function get() {
        return _introspection.__EnumValue;
      }
    });
    Object.defineProperty(exports, "__TypeKind", {
      enumerable: true,
      get: function get() {
        return _introspection.__TypeKind;
      }
    });
    Object.defineProperty(exports, "TypeKind", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeKind;
      }
    });
    Object.defineProperty(exports, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "validateSchema", {
      enumerable: true,
      get: function get() {
        return _validate.validateSchema;
      }
    });
    Object.defineProperty(exports, "assertValidSchema", {
      enumerable: true,
      get: function get() {
        return _validate.assertValidSchema;
      }
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
  }
});

// node_modules/graphql/language/index.js
var require_language = __commonJS({
  "node_modules/graphql/language/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Source", {
      enumerable: true,
      get: function get() {
        return _source.Source;
      }
    });
    Object.defineProperty(exports, "getLocation", {
      enumerable: true,
      get: function get() {
        return _location.getLocation;
      }
    });
    Object.defineProperty(exports, "printLocation", {
      enumerable: true,
      get: function get() {
        return _printLocation.printLocation;
      }
    });
    Object.defineProperty(exports, "printSourceLocation", {
      enumerable: true,
      get: function get() {
        return _printLocation.printSourceLocation;
      }
    });
    Object.defineProperty(exports, "Kind", {
      enumerable: true,
      get: function get() {
        return _kinds.Kind;
      }
    });
    Object.defineProperty(exports, "TokenKind", {
      enumerable: true,
      get: function get() {
        return _tokenKind.TokenKind;
      }
    });
    Object.defineProperty(exports, "Lexer", {
      enumerable: true,
      get: function get() {
        return _lexer.Lexer;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parser.parse;
      }
    });
    Object.defineProperty(exports, "parseValue", {
      enumerable: true,
      get: function get() {
        return _parser.parseValue;
      }
    });
    Object.defineProperty(exports, "parseType", {
      enumerable: true,
      get: function get() {
        return _parser.parseType;
      }
    });
    Object.defineProperty(exports, "print", {
      enumerable: true,
      get: function get() {
        return _printer.print;
      }
    });
    Object.defineProperty(exports, "visit", {
      enumerable: true,
      get: function get() {
        return _visitor.visit;
      }
    });
    Object.defineProperty(exports, "visitInParallel", {
      enumerable: true,
      get: function get() {
        return _visitor.visitInParallel;
      }
    });
    Object.defineProperty(exports, "getVisitFn", {
      enumerable: true,
      get: function get() {
        return _visitor.getVisitFn;
      }
    });
    Object.defineProperty(exports, "BREAK", {
      enumerable: true,
      get: function get() {
        return _visitor.BREAK;
      }
    });
    Object.defineProperty(exports, "Location", {
      enumerable: true,
      get: function get() {
        return _ast.Location;
      }
    });
    Object.defineProperty(exports, "Token", {
      enumerable: true,
      get: function get() {
        return _ast.Token;
      }
    });
    Object.defineProperty(exports, "isDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isSelectionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isSelectionNode;
      }
    });
    Object.defineProperty(exports, "isValueNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isValueNode;
      }
    });
    Object.defineProperty(exports, "isTypeNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports, "isTypeExtensionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports, "DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _directiveLocation.DirectiveLocation;
      }
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "node_modules/graphql/execution/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "responsePathAsArray", {
      enumerable: true,
      get: function get() {
        return _Path.pathToArray;
      }
    });
    Object.defineProperty(exports, "execute", {
      enumerable: true,
      get: function get() {
        return _execute.execute;
      }
    });
    Object.defineProperty(exports, "executeSync", {
      enumerable: true,
      get: function get() {
        return _execute.executeSync;
      }
    });
    Object.defineProperty(exports, "defaultFieldResolver", {
      enumerable: true,
      get: function get() {
        return _execute.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports, "defaultTypeResolver", {
      enumerable: true,
      get: function get() {
        return _execute.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports, "getDirectiveValues", {
      enumerable: true,
      get: function get() {
        return _values.getDirectiveValues;
      }
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _values = require_values();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAsyncIterable;
    var _symbols = require_symbols();
    function isAsyncIterable(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[_symbols.SYMBOL_ASYNC_ITERATOR]) === "function";
    }
  }
});

// node_modules/graphql/subscription/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/graphql/subscription/mapAsyncIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mapAsyncIterator;
    var _symbols = require_symbols();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function mapAsyncIterator(iterable, callback, rejectCallback) {
      var iteratorMethod = iterable[_symbols.SYMBOL_ASYNC_ITERATOR];
      var iterator = iteratorMethod.call(iterable);
      var $return;
      var abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = function abruptClose2(error) {
          var rethrow = function rethrow2() {
            return Promise.reject(error);
          };
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      var mapReject;
      if (rejectCallback) {
        var reject = rejectCallback;
        mapReject = function mapReject2(error) {
          return asyncMapValue(error, reject).then(iteratorResult, abruptClose);
        };
      }
      return _defineProperty({
        next: function next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return: function _return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
            value: void 0,
            done: true
          });
        },
        throw: function _throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        }
      }, _symbols.SYMBOL_ASYNC_ITERATOR, function() {
        return this;
      });
    }
    function asyncMapValue(value, callback) {
      return new Promise(function(resolve) {
        return resolve(callback(value));
      });
    }
    function iteratorResult(value) {
      return {
        value,
        done: false
      };
    }
  }
});

// node_modules/graphql/subscription/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/graphql/subscription/subscribe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subscribe = subscribe;
    exports.createSourceEventStream = createSourceEventStream;
    var _inspect = _interopRequireDefault(require_inspect());
    var _isAsyncIterable = _interopRequireDefault(require_isAsyncIterable());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _values = require_values();
    var _execute = require_execute();
    var _getOperationRootType = require_getOperationRootType();
    var _mapAsyncIterator = _interopRequireDefault(require_mapAsyncIterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
      return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({
        schema: argsOrSchema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        subscribeFieldResolver
      });
    }
    function reportGraphQLError(error) {
      if (error instanceof _GraphQLError.GraphQLError) {
        return {
          errors: [error]
        };
      }
      throw error;
    }
    function subscribeImpl(args) {
      var schema = args.schema, document = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, subscribeFieldResolver = args.subscribeFieldResolver;
      var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
      var mapSourceToResponse = function mapSourceToResponse2(payload) {
        return (0, _execute.execute)({
          schema,
          document,
          rootValue: payload,
          contextValue,
          variableValues,
          operationName,
          fieldResolver
        });
      };
      return sourcePromise.then(function(resultOrStream) {
        return (0, _isAsyncIterable.default)(resultOrStream) ? (0, _mapAsyncIterator.default)(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream;
      });
    }
    function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
      (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
      return new Promise(function(resolve) {
        var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);
        resolve(Array.isArray(exeContext) ? {
          errors: exeContext
        } : executeSubscription(exeContext));
      }).catch(reportGraphQLError);
    }
    function executeSubscription(exeContext) {
      var schema = exeContext.schema, operation = exeContext.operation, variableValues = exeContext.variableValues, rootValue = exeContext.rootValue;
      var type = (0, _getOperationRootType.getOperationRootType)(schema, operation);
      var fields = (0, _execute.collectFields)(exeContext, type, operation.selectionSet, /* @__PURE__ */ Object.create(null), /* @__PURE__ */ Object.create(null));
      var responseNames = Object.keys(fields);
      var responseName = responseNames[0];
      var fieldNodes = fields[responseName];
      var fieldNode = fieldNodes[0];
      var fieldName = fieldNode.name.value;
      var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldName);
      if (!fieldDef) {
        throw new _GraphQLError.GraphQLError('The subscription field "'.concat(fieldName, '" is not defined.'), fieldNodes);
      }
      var path = (0, _Path.addPath)(void 0, responseName, type.name);
      var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);
      return new Promise(function(resolveResult) {
        var _fieldDef$subscribe;
        var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
        var contextValue = exeContext.contextValue;
        var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;
        resolveResult(resolveFn(rootValue, args, contextValue, info));
      }).then(function(eventStream) {
        if (eventStream instanceof Error) {
          throw (0, _locatedError.locatedError)(eventStream, fieldNodes, (0, _Path.pathToArray)(path));
        }
        if (!(0, _isAsyncIterable.default)(eventStream)) {
          throw new Error("Subscription field must return Async Iterable. " + "Received: ".concat((0, _inspect.default)(eventStream), "."));
        }
        return eventStream;
      }, function(error) {
        throw (0, _locatedError.locatedError)(error, fieldNodes, (0, _Path.pathToArray)(path));
      });
    }
  }
});

// node_modules/graphql/subscription/index.js
var require_subscription = __commonJS({
  "node_modules/graphql/subscription/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "subscribe", {
      enumerable: true,
      get: function get() {
        return _subscribe.subscribe;
      }
    });
    Object.defineProperty(exports, "createSourceEventStream", {
      enumerable: true,
      get: function get() {
        return _subscribe.createSourceEventStream;
      }
    });
    var _subscribe = require_subscribe();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function NoDeprecatedCustomRule(context) {
      return {
        Field: function Field(node) {
          var fieldDef = context.getFieldDef();
          var deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            var parentType = context.getParentType();
            parentType != null || (0, _invariant.default)(0);
            context.reportError(new _GraphQLError.GraphQLError("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ").concat(deprecationReason), node));
          }
        },
        Argument: function Argument(node) {
          var argDef = context.getArgument();
          var deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            var directiveDef = context.getDirective();
            if (directiveDef != null) {
              context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
            } else {
              var parentType = context.getParentType();
              var fieldDef = context.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.default)(0);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(parentType.name, ".").concat(fieldDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
            }
          }
        },
        ObjectField: function ObjectField(node) {
          var inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            var inputFieldDef = inputObjectDef.getFields()[node.name.value];
            var deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context.reportError(new _GraphQLError.GraphQLError("The input field ".concat(inputObjectDef.name, ".").concat(inputFieldDef.name, " is deprecated. ").concat(deprecationReason), node));
            }
          }
        },
        EnumValue: function EnumValue(node) {
          var enumValueDef = context.getEnumValue();
          var deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            var enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
            enumTypeDef != null || (0, _invariant.default)(0);
            context.reportError(new _GraphQLError.GraphQLError('The enum value "'.concat(enumTypeDef.name, ".").concat(enumValueDef.name, '" is deprecated. ').concat(deprecationReason), node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context) {
      return {
        Field: function Field(node) {
          var type = (0, _definition.getNamedType)(context.getType());
          if (type && (0, _introspection.isIntrospectionType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError('GraphQL introspection has been disabled, but the requested query contained the field "'.concat(node.name.value, '".'), node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "node_modules/graphql/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.validate;
      }
    });
    Object.defineProperty(exports, "ValidationContext", {
      enumerable: true,
      get: function get() {
        return _ValidationContext.ValidationContext;
      }
    });
    Object.defineProperty(exports, "specifiedRules", {
      enumerable: true,
      get: function get() {
        return _specifiedRules.specifiedRules;
      }
    });
    Object.defineProperty(exports, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function get() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function get() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownDirectivesRule", {
      enumerable: true,
      get: function get() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function get() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function get() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function get() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function get() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function get() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function get() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports, "ScalarLeafsRule", {
      enumerable: true,
      get: function get() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function get() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function get() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function get() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function get() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function get() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function get() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function get() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function get() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/formatError.js
var require_formatError = __commonJS({
  "node_modules/graphql/error/formatError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatError = formatError;
    var _devAssert = _interopRequireDefault(require_devAssert());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function formatError(error) {
      var _error$message;
      error || (0, _devAssert.default)(0, "Received null or undefined error.");
      var message = (_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : "An unknown error occurred.";
      var locations = error.locations;
      var path = error.path;
      var extensions = error.extensions;
      return extensions ? {
        message,
        locations,
        path,
        extensions
      } : {
        message,
        locations,
        path
      };
    }
  }
});

// node_modules/graphql/error/index.js
var require_error = __commonJS({
  "node_modules/graphql/error/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GraphQLError", {
      enumerable: true,
      get: function get() {
        return _GraphQLError.GraphQLError;
      }
    });
    Object.defineProperty(exports, "printError", {
      enumerable: true,
      get: function get() {
        return _GraphQLError.printError;
      }
    });
    Object.defineProperty(exports, "syntaxError", {
      enumerable: true,
      get: function get() {
        return _syntaxError.syntaxError;
      }
    });
    Object.defineProperty(exports, "locatedError", {
      enumerable: true,
      get: function get() {
        return _locatedError.locatedError;
      }
    });
    Object.defineProperty(exports, "formatError", {
      enumerable: true,
      get: function get() {
        return _formatError.formatError;
      }
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
    var _formatError = require_formatError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getIntrospectionQuery = getIntrospectionQuery;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function getIntrospectionQuery(options) {
      var optionsWithDefault = _objectSpread({
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false
      }, options);
      var descriptions = optionsWithDefault.descriptions ? "description" : "";
      var specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByUrl" : "";
      var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      return "\n    query IntrospectionQuery {\n      __schema {\n        ".concat(schemaDescription, "\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ").concat(descriptions, "\n          ").concat(directiveIsRepeatable, "\n          locations\n          args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions, "\n      ").concat(specifiedByUrl, "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields").concat(inputDeprecation("(includeDeprecated: true)"), " {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions, "\n      type { ...TypeRef }\n      defaultValue\n      ").concat(inputDeprecation("isDeprecated"), "\n      ").concat(inputDeprecation("deprecationReason"), "\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
    }
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/graphql/utilities/getOperationAST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOperationAST = getOperationAST;
    var _kinds = require_kinds();
    function getOperationAST(documentAST, operationName) {
      var operation = null;
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var definition = _documentAST$definiti2[_i2];
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.introspectionFromSchema = introspectionFromSchema;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function introspectionFromSchema(schema, options) {
      var optionsWithDefaults = _objectSpread({
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true
      }, options);
      var document = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
      var result = (0, _execute.executeSync)({
        schema,
        document
      });
      !result.errors && result.data || (0, _invariant.default)(0);
      return result.data;
    }
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/graphql/utilities/buildClientSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildClientSchema = buildClientSchema;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _parser = require_parser();
    var _schema = require_schema();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _definition = require_definition();
    var _valueFromAST = require_valueFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function buildClientSchema(introspection, options) {
      (0, _isObjectLike.default)(introspection) && (0, _isObjectLike.default)(introspection.__schema) || (0, _devAssert.default)(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat((0, _inspect.default)(introspection), "."));
      var schemaIntrospection = introspection.__schema;
      var typeMap = (0, _keyValMap.default)(schemaIntrospection.types, function(typeIntrospection) {
        return typeIntrospection.name;
      }, function(typeIntrospection) {
        return buildType(typeIntrospection);
      });
      for (var _i2 = 0, _ref2 = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes); _i2 < _ref2.length; _i2++) {
        var stdType = _ref2[_i2];
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: (0, _objectValues.default)(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          var itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          var nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          var nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
        }
        return getNamedType(typeRef);
      }
      function getNamedType(typeRef) {
        var typeName = typeRef.name;
        if (!typeName) {
          throw new Error("Unknown type reference: ".concat((0, _inspect.default)(typeRef), "."));
        }
        var type = typeMap[typeName];
        if (!type) {
          throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
        }
        return type;
      }
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType(typeRef));
      }
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
      }
      function buildType(type) {
        if (type != null && type.name != null && type.kind != null) {
          switch (type.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type);
          }
        }
        var typeStr = (0, _inspect.default)(type);
        throw new Error("Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(typeStr, "."));
      }
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByUrl: scalarIntrospection.specifiedByUrl
        });
      }
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          var implementingIntrospectionStr = (0, _inspect.default)(implementingIntrospection);
          throw new Error("Introspection result missing interfaces: ".concat(implementingIntrospectionStr, "."));
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: function interfaces() {
            return buildImplementationsList(objectIntrospection);
          },
          fields: function fields() {
            return buildFieldDefMap(objectIntrospection);
          }
        });
      }
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: function interfaces() {
            return buildImplementationsList(interfaceIntrospection);
          },
          fields: function fields() {
            return buildFieldDefMap(interfaceIntrospection);
          }
        });
      }
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          var unionIntrospectionStr = (0, _inspect.default)(unionIntrospection);
          throw new Error("Introspection result missing possibleTypes: ".concat(unionIntrospectionStr, "."));
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: function types() {
            return unionIntrospection.possibleTypes.map(getObjectType);
          }
        });
      }
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          var enumIntrospectionStr = (0, _inspect.default)(enumIntrospection);
          throw new Error("Introspection result missing enumValues: ".concat(enumIntrospectionStr, "."));
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.default)(enumIntrospection.enumValues, function(valueIntrospection) {
            return valueIntrospection.name;
          }, function(valueIntrospection) {
            return {
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            };
          })
        });
      }
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          var inputObjectIntrospectionStr = (0, _inspect.default)(inputObjectIntrospection);
          throw new Error("Introspection result missing inputFields: ".concat(inputObjectIntrospectionStr, "."));
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: function fields() {
            return buildInputValueDefMap(inputObjectIntrospection.inputFields);
          }
        });
      }
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error("Introspection result missing fields: ".concat((0, _inspect.default)(typeIntrospection), "."));
        }
        return (0, _keyValMap.default)(typeIntrospection.fields, function(fieldIntrospection) {
          return fieldIntrospection.name;
        }, buildField);
      }
      function buildField(fieldIntrospection) {
        var type = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
          var typeStr = (0, _inspect.default)(type);
          throw new Error("Introspection must provide output type for fields, but received: ".concat(typeStr, "."));
        }
        if (!fieldIntrospection.args) {
          var fieldIntrospectionStr = (0, _inspect.default)(fieldIntrospection);
          throw new Error("Introspection result missing field args: ".concat(fieldIntrospectionStr, "."));
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.default)(inputValueIntrospections, function(inputValue) {
          return inputValue.name;
        }, buildInputValue);
      }
      function buildInputValue(inputValueIntrospection) {
        var type = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
          var typeStr = (0, _inspect.default)(type);
          throw new Error("Introspection must provide input type for arguments, but received: ".concat(typeStr, "."));
        }
        var defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : void 0;
        return {
          description: inputValueIntrospection.description,
          type,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          var directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
          throw new Error("Introspection result missing directive args: ".concat(directiveIntrospectionStr, "."));
        }
        if (!directiveIntrospection.locations) {
          var _directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
          throw new Error("Introspection result missing directive locations: ".concat(_directiveIntrospectionStr, "."));
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
    }
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/graphql/utilities/extendSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendSchema = extendSchema;
    exports.extendSchemaImpl = extendSchemaImpl;
    exports.getDescription = getDescription;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _mapValue = _interopRequireDefault(require_mapValue());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _blockString = require_blockString();
    var _predicates = require_predicates();
    var _validate = require_validate2();
    var _values = require_values();
    var _schema = require_schema();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    var _valueFromAST = require_valueFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function extendSchema(schema, documentAST, options) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      var schemaConfig = schema.toConfig();
      var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    function extendSchemaImpl(schemaConfig, documentAST, options) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      var typeDefs = [];
      var typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      var directiveDefs = [];
      var schemaDef;
      var schemaExtensions = [];
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var def = _documentAST$definiti2[_i2];
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          var extendedTypeName = def.name.value;
          var existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      var typeMap = /* @__PURE__ */ Object.create(null);
      for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {
        var existingType = _schemaConfig$types2[_i4];
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {
        var _stdTypeMap$name;
        var typeNode = typeDefs[_i6];
        var name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      var operationTypes = _objectSpread(_objectSpread({
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
      }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
      return _objectSpread(_objectSpread({
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
      }, operationTypes), {}, {
        types: (0, _objectValues.default)(typeMap),
        directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),
        extensions: void 0,
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      });
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceDirective(directive) {
        var config = directive.toConfig();
        return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
          args: (0, _mapValue.default)(config.args, extendArg)
        }));
      }
      function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
          return type;
        }
        if ((0, _definition.isScalarType)(type)) {
          return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return extendInputObjectType(type);
        }
        (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
      }
      function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, function(field) {
              return _objectSpread(_objectSpread({}, field), {}, {
                type: replaceType(field.type)
              });
            })), buildInputFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {
          values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        var specifiedByUrl = config.specifiedByUrl;
        for (var _i8 = 0; _i8 < extensions.length; _i8++) {
          var _getSpecifiedByUrl;
          var extensionNode = extensions[_i8];
          specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;
        }
        return new _definition.GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {
          specifiedByUrl,
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
          interfaces: function interfaces() {
            return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
          },
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {
          interfaces: function interfaces() {
            return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
          },
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {
          types: function types() {
            return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendField(field) {
        return _objectSpread(_objectSpread({}, field), {}, {
          type: replaceType(field.type),
          args: (0, _mapValue.default)(field.args, extendArg)
        });
      }
      function extendArg(arg) {
        return _objectSpread(_objectSpread({}, arg), {}, {
          type: replaceType(arg.type)
        });
      }
      function getOperationTypes(nodes) {
        var opTypes = {};
        for (var _i10 = 0; _i10 < nodes.length; _i10++) {
          var _node$operationTypes;
          var node = nodes[_i10];
          var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {
            var operationType = operationTypesNodes[_i12];
            opTypes[operationType.operation] = getNamedType(operationType.type);
          }
        }
        return opTypes;
      }
      function getNamedType(node) {
        var _stdTypeMap$name2;
        var name2 = node.name.value;
        var type = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
        if (type === void 0) {
          throw new Error('Unknown type: "'.concat(name2, '".'));
        }
        return type;
      }
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType(node);
      }
      function buildDirective(node) {
        var locations = node.locations.map(function(_ref) {
          var value = _ref.value;
          return value;
        });
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: getDescription(node, options),
          locations,
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      function buildFieldMap(nodes) {
        var fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (var _i14 = 0; _i14 < nodes.length; _i14++) {
          var _node$fields;
          var node = nodes[_i14];
          var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {
            var field = nodeFields[_i16];
            fieldConfigMap[field.name.value] = {
              type: getWrappedType(field.type),
              description: getDescription(field, options),
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      function buildArgumentMap(args) {
        var argsNodes = args !== null && args !== void 0 ? args : [];
        var argConfigMap = /* @__PURE__ */ Object.create(null);
        for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {
          var arg = argsNodes[_i18];
          var type = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type,
            description: getDescription(arg, options),
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      function buildInputFieldMap(nodes) {
        var inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (var _i20 = 0; _i20 < nodes.length; _i20++) {
          var _node$fields2;
          var node = nodes[_i20];
          var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
          for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {
            var field = fieldsNodes[_i22];
            var type = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type,
              description: getDescription(field, options),
              defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      function buildEnumValueMap(nodes) {
        var enumValueMap = /* @__PURE__ */ Object.create(null);
        for (var _i24 = 0; _i24 < nodes.length; _i24++) {
          var _node$values;
          var node = nodes[_i24];
          var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {
            var value = valuesNodes[_i26];
            enumValueMap[value.name.value] = {
              description: getDescription(value, options),
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      function buildInterfaces(nodes) {
        var interfaces = [];
        for (var _i28 = 0; _i28 < nodes.length; _i28++) {
          var _node$interfaces;
          var node = nodes[_i28];
          var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];
          for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {
            var type = interfacesNodes[_i30];
            interfaces.push(getNamedType(type));
          }
        }
        return interfaces;
      }
      function buildUnionTypes(nodes) {
        var types = [];
        for (var _i32 = 0; _i32 < nodes.length; _i32++) {
          var _node$types;
          var node = nodes[_i32];
          var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];
          for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {
            var type = typeNodes[_i34];
            types.push(getNamedType(type));
          }
        }
        return types;
      }
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        var name2 = astNode.name.value;
        var description = getDescription(astNode, options);
        var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var extensionASTNodes = extensionNodes;
            var allNodes = [astNode].concat(extensionASTNodes);
            return new _definition.GraphQLObjectType({
              name: name2,
              description,
              interfaces: function interfaces() {
                return buildInterfaces(allNodes);
              },
              fields: function fields() {
                return buildFieldMap(allNodes);
              },
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _extensionASTNodes = extensionNodes;
            var _allNodes = [astNode].concat(_extensionASTNodes);
            return new _definition.GraphQLInterfaceType({
              name: name2,
              description,
              interfaces: function interfaces() {
                return buildInterfaces(_allNodes);
              },
              fields: function fields() {
                return buildFieldMap(_allNodes);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _extensionASTNodes2 = extensionNodes;
            var _allNodes2 = [astNode].concat(_extensionASTNodes2);
            return new _definition.GraphQLEnumType({
              name: name2,
              description,
              values: buildEnumValueMap(_allNodes2),
              astNode,
              extensionASTNodes: _extensionASTNodes2
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _extensionASTNodes3 = extensionNodes;
            var _allNodes3 = [astNode].concat(_extensionASTNodes3);
            return new _definition.GraphQLUnionType({
              name: name2,
              description,
              types: function types() {
                return buildUnionTypes(_allNodes3);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes3
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _extensionASTNodes4 = extensionNodes;
            return new _definition.GraphQLScalarType({
              name: name2,
              description,
              specifiedByUrl: getSpecifiedByUrl(astNode),
              astNode,
              extensionASTNodes: _extensionASTNodes4
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _extensionASTNodes5 = extensionNodes;
            var _allNodes4 = [astNode].concat(_extensionASTNodes5);
            return new _definition.GraphQLInputObjectType({
              name: name2,
              description,
              fields: function fields() {
                return buildInputFieldMap(_allNodes4);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes5
            });
          }
        }
        (0, _invariant.default)(0, "Unexpected type definition node: " + (0, _inspect.default)(astNode));
      }
    }
    var stdTypeMap = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function(type) {
      return type.name;
    });
    function getDeprecationReason(node) {
      var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    function getSpecifiedByUrl(node) {
      var specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    function getDescription(node, options) {
      if (node.description) {
        return node.description.value;
      }
      if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {
        var rawValue = getLeadingCommentBlock(node);
        if (rawValue !== void 0) {
          return (0, _blockString.dedentBlockStringValue)("\n" + rawValue);
        }
      }
    }
    function getLeadingCommentBlock(node) {
      var loc = node.loc;
      if (!loc) {
        return;
      }
      var comments = [];
      var token = loc.startToken.prev;
      while (token != null && token.kind === _tokenKind.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        var value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/graphql/utilities/buildASTSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildASTSchema = buildASTSchema;
    exports.buildSchema = buildSchema;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _validate = require_validate2();
    var _schema = require_schema();
    var _directives = require_directives();
    var _extendSchema = require_extendSchema();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function buildASTSchema(documentAST, options) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      var emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: void 0,
        extensionASTNodes: [],
        assumeValid: false
      };
      var config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
      if (config.astNode == null) {
        for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
          var type = _config$types2[_i2];
          switch (type.name) {
            case "Query":
              config.query = type;
              break;
            case "Mutation":
              config.mutation = type;
              break;
            case "Subscription":
              config.subscription = type;
              break;
          }
        }
      }
      var directives = config.directives;
      var _loop = function _loop2(_i42) {
        var stdDirective = _directives.specifiedDirectives[_i42];
        if (directives.every(function(directive) {
          return directive.name !== stdDirective.name;
        })) {
          directives.push(stdDirective);
        }
      };
      for (var _i4 = 0; _i4 < _directives.specifiedDirectives.length; _i4++) {
        _loop(_i4);
      }
      return new _schema.GraphQLSchema(config);
    }
    function buildSchema(source, options) {
      var document = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,
        allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,
        experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables
      });
      return buildASTSchema(document, {
        commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
    }
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lexicographicSortSchema = lexicographicSortSchema;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _schema = require_schema();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function lexicographicSortSchema(schema) {
      var schemaConfig = schema.toConfig();
      var typeMap = (0, _keyValMap.default)(sortByName(schemaConfig.types), function(type) {
        return type.name;
      }, sortNamedType);
      return new _schema.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
        types: (0, _objectValues.default)(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      }));
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      function sortDirective(directive) {
        var config = directive.toConfig();
        return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
          locations: sortBy(config.locations, function(x) {
            return x;
          }),
          args: sortArgs(config.args)
        }));
      }
      function sortArgs(args) {
        return sortObjMap(args, function(arg) {
          return _objectSpread(_objectSpread({}, arg), {}, {
            type: replaceType(arg.type)
          });
        });
      }
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, function(field) {
          return _objectSpread(_objectSpread({}, field), {}, {
            type: replaceType(field.type),
            args: sortArgs(field.args)
          });
        });
      }
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, function(field) {
          return _objectSpread(_objectSpread({}, field), {}, {
            type: replaceType(field.type)
          });
        });
      }
      function sortTypes(arr) {
        return sortByName(arr).map(replaceNamedType);
      }
      function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
          return type;
        }
        if ((0, _definition.isObjectType)(type)) {
          var config = type.toConfig();
          return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
            interfaces: function interfaces() {
              return sortTypes(config.interfaces);
            },
            fields: function fields() {
              return sortFields(config.fields);
            }
          }));
        }
        if ((0, _definition.isInterfaceType)(type)) {
          var _config = type.toConfig();
          return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {
            interfaces: function interfaces() {
              return sortTypes(_config.interfaces);
            },
            fields: function fields() {
              return sortFields(_config.fields);
            }
          }));
        }
        if ((0, _definition.isUnionType)(type)) {
          var _config2 = type.toConfig();
          return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {
            types: function types() {
              return sortTypes(_config2.types);
            }
          }));
        }
        if ((0, _definition.isEnumType)(type)) {
          var _config3 = type.toConfig();
          return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {
            values: sortObjMap(_config3.values)
          }));
        }
        if ((0, _definition.isInputObjectType)(type)) {
          var _config4 = type.toConfig();
          return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {
            fields: function fields() {
              return sortInputFields(_config4.fields);
            }
          }));
        }
        (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
      }
    }
    function sortObjMap(map, sortValueFn) {
      var sortedMap = /* @__PURE__ */ Object.create(null);
      var sortedKeys = sortBy(Object.keys(map), function(x) {
        return x;
      });
      for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {
        var key = sortedKeys[_i2];
        var value = map[key];
        sortedMap[key] = sortValueFn ? sortValueFn(value) : value;
      }
      return sortedMap;
    }
    function sortByName(array) {
      return sortBy(array, function(obj) {
        return obj.name;
      });
    }
    function sortBy(array, mapToKey) {
      return array.slice().sort(function(obj1, obj2) {
        var key1 = mapToKey(obj1);
        var key2 = mapToKey(obj2);
        return (0, _naturalCompare.default)(key1, key2);
      });
    }
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/graphql/utilities/printSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printSchema = printSchema;
    exports.printIntrospectionSchema = printIntrospectionSchema;
    exports.printType = printType;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _printer = require_printer();
    var _blockString = require_blockString();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _directives = require_directives();
    var _definition = require_definition();
    var _astFromValue = require_astFromValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printSchema(schema, options) {
      return printFilteredSchema(schema, function(n) {
        return !(0, _directives.isSpecifiedDirective)(n);
      }, isDefinedType, options);
    }
    function printIntrospectionSchema(schema, options) {
      return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType, options);
    }
    function isDefinedType(type) {
      return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
    }
    function printFilteredSchema(schema, directiveFilter, typeFilter, options) {
      var directives = schema.getDirectives().filter(directiveFilter);
      var types = (0, _objectValues.default)(schema.getTypeMap()).filter(typeFilter);
      return [printSchemaDefinition(schema)].concat(directives.map(function(directive) {
        return printDirective(directive, options);
      }), types.map(function(type) {
        return printType(type, options);
      })).filter(Boolean).join("\n\n") + "\n";
    }
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      var operationTypes = [];
      var queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push("  query: ".concat(queryType.name));
      }
      var mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push("  mutation: ".concat(mutationType.name));
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push("  subscription: ".concat(subscriptionType.name));
      }
      return printDescription({}, schema) + "schema {\n".concat(operationTypes.join("\n"), "\n}");
    }
    function isSchemaOfCommonNames(schema) {
      var queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      var mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    function printType(type, options) {
      if ((0, _definition.isScalarType)(type)) {
        return printScalar(type, options);
      }
      if ((0, _definition.isObjectType)(type)) {
        return printObject(type, options);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type, options);
      }
      if ((0, _definition.isUnionType)(type)) {
        return printUnion(type, options);
      }
      if ((0, _definition.isEnumType)(type)) {
        return printEnum(type, options);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type, options);
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function printScalar(type, options) {
      return printDescription(options, type) + "scalar ".concat(type.name) + printSpecifiedByUrl(type);
    }
    function printImplementedInterfaces(type) {
      var interfaces = type.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map(function(i) {
        return i.name;
      }).join(" & ") : "";
    }
    function printObject(type, options) {
      return printDescription(options, type) + "type ".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);
    }
    function printInterface(type, options) {
      return printDescription(options, type) + "interface ".concat(type.name) + printImplementedInterfaces(type) + printFields(options, type);
    }
    function printUnion(type, options) {
      var types = type.getTypes();
      var possibleTypes = types.length ? " = " + types.join(" | ") : "";
      return printDescription(options, type) + "union " + type.name + possibleTypes;
    }
    function printEnum(type, options) {
      var values = type.getValues().map(function(value, i) {
        return printDescription(options, value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason);
      });
      return printDescription(options, type) + "enum ".concat(type.name) + printBlock(values);
    }
    function printInputObject(type, options) {
      var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
        return printDescription(options, f, "  ", !i) + "  " + printInputValue(f);
      });
      return printDescription(options, type) + "input ".concat(type.name) + printBlock(fields);
    }
    function printFields(options, type) {
      var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
        return printDescription(options, f, "  ", !i) + "  " + f.name + printArgs(options, f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason);
      });
      return printBlock(fields);
    }
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    function printArgs(options, args) {
      var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (args.length === 0) {
        return "";
      }
      if (args.every(function(arg) {
        return !arg.description;
      })) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(function(arg, i) {
        return printDescription(options, arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg);
      }).join("\n") + "\n" + indentation + ")";
    }
    function printInputValue(arg) {
      var defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
      var argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += " = ".concat((0, _printer.print)(defaultAST));
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    function printDirective(directive, options) {
      return printDescription(options, directive) + "directive @" + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      var reasonAST = (0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString);
      if (reasonAST && reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        return " @deprecated(reason: " + (0, _printer.print)(reasonAST) + ")";
      }
      return " @deprecated";
    }
    function printSpecifiedByUrl(scalar) {
      if (scalar.specifiedByUrl == null) {
        return "";
      }
      var url = scalar.specifiedByUrl;
      var urlAST = (0, _astFromValue.astFromValue)(url, _scalars.GraphQLString);
      urlAST || (0, _invariant.default)(0, "Unexpected null value returned from `astFromValue` for specifiedByUrl");
      return " @specifiedBy(url: " + (0, _printer.print)(urlAST) + ")";
    }
    function printDescription(options, def) {
      var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      var firstInBlock = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var description = def.description;
      if (description == null) {
        return "";
      }
      if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {
        return printDescriptionWithComments(description, indentation, firstInBlock);
      }
      var preferMultipleLines = description.length > 70;
      var blockString = (0, _blockString.printBlockString)(description, "", preferMultipleLines);
      var prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
    function printDescriptionWithComments(description, indentation, firstInBlock) {
      var prefix = indentation && !firstInBlock ? "\n" : "";
      var comment = description.split("\n").map(function(line) {
        return indentation + (line !== "" ? "# " + line : "#");
      }).join("\n");
      return prefix + comment + "\n";
    }
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/graphql/utilities/concatAST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatAST = concatAST;
    function concatAST(documents) {
      var definitions = [];
      for (var _i2 = 0; _i2 < documents.length; _i2++) {
        var doc = documents[_i2];
        definitions = definitions.concat(doc.definitions);
      }
      return {
        kind: "Document",
        definitions
      };
    }
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/graphql/utilities/separateOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      var operations = [];
      var depGraph = /* @__PURE__ */ Object.create(null);
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var definitionNode = _documentAST$definiti2[_i2];
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
            break;
        }
      }
      var separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      var _loop = function _loop2(_i42) {
        var operation = operations[_i42];
        var dependencies = /* @__PURE__ */ new Set();
        for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {
          var fragmentName = _collectDependencies2[_i6];
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        var operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(function(node) {
            return node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);
          })
        };
      };
      for (var _i4 = 0; _i4 < operations.length; _i4++) {
        _loop(_i4);
      }
      return separatedDocumentASTs;
    }
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        var immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {
            var toName = immediateDeps[_i8];
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    function collectDependencies(selectionSet) {
      var dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread: function FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stripIgnoredCharacters = stripIgnoredCharacters;
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _blockString = require_blockString();
    function stripIgnoredCharacters(source) {
      var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      var body = sourceObj.body;
      var lexer = new _lexer.Lexer(sourceObj);
      var strippedBody = "";
      var wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        var currentToken = lexer.token;
        var tokenKind = currentToken.kind;
        var isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        var tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += dedentBlockString(tokenBody);
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
    function dedentBlockString(blockStr) {
      var rawStr = blockStr.slice(3, -3);
      var body = (0, _blockString.dedentBlockStringValue)(rawStr);
      if ((0, _blockString.getBlockStringIndentation)(body) > 0) {
        body = "\n" + body;
      }
      var lastChar = body[body.length - 1];
      var hasTrailingQuote = lastChar === '"' && body.slice(-4) !== '\\"""';
      if (hasTrailingQuote || lastChar === "\\") {
        body += "\n";
      }
      return '"""' + body + '"""';
    }
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findBreakingChanges = findBreakingChanges;
    exports.findDangerousChanges = findDangerousChanges;
    exports.DangerousChangeType = exports.BreakingChangeType = void 0;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _scalars = require_scalars();
    var _definition = require_definition();
    var _astFromValue = require_astFromValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var BreakingChangeType = Object.freeze({
      TYPE_REMOVED: "TYPE_REMOVED",
      TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
      TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
      VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
      REQUIRED_INPUT_FIELD_ADDED: "REQUIRED_INPUT_FIELD_ADDED",
      IMPLEMENTED_INTERFACE_REMOVED: "IMPLEMENTED_INTERFACE_REMOVED",
      FIELD_REMOVED: "FIELD_REMOVED",
      FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
      REQUIRED_ARG_ADDED: "REQUIRED_ARG_ADDED",
      ARG_REMOVED: "ARG_REMOVED",
      ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
      DIRECTIVE_REMOVED: "DIRECTIVE_REMOVED",
      DIRECTIVE_ARG_REMOVED: "DIRECTIVE_ARG_REMOVED",
      REQUIRED_DIRECTIVE_ARG_ADDED: "REQUIRED_DIRECTIVE_ARG_ADDED",
      DIRECTIVE_REPEATABLE_REMOVED: "DIRECTIVE_REPEATABLE_REMOVED",
      DIRECTIVE_LOCATION_REMOVED: "DIRECTIVE_LOCATION_REMOVED"
    });
    exports.BreakingChangeType = BreakingChangeType;
    var DangerousChangeType = Object.freeze({
      VALUE_ADDED_TO_ENUM: "VALUE_ADDED_TO_ENUM",
      TYPE_ADDED_TO_UNION: "TYPE_ADDED_TO_UNION",
      OPTIONAL_INPUT_FIELD_ADDED: "OPTIONAL_INPUT_FIELD_ADDED",
      OPTIONAL_ARG_ADDED: "OPTIONAL_ARG_ADDED",
      IMPLEMENTED_INTERFACE_ADDED: "IMPLEMENTED_INTERFACE_ADDED",
      ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE"
    });
    exports.DangerousChangeType = DangerousChangeType;
    function findBreakingChanges(oldSchema, newSchema) {
      var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
        return change.type in BreakingChangeType;
      });
      return breakingChanges;
    }
    function findDangerousChanges(oldSchema, newSchema) {
      var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
        return change.type in DangerousChangeType;
      });
      return dangerousChanges;
    }
    function findSchemaChanges(oldSchema, newSchema) {
      return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));
    }
    function findDirectiveChanges(oldSchema, newSchema) {
      var schemaChanges = [];
      var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
      for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {
        var oldDirective = _directivesDiff$remov2[_i2];
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: "".concat(oldDirective.name, " was removed.")
        });
      }
      for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {
        var _ref2 = _directivesDiff$persi2[_i4];
        var _oldDirective = _ref2[0];
        var newDirective = _ref2[1];
        var argsDiff = diff(_oldDirective.args, newDirective.args);
        for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {
          var newArg = _argsDiff$added2[_i6];
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: "A required arg ".concat(newArg.name, " on directive ").concat(_oldDirective.name, " was added.")
            });
          }
        }
        for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {
          var oldArg = _argsDiff$removed2[_i8];
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: "".concat(oldArg.name, " was removed from ").concat(_oldDirective.name, ".")
          });
        }
        if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: "Repeatable flag was removed from ".concat(_oldDirective.name, ".")
          });
        }
        for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {
          var location = _oldDirective$locatio2[_i10];
          if (newDirective.locations.indexOf(location) === -1) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: "".concat(location, " was removed from ").concat(_oldDirective.name, ".")
            });
          }
        }
      }
      return schemaChanges;
    }
    function findTypeChanges(oldSchema, newSchema) {
      var schemaChanges = [];
      var typesDiff = diff((0, _objectValues.default)(oldSchema.getTypeMap()), (0, _objectValues.default)(newSchema.getTypeMap()));
      for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {
        var oldType = _typesDiff$removed2[_i12];
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? "Standard scalar ".concat(oldType.name, " was removed because it is not referenced anymore.") : "".concat(oldType.name, " was removed.")
        });
      }
      for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {
        var _ref4 = _typesDiff$persisted2[_i14];
        var _oldType = _ref4[0];
        var newType = _ref4[1];
        if ((0, _definition.isEnumType)(_oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));
        } else if ((0, _definition.isUnionType)(_oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));
        } else if ((0, _definition.isInputObjectType)(_oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));
        } else if ((0, _definition.isObjectType)(_oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
        } else if ((0, _definition.isInterfaceType)(_oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
        } else if (_oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: "".concat(_oldType.name, " changed from ") + "".concat(typeKindName(_oldType), " to ").concat(typeKindName(newType), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findInputObjectTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
      for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {
        var newField = _fieldsDiff$added2[_i16];
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: "A required field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: "An optional field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
          });
        }
      }
      for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {
        var oldField = _fieldsDiff$removed2[_i18];
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
        });
      }
      for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {
        var _ref6 = _fieldsDiff$persisted2[_i20];
        var _oldField = _ref6[0];
        var _newField = _ref6[1];
        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(_oldField.name, " changed type from ") + "".concat(String(_oldField.type), " to ").concat(String(_newField.type), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findUnionTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {
        var newPossibleType = _possibleTypesDiff$ad2[_i22];
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: "".concat(newPossibleType.name, " was added to union type ").concat(oldType.name, ".")
        });
      }
      for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {
        var oldPossibleType = _possibleTypesDiff$re2[_i24];
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: "".concat(oldPossibleType.name, " was removed from union type ").concat(oldType.name, ".")
        });
      }
      return schemaChanges;
    }
    function findEnumTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {
        var newValue = _valuesDiff$added2[_i26];
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: "".concat(newValue.name, " was added to enum type ").concat(oldType.name, ".")
        });
      }
      for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {
        var oldValue = _valuesDiff$removed2[_i28];
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: "".concat(oldValue.name, " was removed from enum type ").concat(oldType.name, ".")
        });
      }
      return schemaChanges;
    }
    function findImplementedInterfacesChanges(oldType, newType) {
      var schemaChanges = [];
      var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {
        var newInterface = _interfacesDiff$added2[_i30];
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: "".concat(newInterface.name, " added to interfaces implemented by ").concat(oldType.name, ".")
        });
      }
      for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {
        var oldInterface = _interfacesDiff$remov2[_i32];
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: "".concat(oldType.name, " no longer implements interface ").concat(oldInterface.name, ".")
        });
      }
      return schemaChanges;
    }
    function findFieldChanges(oldType, newType) {
      var schemaChanges = [];
      var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
      for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {
        var oldField = _fieldsDiff$removed4[_i34];
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
        });
      }
      for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {
        var _ref8 = _fieldsDiff$persisted4[_i36];
        var _oldField2 = _ref8[0];
        var newField = _ref8[1];
        schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));
        var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(_oldField2.name, " changed type from ") + "".concat(String(_oldField2.type), " to ").concat(String(newField.type), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findArgChanges(oldType, oldField, newField) {
      var schemaChanges = [];
      var argsDiff = diff(oldField.args, newField.args);
      for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {
        var oldArg = _argsDiff$removed4[_i38];
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(oldArg.name, " was removed.")
        });
      }
      for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {
        var _ref10 = _argsDiff$persisted2[_i40];
        var _oldArg = _ref10[0];
        var newArg = _ref10[1];
        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed type from ") + "".concat(String(_oldArg.type), " to ").concat(String(newArg.type), ".")
          });
        } else if (_oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " defaultValue was removed.")
            });
          } else {
            var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);
            var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed defaultValue from ").concat(oldValueStr, " to ").concat(newValueStr, ".")
              });
            }
          }
        }
      }
      for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {
        var _newArg = _argsDiff$added4[_i42];
        if ((0, _definition.isRequiredArgument)(_newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: "A required arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: "An optional arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
          });
        }
      }
      return schemaChanges;
    }
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    function typeKindName(type) {
      if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function stringifyValue(value, type) {
      var ast = (0, _astFromValue.astFromValue)(value, type);
      ast != null || (0, _invariant.default)(0);
      var sortedAST = (0, _visitor.visit)(ast, {
        ObjectValue: function ObjectValue(objectNode) {
          var fields = [].concat(objectNode.fields);
          fields.sort(function(fieldA, fieldB) {
            return (0, _naturalCompare.default)(fieldA.name.value, fieldB.name.value);
          });
          return _objectSpread(_objectSpread({}, objectNode), {}, {
            fields
          });
        }
      });
      return (0, _printer.print)(sortedAST);
    }
    function diff(oldArray, newArray) {
      var added = [];
      var removed = [];
      var persisted = [];
      var oldMap = (0, _keyMap.default)(oldArray, function(_ref11) {
        var name = _ref11.name;
        return name;
      });
      var newMap = (0, _keyMap.default)(newArray, function(_ref12) {
        var name = _ref12.name;
        return name;
      });
      for (var _i44 = 0; _i44 < oldArray.length; _i44++) {
        var oldItem = oldArray[_i44];
        var newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (var _i46 = 0; _i46 < newArray.length; _i46++) {
        var _newItem = newArray[_i46];
        if (oldMap[_newItem.name] === void 0) {
          added.push(_newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
  }
});

// node_modules/graphql/utilities/findDeprecatedUsages.js
var require_findDeprecatedUsages = __commonJS({
  "node_modules/graphql/utilities/findDeprecatedUsages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findDeprecatedUsages = findDeprecatedUsages;
    var _validate = require_validate2();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    function findDeprecatedUsages(schema, ast) {
      return (0, _validate.validate)(schema, ast, [_NoDeprecatedCustomRule.NoDeprecatedCustomRule]);
    }
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/graphql/utilities/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getIntrospectionQuery", {
      enumerable: true,
      get: function get() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports, "getOperationAST", {
      enumerable: true,
      get: function get() {
        return _getOperationAST.getOperationAST;
      }
    });
    Object.defineProperty(exports, "getOperationRootType", {
      enumerable: true,
      get: function get() {
        return _getOperationRootType.getOperationRootType;
      }
    });
    Object.defineProperty(exports, "introspectionFromSchema", {
      enumerable: true,
      get: function get() {
        return _introspectionFromSchema.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports, "buildClientSchema", {
      enumerable: true,
      get: function get() {
        return _buildClientSchema.buildClientSchema;
      }
    });
    Object.defineProperty(exports, "buildASTSchema", {
      enumerable: true,
      get: function get() {
        return _buildASTSchema.buildASTSchema;
      }
    });
    Object.defineProperty(exports, "buildSchema", {
      enumerable: true,
      get: function get() {
        return _buildASTSchema.buildSchema;
      }
    });
    Object.defineProperty(exports, "extendSchema", {
      enumerable: true,
      get: function get() {
        return _extendSchema.extendSchema;
      }
    });
    Object.defineProperty(exports, "getDescription", {
      enumerable: true,
      get: function get() {
        return _extendSchema.getDescription;
      }
    });
    Object.defineProperty(exports, "lexicographicSortSchema", {
      enumerable: true,
      get: function get() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports, "printSchema", {
      enumerable: true,
      get: function get() {
        return _printSchema.printSchema;
      }
    });
    Object.defineProperty(exports, "printType", {
      enumerable: true,
      get: function get() {
        return _printSchema.printType;
      }
    });
    Object.defineProperty(exports, "printIntrospectionSchema", {
      enumerable: true,
      get: function get() {
        return _printSchema.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports, "typeFromAST", {
      enumerable: true,
      get: function get() {
        return _typeFromAST.typeFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromAST", {
      enumerable: true,
      get: function get() {
        return _valueFromAST.valueFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromASTUntyped", {
      enumerable: true,
      get: function get() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports, "astFromValue", {
      enumerable: true,
      get: function get() {
        return _astFromValue.astFromValue;
      }
    });
    Object.defineProperty(exports, "TypeInfo", {
      enumerable: true,
      get: function get() {
        return _TypeInfo.TypeInfo;
      }
    });
    Object.defineProperty(exports, "visitWithTypeInfo", {
      enumerable: true,
      get: function get() {
        return _TypeInfo.visitWithTypeInfo;
      }
    });
    Object.defineProperty(exports, "coerceInputValue", {
      enumerable: true,
      get: function get() {
        return _coerceInputValue.coerceInputValue;
      }
    });
    Object.defineProperty(exports, "concatAST", {
      enumerable: true,
      get: function get() {
        return _concatAST.concatAST;
      }
    });
    Object.defineProperty(exports, "separateOperations", {
      enumerable: true,
      get: function get() {
        return _separateOperations.separateOperations;
      }
    });
    Object.defineProperty(exports, "stripIgnoredCharacters", {
      enumerable: true,
      get: function get() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports, "isEqualType", {
      enumerable: true,
      get: function get() {
        return _typeComparators.isEqualType;
      }
    });
    Object.defineProperty(exports, "isTypeSubTypeOf", {
      enumerable: true,
      get: function get() {
        return _typeComparators.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports, "doTypesOverlap", {
      enumerable: true,
      get: function get() {
        return _typeComparators.doTypesOverlap;
      }
    });
    Object.defineProperty(exports, "assertValidName", {
      enumerable: true,
      get: function get() {
        return _assertValidName.assertValidName;
      }
    });
    Object.defineProperty(exports, "isValidNameError", {
      enumerable: true,
      get: function get() {
        return _assertValidName.isValidNameError;
      }
    });
    Object.defineProperty(exports, "BreakingChangeType", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.BreakingChangeType;
      }
    });
    Object.defineProperty(exports, "DangerousChangeType", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.DangerousChangeType;
      }
    });
    Object.defineProperty(exports, "findBreakingChanges", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.findBreakingChanges;
      }
    });
    Object.defineProperty(exports, "findDangerousChanges", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.findDangerousChanges;
      }
    });
    Object.defineProperty(exports, "findDeprecatedUsages", {
      enumerable: true,
      get: function get() {
        return _findDeprecatedUsages.findDeprecatedUsages;
      }
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
    var _findDeprecatedUsages = require_findDeprecatedUsages();
  }
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "node_modules/graphql/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.version;
      }
    });
    Object.defineProperty(exports, "versionInfo", {
      enumerable: true,
      get: function get() {
        return _version.versionInfo;
      }
    });
    Object.defineProperty(exports, "graphql", {
      enumerable: true,
      get: function get() {
        return _graphql.graphql;
      }
    });
    Object.defineProperty(exports, "graphqlSync", {
      enumerable: true,
      get: function get() {
        return _graphql.graphqlSync;
      }
    });
    Object.defineProperty(exports, "GraphQLSchema", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSchema;
      }
    });
    Object.defineProperty(exports, "GraphQLDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLScalarType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports, "GraphQLObjectType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports, "GraphQLUnionType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports, "GraphQLEnumType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports, "GraphQLInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLList", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLList;
      }
    });
    Object.defineProperty(exports, "GraphQLNonNull", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports, "specifiedScalarTypes", {
      enumerable: true,
      get: function get() {
        return _index.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports, "GraphQLInt", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInt;
      }
    });
    Object.defineProperty(exports, "GraphQLFloat", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLFloat;
      }
    });
    Object.defineProperty(exports, "GraphQLString", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLString;
      }
    });
    Object.defineProperty(exports, "GraphQLBoolean", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports, "GraphQLID", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLID;
      }
    });
    Object.defineProperty(exports, "specifiedDirectives", {
      enumerable: true,
      get: function get() {
        return _index.specifiedDirectives;
      }
    });
    Object.defineProperty(exports, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSkipDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports, "TypeKind", {
      enumerable: true,
      get: function get() {
        return _index.TypeKind;
      }
    });
    Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function get() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports, "introspectionTypes", {
      enumerable: true,
      get: function get() {
        return _index.introspectionTypes;
      }
    });
    Object.defineProperty(exports, "__Schema", {
      enumerable: true,
      get: function get() {
        return _index.__Schema;
      }
    });
    Object.defineProperty(exports, "__Directive", {
      enumerable: true,
      get: function get() {
        return _index.__Directive;
      }
    });
    Object.defineProperty(exports, "__DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _index.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "__Type", {
      enumerable: true,
      get: function get() {
        return _index.__Type;
      }
    });
    Object.defineProperty(exports, "__Field", {
      enumerable: true,
      get: function get() {
        return _index.__Field;
      }
    });
    Object.defineProperty(exports, "__InputValue", {
      enumerable: true,
      get: function get() {
        return _index.__InputValue;
      }
    });
    Object.defineProperty(exports, "__EnumValue", {
      enumerable: true,
      get: function get() {
        return _index.__EnumValue;
      }
    });
    Object.defineProperty(exports, "__TypeKind", {
      enumerable: true,
      get: function get() {
        return _index.__TypeKind;
      }
    });
    Object.defineProperty(exports, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "isSchema", {
      enumerable: true,
      get: function get() {
        return _index.isSchema;
      }
    });
    Object.defineProperty(exports, "isDirective", {
      enumerable: true,
      get: function get() {
        return _index.isDirective;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function get() {
        return _index.isType;
      }
    });
    Object.defineProperty(exports, "isScalarType", {
      enumerable: true,
      get: function get() {
        return _index.isScalarType;
      }
    });
    Object.defineProperty(exports, "isObjectType", {
      enumerable: true,
      get: function get() {
        return _index.isObjectType;
      }
    });
    Object.defineProperty(exports, "isInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.isInterfaceType;
      }
    });
    Object.defineProperty(exports, "isUnionType", {
      enumerable: true,
      get: function get() {
        return _index.isUnionType;
      }
    });
    Object.defineProperty(exports, "isEnumType", {
      enumerable: true,
      get: function get() {
        return _index.isEnumType;
      }
    });
    Object.defineProperty(exports, "isInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.isInputObjectType;
      }
    });
    Object.defineProperty(exports, "isListType", {
      enumerable: true,
      get: function get() {
        return _index.isListType;
      }
    });
    Object.defineProperty(exports, "isNonNullType", {
      enumerable: true,
      get: function get() {
        return _index.isNonNullType;
      }
    });
    Object.defineProperty(exports, "isInputType", {
      enumerable: true,
      get: function get() {
        return _index.isInputType;
      }
    });
    Object.defineProperty(exports, "isOutputType", {
      enumerable: true,
      get: function get() {
        return _index.isOutputType;
      }
    });
    Object.defineProperty(exports, "isLeafType", {
      enumerable: true,
      get: function get() {
        return _index.isLeafType;
      }
    });
    Object.defineProperty(exports, "isCompositeType", {
      enumerable: true,
      get: function get() {
        return _index.isCompositeType;
      }
    });
    Object.defineProperty(exports, "isAbstractType", {
      enumerable: true,
      get: function get() {
        return _index.isAbstractType;
      }
    });
    Object.defineProperty(exports, "isWrappingType", {
      enumerable: true,
      get: function get() {
        return _index.isWrappingType;
      }
    });
    Object.defineProperty(exports, "isNullableType", {
      enumerable: true,
      get: function get() {
        return _index.isNullableType;
      }
    });
    Object.defineProperty(exports, "isNamedType", {
      enumerable: true,
      get: function get() {
        return _index.isNamedType;
      }
    });
    Object.defineProperty(exports, "isRequiredArgument", {
      enumerable: true,
      get: function get() {
        return _index.isRequiredArgument;
      }
    });
    Object.defineProperty(exports, "isRequiredInputField", {
      enumerable: true,
      get: function get() {
        return _index.isRequiredInputField;
      }
    });
    Object.defineProperty(exports, "isSpecifiedScalarType", {
      enumerable: true,
      get: function get() {
        return _index.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports, "isIntrospectionType", {
      enumerable: true,
      get: function get() {
        return _index.isIntrospectionType;
      }
    });
    Object.defineProperty(exports, "isSpecifiedDirective", {
      enumerable: true,
      get: function get() {
        return _index.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports, "assertSchema", {
      enumerable: true,
      get: function get() {
        return _index.assertSchema;
      }
    });
    Object.defineProperty(exports, "assertDirective", {
      enumerable: true,
      get: function get() {
        return _index.assertDirective;
      }
    });
    Object.defineProperty(exports, "assertType", {
      enumerable: true,
      get: function get() {
        return _index.assertType;
      }
    });
    Object.defineProperty(exports, "assertScalarType", {
      enumerable: true,
      get: function get() {
        return _index.assertScalarType;
      }
    });
    Object.defineProperty(exports, "assertObjectType", {
      enumerable: true,
      get: function get() {
        return _index.assertObjectType;
      }
    });
    Object.defineProperty(exports, "assertInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.assertInterfaceType;
      }
    });
    Object.defineProperty(exports, "assertUnionType", {
      enumerable: true,
      get: function get() {
        return _index.assertUnionType;
      }
    });
    Object.defineProperty(exports, "assertEnumType", {
      enumerable: true,
      get: function get() {
        return _index.assertEnumType;
      }
    });
    Object.defineProperty(exports, "assertInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.assertInputObjectType;
      }
    });
    Object.defineProperty(exports, "assertListType", {
      enumerable: true,
      get: function get() {
        return _index.assertListType;
      }
    });
    Object.defineProperty(exports, "assertNonNullType", {
      enumerable: true,
      get: function get() {
        return _index.assertNonNullType;
      }
    });
    Object.defineProperty(exports, "assertInputType", {
      enumerable: true,
      get: function get() {
        return _index.assertInputType;
      }
    });
    Object.defineProperty(exports, "assertOutputType", {
      enumerable: true,
      get: function get() {
        return _index.assertOutputType;
      }
    });
    Object.defineProperty(exports, "assertLeafType", {
      enumerable: true,
      get: function get() {
        return _index.assertLeafType;
      }
    });
    Object.defineProperty(exports, "assertCompositeType", {
      enumerable: true,
      get: function get() {
        return _index.assertCompositeType;
      }
    });
    Object.defineProperty(exports, "assertAbstractType", {
      enumerable: true,
      get: function get() {
        return _index.assertAbstractType;
      }
    });
    Object.defineProperty(exports, "assertWrappingType", {
      enumerable: true,
      get: function get() {
        return _index.assertWrappingType;
      }
    });
    Object.defineProperty(exports, "assertNullableType", {
      enumerable: true,
      get: function get() {
        return _index.assertNullableType;
      }
    });
    Object.defineProperty(exports, "assertNamedType", {
      enumerable: true,
      get: function get() {
        return _index.assertNamedType;
      }
    });
    Object.defineProperty(exports, "getNullableType", {
      enumerable: true,
      get: function get() {
        return _index.getNullableType;
      }
    });
    Object.defineProperty(exports, "getNamedType", {
      enumerable: true,
      get: function get() {
        return _index.getNamedType;
      }
    });
    Object.defineProperty(exports, "validateSchema", {
      enumerable: true,
      get: function get() {
        return _index.validateSchema;
      }
    });
    Object.defineProperty(exports, "assertValidSchema", {
      enumerable: true,
      get: function get() {
        return _index.assertValidSchema;
      }
    });
    Object.defineProperty(exports, "Token", {
      enumerable: true,
      get: function get() {
        return _index2.Token;
      }
    });
    Object.defineProperty(exports, "Source", {
      enumerable: true,
      get: function get() {
        return _index2.Source;
      }
    });
    Object.defineProperty(exports, "Location", {
      enumerable: true,
      get: function get() {
        return _index2.Location;
      }
    });
    Object.defineProperty(exports, "getLocation", {
      enumerable: true,
      get: function get() {
        return _index2.getLocation;
      }
    });
    Object.defineProperty(exports, "printLocation", {
      enumerable: true,
      get: function get() {
        return _index2.printLocation;
      }
    });
    Object.defineProperty(exports, "printSourceLocation", {
      enumerable: true,
      get: function get() {
        return _index2.printSourceLocation;
      }
    });
    Object.defineProperty(exports, "Lexer", {
      enumerable: true,
      get: function get() {
        return _index2.Lexer;
      }
    });
    Object.defineProperty(exports, "TokenKind", {
      enumerable: true,
      get: function get() {
        return _index2.TokenKind;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _index2.parse;
      }
    });
    Object.defineProperty(exports, "parseValue", {
      enumerable: true,
      get: function get() {
        return _index2.parseValue;
      }
    });
    Object.defineProperty(exports, "parseType", {
      enumerable: true,
      get: function get() {
        return _index2.parseType;
      }
    });
    Object.defineProperty(exports, "print", {
      enumerable: true,
      get: function get() {
        return _index2.print;
      }
    });
    Object.defineProperty(exports, "visit", {
      enumerable: true,
      get: function get() {
        return _index2.visit;
      }
    });
    Object.defineProperty(exports, "visitInParallel", {
      enumerable: true,
      get: function get() {
        return _index2.visitInParallel;
      }
    });
    Object.defineProperty(exports, "getVisitFn", {
      enumerable: true,
      get: function get() {
        return _index2.getVisitFn;
      }
    });
    Object.defineProperty(exports, "BREAK", {
      enumerable: true,
      get: function get() {
        return _index2.BREAK;
      }
    });
    Object.defineProperty(exports, "Kind", {
      enumerable: true,
      get: function get() {
        return _index2.Kind;
      }
    });
    Object.defineProperty(exports, "DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _index2.DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "isDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isSelectionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isSelectionNode;
      }
    });
    Object.defineProperty(exports, "isValueNode", {
      enumerable: true,
      get: function get() {
        return _index2.isValueNode;
      }
    });
    Object.defineProperty(exports, "isTypeNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports, "isTypeExtensionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports, "execute", {
      enumerable: true,
      get: function get() {
        return _index3.execute;
      }
    });
    Object.defineProperty(exports, "executeSync", {
      enumerable: true,
      get: function get() {
        return _index3.executeSync;
      }
    });
    Object.defineProperty(exports, "defaultFieldResolver", {
      enumerable: true,
      get: function get() {
        return _index3.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports, "defaultTypeResolver", {
      enumerable: true,
      get: function get() {
        return _index3.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports, "responsePathAsArray", {
      enumerable: true,
      get: function get() {
        return _index3.responsePathAsArray;
      }
    });
    Object.defineProperty(exports, "getDirectiveValues", {
      enumerable: true,
      get: function get() {
        return _index3.getDirectiveValues;
      }
    });
    Object.defineProperty(exports, "subscribe", {
      enumerable: true,
      get: function get() {
        return _index4.subscribe;
      }
    });
    Object.defineProperty(exports, "createSourceEventStream", {
      enumerable: true,
      get: function get() {
        return _index4.createSourceEventStream;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _index5.validate;
      }
    });
    Object.defineProperty(exports, "ValidationContext", {
      enumerable: true,
      get: function get() {
        return _index5.ValidationContext;
      }
    });
    Object.defineProperty(exports, "specifiedRules", {
      enumerable: true,
      get: function get() {
        return _index5.specifiedRules;
      }
    });
    Object.defineProperty(exports, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _index5.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownDirectivesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function get() {
        return _index5.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function get() {
        return _index5.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function get() {
        return _index5.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports, "ScalarLeafsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _index5.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function get() {
        return _index5.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function get() {
        return _index5.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports, "GraphQLError", {
      enumerable: true,
      get: function get() {
        return _index6.GraphQLError;
      }
    });
    Object.defineProperty(exports, "syntaxError", {
      enumerable: true,
      get: function get() {
        return _index6.syntaxError;
      }
    });
    Object.defineProperty(exports, "locatedError", {
      enumerable: true,
      get: function get() {
        return _index6.locatedError;
      }
    });
    Object.defineProperty(exports, "printError", {
      enumerable: true,
      get: function get() {
        return _index6.printError;
      }
    });
    Object.defineProperty(exports, "formatError", {
      enumerable: true,
      get: function get() {
        return _index6.formatError;
      }
    });
    Object.defineProperty(exports, "getIntrospectionQuery", {
      enumerable: true,
      get: function get() {
        return _index7.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports, "getOperationAST", {
      enumerable: true,
      get: function get() {
        return _index7.getOperationAST;
      }
    });
    Object.defineProperty(exports, "getOperationRootType", {
      enumerable: true,
      get: function get() {
        return _index7.getOperationRootType;
      }
    });
    Object.defineProperty(exports, "introspectionFromSchema", {
      enumerable: true,
      get: function get() {
        return _index7.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports, "buildClientSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildClientSchema;
      }
    });
    Object.defineProperty(exports, "buildASTSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildASTSchema;
      }
    });
    Object.defineProperty(exports, "buildSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildSchema;
      }
    });
    Object.defineProperty(exports, "getDescription", {
      enumerable: true,
      get: function get() {
        return _index7.getDescription;
      }
    });
    Object.defineProperty(exports, "extendSchema", {
      enumerable: true,
      get: function get() {
        return _index7.extendSchema;
      }
    });
    Object.defineProperty(exports, "lexicographicSortSchema", {
      enumerable: true,
      get: function get() {
        return _index7.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports, "printSchema", {
      enumerable: true,
      get: function get() {
        return _index7.printSchema;
      }
    });
    Object.defineProperty(exports, "printType", {
      enumerable: true,
      get: function get() {
        return _index7.printType;
      }
    });
    Object.defineProperty(exports, "printIntrospectionSchema", {
      enumerable: true,
      get: function get() {
        return _index7.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports, "typeFromAST", {
      enumerable: true,
      get: function get() {
        return _index7.typeFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromAST", {
      enumerable: true,
      get: function get() {
        return _index7.valueFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromASTUntyped", {
      enumerable: true,
      get: function get() {
        return _index7.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports, "astFromValue", {
      enumerable: true,
      get: function get() {
        return _index7.astFromValue;
      }
    });
    Object.defineProperty(exports, "TypeInfo", {
      enumerable: true,
      get: function get() {
        return _index7.TypeInfo;
      }
    });
    Object.defineProperty(exports, "visitWithTypeInfo", {
      enumerable: true,
      get: function get() {
        return _index7.visitWithTypeInfo;
      }
    });
    Object.defineProperty(exports, "coerceInputValue", {
      enumerable: true,
      get: function get() {
        return _index7.coerceInputValue;
      }
    });
    Object.defineProperty(exports, "concatAST", {
      enumerable: true,
      get: function get() {
        return _index7.concatAST;
      }
    });
    Object.defineProperty(exports, "separateOperations", {
      enumerable: true,
      get: function get() {
        return _index7.separateOperations;
      }
    });
    Object.defineProperty(exports, "stripIgnoredCharacters", {
      enumerable: true,
      get: function get() {
        return _index7.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports, "isEqualType", {
      enumerable: true,
      get: function get() {
        return _index7.isEqualType;
      }
    });
    Object.defineProperty(exports, "isTypeSubTypeOf", {
      enumerable: true,
      get: function get() {
        return _index7.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports, "doTypesOverlap", {
      enumerable: true,
      get: function get() {
        return _index7.doTypesOverlap;
      }
    });
    Object.defineProperty(exports, "assertValidName", {
      enumerable: true,
      get: function get() {
        return _index7.assertValidName;
      }
    });
    Object.defineProperty(exports, "isValidNameError", {
      enumerable: true,
      get: function get() {
        return _index7.isValidNameError;
      }
    });
    Object.defineProperty(exports, "BreakingChangeType", {
      enumerable: true,
      get: function get() {
        return _index7.BreakingChangeType;
      }
    });
    Object.defineProperty(exports, "DangerousChangeType", {
      enumerable: true,
      get: function get() {
        return _index7.DangerousChangeType;
      }
    });
    Object.defineProperty(exports, "findBreakingChanges", {
      enumerable: true,
      get: function get() {
        return _index7.findBreakingChanges;
      }
    });
    Object.defineProperty(exports, "findDangerousChanges", {
      enumerable: true,
      get: function get() {
        return _index7.findDangerousChanges;
      }
    });
    Object.defineProperty(exports, "findDeprecatedUsages", {
      enumerable: true,
      get: function get() {
        return _index7.findDeprecatedUsages;
      }
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_subscription();
    var _index5 = require_validation();
    var _index6 = require_error();
    var _index7 = require_utilities();
  }
});

// node_modules/@apollo/client/utilities/globals/globals.cjs.js
var require_globals_cjs = __commonJS({
  "node_modules/@apollo/client/utilities/globals/globals.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = require_invariant();
    var process$1 = require_main();
    var graphql = require_graphql2();
    function maybe(thunk) {
      try {
        return thunk();
      } catch (_a) {
      }
    }
    var global$1 = maybe(function() {
      return globalThis;
    }) || maybe(function() {
      return window;
    }) || maybe(function() {
      return self;
    }) || maybe(function() {
      return global;
    }) || maybe(function() {
      return Function("return this")();
    });
    var __ = "__";
    var GLOBAL_KEY = [__, __].join("DEV");
    function getDEV() {
      try {
        return Boolean(__DEV__);
      } catch (_a) {
        Object.defineProperty(global$1, GLOBAL_KEY, {
          value: maybe(function() {
            return process.env.NODE_ENV;
          }) !== "production",
          enumerable: false,
          configurable: true,
          writable: true
        });
        return global$1[GLOBAL_KEY];
      }
    }
    var DEV = getDEV();
    function removeTemporaryGlobals() {
      return typeof graphql.Source === "function" ? process$1.remove() : process$1.remove();
    }
    function checkDEV() {
      __DEV__ ? tsInvariant.invariant(typeof DEV === "boolean", DEV) : tsInvariant.invariant(typeof DEV === "boolean", 38);
    }
    removeTemporaryGlobals();
    checkDEV();
    exports.InvariantError = tsInvariant.InvariantError;
    exports.invariant = tsInvariant.invariant;
    exports.DEV = DEV;
    exports.checkDEV = checkDEV;
    exports.global = global$1;
    exports.maybe = maybe;
  }
});

// node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS({
  "node_modules/zen-observable/lib/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Observable = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var hasSymbols = function() {
      return typeof Symbol === "function";
    };
    var hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    var SymbolIterator = getSymbol("iterator");
    var SymbolObservable = getSymbol("observable");
    var SymbolSpecies = getSymbol("species");
    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null)
        return void 0;
      if (typeof value !== "function")
        throw new TypeError(value + " is not a function");
      return value;
    }
    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== void 0) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = void 0;
        }
      }
      return ctor !== void 0 ? ctor : Observable;
    }
    function isObservable(x) {
      return x instanceof Observable;
    }
    function hostReportError(e) {
      if (hostReportError.log) {
        hostReportError.log(e);
      } else {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function enqueue(fn) {
      Promise.resolve().then(function() {
        try {
          fn();
        } catch (e) {
          hostReportError(e);
        }
      });
    }
    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === void 0)
        return;
      subscription._cleanup = void 0;
      if (!cleanup) {
        return;
      }
      try {
        if (typeof cleanup === "function") {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, "unsubscribe");
          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e) {
        hostReportError(e);
      }
    }
    function closeSubscription(subscription) {
      subscription._observer = void 0;
      subscription._queue = void 0;
      subscription._state = "closed";
    }
    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = void 0;
      subscription._state = "ready";
      for (var i = 0; i < queue.length; ++i) {
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === "closed")
          break;
      }
    }
    function notifySubscription(subscription, type, value) {
      subscription._state = "running";
      var observer = subscription._observer;
      try {
        var m = getMethod(observer, type);
        switch (type) {
          case "next":
            if (m)
              m.call(observer, value);
            break;
          case "error":
            closeSubscription(subscription);
            if (m)
              m.call(observer, value);
            else
              throw value;
            break;
          case "complete":
            closeSubscription(subscription);
            if (m)
              m.call(observer);
            break;
        }
      } catch (e) {
        hostReportError(e);
      }
      if (subscription._state === "closed")
        cleanupSubscription(subscription);
      else if (subscription._state === "running")
        subscription._state = "ready";
    }
    function onNotify(subscription, type, value) {
      if (subscription._state === "closed")
        return;
      if (subscription._state === "buffering") {
        subscription._queue.push({
          type,
          value
        });
        return;
      }
      if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [{
          type,
          value
        }];
        enqueue(function() {
          return flushSubscription(subscription);
        });
        return;
      }
      notifySubscription(subscription, type, value);
    }
    var Subscription = /* @__PURE__ */ function() {
      function Subscription2(observer, subscriber) {
        _classCallCheck(this, Subscription2);
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing")
          this._state = "ready";
      }
      _createClass(Subscription2, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    var SubscriptionObserver = /* @__PURE__ */ function() {
      function SubscriptionObserver2(subscription) {
        _classCallCheck(this, SubscriptionObserver2);
        this._subscription = subscription;
      }
      _createClass(SubscriptionObserver2, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, "next", value);
        }
      }, {
        key: "error",
        value: function error(value) {
          onNotify(this._subscription, "error", value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, "complete");
        }
      }, {
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    var Observable = /* @__PURE__ */ function() {
      function Observable2(subscriber) {
        _classCallCheck(this, Observable2);
        if (!(this instanceof Observable2))
          throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function")
          throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      _createClass(Observable2, [{
        key: "subscribe",
        value: function subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            if (typeof fn !== "function") {
              reject(new TypeError(fn + " is not a function"));
              return;
            }
            function done() {
              subscription.unsubscribe();
              resolve();
            }
            var subscription = _this.subscribe({
              next: function(value) {
                try {
                  fn(value, done);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      }, {
        key: "map",
        value: function map(fn) {
          var _this2 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this2.subscribe({
              next: function(value) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this3 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this3.subscribe({
              next: function(value) {
                try {
                  if (!fn(value))
                    return;
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this4 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C(function(observer) {
            return _this4.subscribe({
              next: function(value) {
                var first = !hasValue;
                hasValue = true;
                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e) {
                    return observer.error(e);
                  }
                } else {
                  acc = value;
                }
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (!hasValue && !hasSeed)
                  return observer.error(new TypeError("Cannot reduce an empty sequence"));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat() {
          var _this5 = this;
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscription;
            var index = 0;
            function startNext(next) {
              subscription = next.subscribe({
                next: function(v) {
                  observer.next(v);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  if (index === sources.length) {
                    subscription = void 0;
                    observer.complete();
                  } else {
                    startNext(C.from(sources[index++]));
                  }
                }
              });
            }
            startNext(_this5);
            return function() {
              if (subscription) {
                subscription.unsubscribe();
                subscription = void 0;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
              next: function(value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                }
                var inner = C.from(value).subscribe({
                  next: function(value2) {
                    observer.next(value2);
                  },
                  error: function(e) {
                    observer.error(e);
                  },
                  complete: function() {
                    var i = subscriptions.indexOf(inner);
                    if (i >= 0)
                      subscriptions.splice(i, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                completeIfDone();
              }
            });
            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0)
                observer.complete();
            }
            return function() {
              subscriptions.forEach(function(s) {
                return s.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function() {
          return this;
        }
      }], [{
        key: "from",
        value: function from(x) {
          var C = typeof this === "function" ? this : Observable2;
          if (x == null)
            throw new TypeError(x + " is not an object");
          var method = getMethod(x, SymbolObservable);
          if (method) {
            var observable = method.call(x);
            if (Object(observable) !== observable)
              throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C)
              return observable;
            return new C(function(observer) {
              return observable.subscribe(observer);
            });
          }
          if (hasSymbol("iterator")) {
            method = getMethod(x, SymbolIterator);
            if (method) {
              return new C(function(observer) {
                enqueue(function() {
                  if (observer.closed)
                    return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var _item = _step.value;
                      observer.next(_item);
                      if (observer.closed)
                        return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  observer.complete();
                });
              });
            }
          }
          if (Array.isArray(x)) {
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed)
                  return;
                for (var i = 0; i < x.length; ++i) {
                  observer.next(x[i]);
                  if (observer.closed)
                    return;
                }
                observer.complete();
              });
            });
          }
          throw new TypeError(x + " is not observable");
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }
          var C = typeof this === "function" ? this : Observable2;
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed)
                return;
              for (var i = 0; i < items.length; ++i) {
                observer.next(items[i]);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable2;
    }();
    exports.Observable = Observable;
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// node_modules/zen-observable/index.js
var require_zen_observable = __commonJS({
  "node_modules/zen-observable/index.js"(exports, module2) {
    module2.exports = require_Observable().Observable;
  }
});

// node_modules/zen-observable-ts/index.js
var require_zen_observable_ts = __commonJS({
  "node_modules/zen-observable-ts/index.js"(exports) {
    exports.Observable = require_zen_observable();
  }
});

// node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          if (typeof _Symbol["for"] === "function") {
            result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          } else {
            result = _Symbol("https://github.com/benlesh/symbol-observable");
          }
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/symbol-observable/lib/index.js
var require_lib = __commonJS({
  "node_modules/symbol-observable/lib/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _ponyfill = require_ponyfill();
    var _ponyfill2 = _interopRequireDefault(_ponyfill);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var root;
    if (typeof self !== "undefined") {
      root = self;
    } else if (typeof window !== "undefined") {
      root = window;
    } else if (typeof global !== "undefined") {
      root = global;
    } else if (typeof module2 !== "undefined") {
      root = module2;
    } else {
      root = Function("return this")();
    }
    var result = (0, _ponyfill2["default"])(root);
    exports["default"] = result;
  }
});

// node_modules/@apollo/client/utilities/utilities.cjs.js
var require_utilities_cjs = __commonJS({
  "node_modules/@apollo/client/utilities/utilities.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var graphql = require_graphql2();
    var tslib = require_tslib();
    var zenObservableTs = require_zen_observable_ts();
    require_lib();
    function shouldInclude(_a, variables) {
      var directives = _a.directives;
      if (!directives || !directives.length) {
        return true;
      }
      return getInclusionDirectives(directives).every(function(_a2) {
        var directive = _a2.directive, ifArgument = _a2.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === "Variable") {
          evaledValue = variables && variables[ifArgument.value.name.value];
          __DEV__ ? globals.invariant(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.") : globals.invariant(evaledValue !== void 0, 39);
        } else {
          evaledValue = ifArgument.value.value;
        }
        return directive.name.value === "skip" ? !evaledValue : evaledValue;
      });
    }
    function getDirectiveNames(root) {
      var names = [];
      graphql.visit(root, {
        Directive: function(node) {
          names.push(node.name.value);
        }
      });
      return names;
    }
    function hasDirectives(names, root) {
      return getDirectiveNames(root).some(function(name) {
        return names.indexOf(name) > -1;
      });
    }
    function hasClientExports(document) {
      return document && hasDirectives(["client"], document) && hasDirectives(["export"], document);
    }
    function isInclusionDirective(_a) {
      var value = _a.name.value;
      return value === "skip" || value === "include";
    }
    function getInclusionDirectives(directives) {
      var result = [];
      if (directives && directives.length) {
        directives.forEach(function(directive) {
          if (!isInclusionDirective(directive))
            return;
          var directiveArguments = directive.arguments;
          var directiveName = directive.name.value;
          __DEV__ ? globals.invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.") : globals.invariant(directiveArguments && directiveArguments.length === 1, 40);
          var ifArgument = directiveArguments[0];
          __DEV__ ? globals.invariant(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @" + directiveName + " directive.") : globals.invariant(ifArgument.name && ifArgument.name.value === "if", 41);
          var ifValue = ifArgument.value;
          __DEV__ ? globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.") : globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 42);
          result.push({ directive, ifArgument });
        });
      }
      return result;
    }
    function getFragmentQueryDocument(document, fragmentName) {
      var actualFragmentName = fragmentName;
      var fragments = [];
      document.definitions.forEach(function(definition) {
        if (definition.kind === "OperationDefinition") {
          throw __DEV__ ? new globals.InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : "") + ". No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new globals.InvariantError(43);
        }
        if (definition.kind === "FragmentDefinition") {
          fragments.push(definition);
        }
      });
      if (typeof actualFragmentName === "undefined") {
        __DEV__ ? globals.invariant(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.") : globals.invariant(fragments.length === 1, 44);
        actualFragmentName = fragments[0].name.value;
      }
      var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([
        {
          kind: "OperationDefinition",
          operation: "query",
          selectionSet: {
            kind: "SelectionSet",
            selections: [
              {
                kind: "FragmentSpread",
                name: {
                  kind: "Name",
                  value: actualFragmentName
                }
              }
            ]
          }
        }
      ], document.definitions, true) });
      return query;
    }
    function createFragmentMap(fragments) {
      if (fragments === void 0) {
        fragments = [];
      }
      var symTable = {};
      fragments.forEach(function(fragment) {
        symTable[fragment.name.value] = fragment;
      });
      return symTable;
    }
    function getFragmentFromSelection(selection, fragmentMap) {
      switch (selection.kind) {
        case "InlineFragment":
          return selection;
        case "FragmentSpread": {
          var fragment = fragmentMap && fragmentMap[selection.name.value];
          __DEV__ ? globals.invariant(fragment, "No fragment named " + selection.name.value + ".") : globals.invariant(fragment, 45);
          return fragment;
        }
        default:
          return null;
      }
    }
    function isNonNullObject(obj) {
      return obj !== null && typeof obj === "object";
    }
    function makeReference(id) {
      return { __ref: String(id) };
    }
    function isReference(obj) {
      return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
    }
    function isDocumentNode(value) {
      return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
    }
    function isStringValue(value) {
      return value.kind === "StringValue";
    }
    function isBooleanValue(value) {
      return value.kind === "BooleanValue";
    }
    function isIntValue(value) {
      return value.kind === "IntValue";
    }
    function isFloatValue(value) {
      return value.kind === "FloatValue";
    }
    function isVariable(value) {
      return value.kind === "Variable";
    }
    function isObjectValue(value) {
      return value.kind === "ObjectValue";
    }
    function isListValue(value) {
      return value.kind === "ListValue";
    }
    function isEnumValue(value) {
      return value.kind === "EnumValue";
    }
    function isNullValue(value) {
      return value.kind === "NullValue";
    }
    function valueToObjectRepresentation(argObj, name, value, variables) {
      if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
      } else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
      } else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function(obj) {
          return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
      } else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
      } else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function(listValue) {
          var nestedArgArrayObj = {};
          valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
          return nestedArgArrayObj[name.value];
        });
      } else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
      } else if (isNullValue(value)) {
        argObj[name.value] = null;
      } else {
        throw __DEV__ ? new globals.InvariantError('The inline argument "' + name.value + '" of kind "' + value.kind + '"is not supported. Use variables instead of inline arguments to overcome this limitation.') : new globals.InvariantError(54);
      }
    }
    function storeKeyNameFromField(field, variables) {
      var directivesObj = null;
      if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function(directive) {
          directivesObj[directive.name.value] = {};
          if (directive.arguments) {
            directive.arguments.forEach(function(_a) {
              var name = _a.name, value = _a.value;
              return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
            });
          }
        });
      }
      var argObj = null;
      if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function(_a) {
          var name = _a.name, value = _a.value;
          return valueToObjectRepresentation(argObj, name, value, variables);
        });
      }
      return getStoreKeyName(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES = [
      "connection",
      "include",
      "skip",
      "client",
      "rest",
      "export"
    ];
    var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
      if (args && directives && directives["connection"] && directives["connection"]["key"]) {
        if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
          var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
          filterKeys.sort();
          var filteredArgs_1 = {};
          filterKeys.forEach(function(key) {
            filteredArgs_1[key] = args[key];
          });
          return directives["connection"]["key"] + "(" + stringify(filteredArgs_1) + ")";
        } else {
          return directives["connection"]["key"];
        }
      }
      var completeFieldName = fieldName;
      if (args) {
        var stringifiedArgs = stringify(args);
        completeFieldName += "(" + stringifiedArgs + ")";
      }
      if (directives) {
        Object.keys(directives).forEach(function(key) {
          if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
            return;
          if (directives[key] && Object.keys(directives[key]).length) {
            completeFieldName += "@" + key + "(" + stringify(directives[key]) + ")";
          } else {
            completeFieldName += "@" + key;
          }
        });
      }
      return completeFieldName;
    }, {
      setStringify: function(s) {
        var previous = stringify;
        stringify = s;
        return previous;
      }
    });
    var stringify = function defaultStringify(value) {
      return JSON.stringify(value, stringifyReplacer);
    };
    function stringifyReplacer(_key, value) {
      if (isNonNullObject(value) && !Array.isArray(value)) {
        value = Object.keys(value).sort().reduce(function(copy, key) {
          copy[key] = value[key];
          return copy;
        }, {});
      }
      return value;
    }
    function argumentsObjectFromField(field, variables) {
      if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function(_a) {
          var name = _a.name, value = _a.value;
          return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
      }
      return null;
    }
    function resultKeyNameFromField(field) {
      return field.alias ? field.alias.value : field.name.value;
    }
    function getTypenameFromResult(result, selectionSet, fragmentMap) {
      if (typeof result.__typename === "string") {
        return result.__typename;
      }
      for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (isField(selection)) {
          if (selection.name.value === "__typename") {
            return result[resultKeyNameFromField(selection)];
          }
        } else {
          var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
          if (typeof typename === "string") {
            return typename;
          }
        }
      }
    }
    function isField(selection) {
      return selection.kind === "Field";
    }
    function isInlineFragment(selection) {
      return selection.kind === "InlineFragment";
    }
    function checkDocument(doc) {
      __DEV__ ? globals.invariant(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : globals.invariant(doc && doc.kind === "Document", 46);
      var operations = doc.definitions.filter(function(d) {
        return d.kind !== "FragmentDefinition";
      }).map(function(definition) {
        if (definition.kind !== "OperationDefinition") {
          throw __DEV__ ? new globals.InvariantError('Schema type definitions not allowed in queries. Found: "' + definition.kind + '"') : new globals.InvariantError(47);
        }
        return definition;
      });
      __DEV__ ? globals.invariant(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations") : globals.invariant(operations.length <= 1, 48);
      return doc;
    }
    function getOperationDefinition(doc) {
      checkDocument(doc);
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      })[0];
    }
    function getOperationName(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition" && definition.name;
      }).map(function(x) {
        return x.name.value;
      })[0] || null;
    }
    function getFragmentDefinitions(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "FragmentDefinition";
      });
    }
    function getQueryDefinition(doc) {
      var queryDef = getOperationDefinition(doc);
      __DEV__ ? globals.invariant(queryDef && queryDef.operation === "query", "Must contain a query definition.") : globals.invariant(queryDef && queryDef.operation === "query", 49);
      return queryDef;
    }
    function getFragmentDefinition(doc) {
      __DEV__ ? globals.invariant(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : globals.invariant(doc.kind === "Document", 50);
      __DEV__ ? globals.invariant(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : globals.invariant(doc.definitions.length <= 1, 51);
      var fragmentDef = doc.definitions[0];
      __DEV__ ? globals.invariant(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : globals.invariant(fragmentDef.kind === "FragmentDefinition", 52);
      return fragmentDef;
    }
    function getMainDefinition(queryDoc) {
      checkDocument(queryDoc);
      var fragmentDefinition;
      for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === "OperationDefinition") {
          var operation = definition.operation;
          if (operation === "query" || operation === "mutation" || operation === "subscription") {
            return definition;
          }
        }
        if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
          fragmentDefinition = definition;
        }
      }
      if (fragmentDefinition) {
        return fragmentDefinition;
      }
      throw __DEV__ ? new globals.InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new globals.InvariantError(53);
    }
    function getDefaultValues(definition) {
      var defaultValues = /* @__PURE__ */ Object.create(null);
      var defs = definition && definition.variableDefinitions;
      if (defs && defs.length) {
        defs.forEach(function(def) {
          if (def.defaultValue) {
            valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
          }
        });
      }
      return defaultValues;
    }
    function filterInPlace(array, test, context) {
      var target = 0;
      array.forEach(function(elem, i) {
        if (test.call(this, elem, i, array)) {
          array[target++] = elem;
        }
      }, context);
      array.length = target;
      return array;
    }
    var TYPENAME_FIELD = {
      kind: "Field",
      name: {
        kind: "Name",
        value: "__typename"
      }
    };
    function isEmpty(op, fragments) {
      return op.selectionSet.selections.every(function(selection) {
        return selection.kind === "FragmentSpread" && isEmpty(fragments[selection.name.value], fragments);
      });
    }
    function nullIfDocIsEmpty(doc) {
      return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
    }
    function getDirectiveMatcher(directives) {
      return function directiveMatcher(directive) {
        return directives.some(function(dir) {
          return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
        });
      };
    }
    function removeDirectivesFromDocument(directives, doc) {
      var variablesInUse = /* @__PURE__ */ Object.create(null);
      var variablesToRemove = [];
      var fragmentSpreadsInUse = /* @__PURE__ */ Object.create(null);
      var fragmentSpreadsToRemove = [];
      var modifiedDoc = nullIfDocIsEmpty(graphql.visit(doc, {
        Variable: {
          enter: function(node, _key, parent) {
            if (parent.kind !== "VariableDefinition") {
              variablesInUse[node.name.value] = true;
            }
          }
        },
        Field: {
          enter: function(node) {
            if (directives && node.directives) {
              var shouldRemoveField = directives.some(function(directive) {
                return directive.remove;
              });
              if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
                if (node.arguments) {
                  node.arguments.forEach(function(arg) {
                    if (arg.value.kind === "Variable") {
                      variablesToRemove.push({
                        name: arg.value.name.value
                      });
                    }
                  });
                }
                if (node.selectionSet) {
                  getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag) {
                    fragmentSpreadsToRemove.push({
                      name: frag.name.value
                    });
                  });
                }
                return null;
              }
            }
          }
        },
        FragmentSpread: {
          enter: function(node) {
            fragmentSpreadsInUse[node.name.value] = true;
          }
        },
        Directive: {
          enter: function(node) {
            if (getDirectiveMatcher(directives)(node)) {
              return null;
            }
          }
        }
      }));
      if (modifiedDoc && filterInPlace(variablesToRemove, function(v) {
        return !!v.name && !variablesInUse[v.name];
      }).length) {
        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
      }
      if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
        return !!fs.name && !fragmentSpreadsInUse[fs.name];
      }).length) {
        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
      }
      return modifiedDoc;
    }
    var addTypenameToDocument = Object.assign(function(doc) {
      return graphql.visit(checkDocument(doc), {
        SelectionSet: {
          enter: function(node, _key, parent) {
            if (parent && parent.kind === "OperationDefinition") {
              return;
            }
            var selections = node.selections;
            if (!selections) {
              return;
            }
            var skip = selections.some(function(selection) {
              return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
            });
            if (skip) {
              return;
            }
            var field = parent;
            if (isField(field) && field.directives && field.directives.some(function(d) {
              return d.name.value === "export";
            })) {
              return;
            }
            return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
          }
        }
      });
    }, {
      added: function(field) {
        return field === TYPENAME_FIELD;
      }
    });
    var connectionRemoveConfig = {
      test: function(directive) {
        var willRemove = directive.name.value === "connection";
        if (willRemove) {
          if (!directive.arguments || !directive.arguments.some(function(arg) {
            return arg.name.value === "key";
          })) {
            __DEV__ && globals.invariant.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
          }
        }
        return willRemove;
      }
    };
    function removeConnectionDirectiveFromDocument(doc) {
      return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
    }
    function getArgumentMatcher(config) {
      return function argumentMatcher(argument) {
        return config.some(function(aConfig) {
          return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
        });
      };
    }
    function removeArgumentsFromDocument(config, doc) {
      var argMatcher = getArgumentMatcher(config);
      return nullIfDocIsEmpty(graphql.visit(doc, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
              return !config.some(function(arg) {
                return arg.name === varDef.variable.name.value;
              });
            }) : [] });
          }
        },
        Field: {
          enter: function(node) {
            var shouldRemoveField = config.some(function(argConfig) {
              return argConfig.remove;
            });
            if (shouldRemoveField) {
              var argMatchCount_1 = 0;
              if (node.arguments) {
                node.arguments.forEach(function(arg) {
                  if (argMatcher(arg)) {
                    argMatchCount_1 += 1;
                  }
                });
              }
              if (argMatchCount_1 === 1) {
                return null;
              }
            }
          }
        },
        Argument: {
          enter: function(node) {
            if (argMatcher(node)) {
              return null;
            }
          }
        }
      }));
    }
    function removeFragmentSpreadFromDocument(config, doc) {
      function enter(node) {
        if (config.some(function(def) {
          return def.name === node.name.value;
        })) {
          return null;
        }
      }
      return nullIfDocIsEmpty(graphql.visit(doc, {
        FragmentSpread: { enter },
        FragmentDefinition: { enter }
      }));
    }
    function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
      var allFragments = [];
      selectionSet.selections.forEach(function(selection) {
        if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
          getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
            return allFragments.push(frag);
          });
        } else if (selection.kind === "FragmentSpread") {
          allFragments.push(selection);
        }
      });
      return allFragments;
    }
    function buildQueryFromSelectionSet(document) {
      var definition = getMainDefinition(document);
      var definitionOperation = definition.operation;
      if (definitionOperation === "query") {
        return document;
      }
      var modifiedDoc = graphql.visit(document, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { operation: "query" });
          }
        }
      });
      return modifiedDoc;
    }
    function removeClientSetsFromDocument(document) {
      checkDocument(document);
      var modifiedDoc = removeDirectivesFromDocument([
        {
          test: function(directive) {
            return directive.name.value === "client";
          },
          remove: true
        }
      ], document);
      if (modifiedDoc) {
        modifiedDoc = graphql.visit(modifiedDoc, {
          FragmentDefinition: {
            enter: function(node) {
              if (node.selectionSet) {
                var isTypenameOnly = node.selectionSet.selections.every(function(selection) {
                  return isField(selection) && selection.name.value === "__typename";
                });
                if (isTypenameOnly) {
                  return null;
                }
              }
            }
          }
        });
      }
      return modifiedDoc;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function mergeDeep() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return mergeDeepArray(sources);
    }
    function mergeDeepArray(sources) {
      var target = sources[0] || {};
      var count = sources.length;
      if (count > 1) {
        var merger = new DeepMerger();
        for (var i = 1; i < count; ++i) {
          target = merger.merge(target, sources[i]);
        }
      }
      return target;
    }
    var defaultReconciler = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger = function() {
      function DeepMerger2(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = /* @__PURE__ */ new Set();
      }
      DeepMerger2.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source) && isNonNullObject(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result = _this.reconciler.apply(_this, tslib.__spreadArray([target, source, sourceKey], context, false));
                if (result !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger2.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject(value) && !this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
        return value;
      };
      return DeepMerger2;
    }();
    function concatPagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming) {
          return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
        }
      };
    }
    function offsetLimitPagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming, _a) {
          var args = _a.args;
          var merged = existing ? existing.slice(0) : [];
          if (args) {
            var _b = args.offset, offset = _b === void 0 ? 0 : _b;
            for (var i = 0; i < incoming.length; ++i) {
              merged[offset + i] = incoming[i];
            }
          } else {
            merged.push.apply(merged, incoming);
          }
          return merged;
        }
      };
    }
    function relayStylePagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        read: function(existing, _a) {
          var canRead = _a.canRead, readField = _a.readField;
          if (!existing)
            return existing;
          var edges = [];
          var firstEdgeCursor = "";
          var lastEdgeCursor = "";
          existing.edges.forEach(function(edge) {
            if (canRead(readField("node", edge))) {
              edges.push(edge);
              if (edge.cursor) {
                firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                lastEdgeCursor = edge.cursor || lastEdgeCursor;
              }
            }
          });
          var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
          return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });
        },
        merge: function(existing, incoming, _a) {
          var args = _a.args, isReference2 = _a.isReference, readField = _a.readField;
          if (!existing) {
            existing = makeEmptyData();
          }
          if (!incoming) {
            return existing;
          }
          var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
            if (isReference2(edge = tslib.__assign({}, edge))) {
              edge.cursor = readField("cursor", edge);
            }
            return edge;
          }) : [];
          if (incoming.pageInfo) {
            var pageInfo_1 = incoming.pageInfo;
            var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
            var firstEdge = incomingEdges[0];
            var lastEdge = incomingEdges[incomingEdges.length - 1];
            if (firstEdge && startCursor) {
              firstEdge.cursor = startCursor;
            }
            if (lastEdge && endCursor) {
              lastEdge.cursor = endCursor;
            }
            var firstCursor = firstEdge && firstEdge.cursor;
            if (firstCursor && !startCursor) {
              incoming = mergeDeep(incoming, {
                pageInfo: {
                  startCursor: firstCursor
                }
              });
            }
            var lastCursor = lastEdge && lastEdge.cursor;
            if (lastCursor && !endCursor) {
              incoming = mergeDeep(incoming, {
                pageInfo: {
                  endCursor: lastCursor
                }
              });
            }
          }
          var prefix = existing.edges;
          var suffix = [];
          if (args && args.after) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.after;
            });
            if (index >= 0) {
              prefix = prefix.slice(0, index + 1);
            }
          } else if (args && args.before) {
            var index = prefix.findIndex(function(edge) {
              return edge.cursor === args.before;
            });
            suffix = index < 0 ? prefix : prefix.slice(index);
            prefix = [];
          } else if (incoming.edges) {
            prefix = [];
          }
          var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
          var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
          if (incoming.pageInfo) {
            var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
            Object.assign(pageInfo, extras);
            if (!prefix.length) {
              if (hasPreviousPage !== void 0)
                pageInfo.hasPreviousPage = hasPreviousPage;
              if (startCursor !== void 0)
                pageInfo.startCursor = startCursor;
            }
            if (!suffix.length) {
              if (hasNextPage !== void 0)
                pageInfo.hasNextPage = hasNextPage;
              if (endCursor !== void 0)
                pageInfo.endCursor = endCursor;
            }
          }
          return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
        }
      };
    }
    var getExtras = function(obj) {
      return tslib.__rest(obj, notExtras);
    };
    var notExtras = ["edges", "pageInfo"];
    function makeEmptyData() {
      return {
        edges: [],
        pageInfo: {
          hasPreviousPage: false,
          hasNextPage: true,
          startCursor: "",
          endCursor: ""
        }
      };
    }
    var toString = Object.prototype.toString;
    function cloneDeep(value) {
      return cloneDeepHelper(value);
    }
    function cloneDeepHelper(val, seen) {
      switch (toString.call(val)) {
        case "[object Array]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_1 = val.slice(0);
          seen.set(val, copy_1);
          copy_1.forEach(function(child, i) {
            copy_1[i] = cloneDeepHelper(child, seen);
          });
          return copy_1;
        }
        case "[object Object]": {
          seen = seen || /* @__PURE__ */ new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_2 = Object.create(Object.getPrototypeOf(val));
          seen.set(val, copy_2);
          Object.keys(val).forEach(function(key) {
            copy_2[key] = cloneDeepHelper(val[key], seen);
          });
          return copy_2;
        }
        default:
          return val;
      }
    }
    function deepFreeze(value) {
      var workSet = /* @__PURE__ */ new Set([value]);
      workSet.forEach(function(obj) {
        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
          Object.getOwnPropertyNames(obj).forEach(function(name) {
            if (isNonNullObject(obj[name]))
              workSet.add(obj[name]);
          });
        }
      });
      return value;
    }
    function shallowFreeze(obj) {
      if (__DEV__ && !Object.isFrozen(obj)) {
        try {
          Object.freeze(obj);
        } catch (e) {
          if (e instanceof TypeError)
            return null;
          throw e;
        }
      }
      return obj;
    }
    function maybeDeepFreeze(obj) {
      if (__DEV__) {
        deepFreeze(obj);
      }
      return obj;
    }
    function iterateObserversSafely(observers, method, argument) {
      var observersWithMethod = [];
      observers.forEach(function(obs) {
        return obs[method] && observersWithMethod.push(obs);
      });
      observersWithMethod.forEach(function(obs) {
        return obs[method](argument);
      });
    }
    function asyncMap(observable, mapFn, catchFn) {
      return new zenObservableTs.Observable(function(observer) {
        var next = observer.next, error = observer.error, complete = observer.complete;
        var activeCallbackCount = 0;
        var completed = false;
        var promiseQueue = {
          then: function(callback) {
            return new Promise(function(resolve) {
              return resolve(callback());
            });
          }
        };
        function makeCallback(examiner, delegate) {
          if (examiner) {
            return function(arg) {
              ++activeCallbackCount;
              var both = function() {
                return examiner(arg);
              };
              promiseQueue = promiseQueue.then(both, both).then(function(result) {
                --activeCallbackCount;
                next && next.call(observer, result);
                if (completed) {
                  handler.complete();
                }
              }, function(error2) {
                --activeCallbackCount;
                throw error2;
              }).catch(function(caught) {
                error && error.call(observer, caught);
              });
            };
          } else {
            return function(arg) {
              return delegate && delegate.call(observer, arg);
            };
          }
        }
        var handler = {
          next: makeCallback(mapFn, next),
          error: makeCallback(catchFn, error),
          complete: function() {
            completed = true;
            if (!activeCallbackCount) {
              complete && complete.call(observer);
            }
          }
        };
        var sub = observable.subscribe(handler);
        return function() {
          return sub.unsubscribe();
        };
      });
    }
    var canUseWeakMap = typeof WeakMap === "function" && !(typeof navigator === "object" && navigator.product === "ReactNative");
    var canUseWeakSet = typeof WeakSet === "function";
    var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
    function fixObservableSubclass(subclass) {
      function set(key) {
        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
      }
      if (canUseSymbol && Symbol.species) {
        set(Symbol.species);
      }
      set("@@species");
      return subclass;
    }
    function isPromiseLike(value) {
      return value && typeof value.then === "function";
    }
    var Concast = function(_super) {
      tslib.__extends(Concast2, _super);
      function Concast2(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.addCount = 0;
        _this.promise = new Promise(function(resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result) {
            if (_this.sub !== null) {
              _this.latest = ["next", result];
              iterateObserversSafely(_this.observers, "next", result);
            }
          },
          error: function(error) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error];
              _this.reject(error);
              iterateObserversSafely(_this.observers, "error", error);
            }
          },
          complete: function() {
            if (_this.sub !== null) {
              var value = _this.sources.shift();
              if (!value) {
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                iterateObserversSafely(_this.observers, "complete");
              } else if (isPromiseLike(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                });
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.complete();
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new zenObservableTs.Observable(sources)];
        }
        if (isPromiseLike(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast2.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast2.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast2.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
          ++this.addCount;
        }
      };
      Concast2.prototype.removeObserver = function(observer, quietly) {
        if (this.observers.delete(observer) && --this.addCount < 1 && !quietly) {
          this.handlers.error(new Error("Observable cancelled prematurely"));
        }
      };
      Concast2.prototype.cleanup = function(callback) {
        var _this = this;
        var called = false;
        var once = function() {
          if (!called) {
            called = true;
            _this.observers.delete(observer);
            callback();
          }
        };
        var observer = {
          next: once,
          error: once,
          complete: once
        };
        var count = this.addCount;
        this.addObserver(observer);
        this.addCount = count;
      };
      return Concast2;
    }(zenObservableTs.Observable);
    fixObservableSubclass(Concast);
    function isNonEmptyArray(value) {
      return Array.isArray(value) && value.length > 0;
    }
    function graphQLResultHasError(result) {
      return result.errors && result.errors.length > 0 || false;
    }
    function compact() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result = /* @__PURE__ */ Object.create(null);
      objects.forEach(function(obj) {
        if (!obj)
          return;
        Object.keys(obj).forEach(function(key) {
          var value = obj[key];
          if (value !== void 0) {
            result[key] = value;
          }
        });
      });
      return result;
    }
    var prefixCounts = /* @__PURE__ */ new Map();
    function makeUniqueId(prefix) {
      var count = prefixCounts.get(prefix) || 1;
      prefixCounts.set(prefix, count + 1);
      return prefix + ":" + count + ":" + Math.random().toString(36).slice(2);
    }
    function stringifyForDisplay(value) {
      var undefId = makeUniqueId("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }).split(JSON.stringify(undefId)).join("<undefined>");
    }
    exports.DEV = globals.DEV;
    exports.maybe = globals.maybe;
    exports.Observable = zenObservableTs.Observable;
    exports.Concast = Concast;
    exports.DeepMerger = DeepMerger;
    exports.addTypenameToDocument = addTypenameToDocument;
    exports.argumentsObjectFromField = argumentsObjectFromField;
    exports.asyncMap = asyncMap;
    exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
    exports.canUseSymbol = canUseSymbol;
    exports.canUseWeakMap = canUseWeakMap;
    exports.canUseWeakSet = canUseWeakSet;
    exports.checkDocument = checkDocument;
    exports.cloneDeep = cloneDeep;
    exports.compact = compact;
    exports.concatPagination = concatPagination;
    exports.createFragmentMap = createFragmentMap;
    exports.fixObservableSubclass = fixObservableSubclass;
    exports.getDefaultValues = getDefaultValues;
    exports.getDirectiveNames = getDirectiveNames;
    exports.getFragmentDefinition = getFragmentDefinition;
    exports.getFragmentDefinitions = getFragmentDefinitions;
    exports.getFragmentFromSelection = getFragmentFromSelection;
    exports.getFragmentQueryDocument = getFragmentQueryDocument;
    exports.getInclusionDirectives = getInclusionDirectives;
    exports.getMainDefinition = getMainDefinition;
    exports.getOperationDefinition = getOperationDefinition;
    exports.getOperationName = getOperationName;
    exports.getQueryDefinition = getQueryDefinition;
    exports.getStoreKeyName = getStoreKeyName;
    exports.getTypenameFromResult = getTypenameFromResult;
    exports.graphQLResultHasError = graphQLResultHasError;
    exports.hasClientExports = hasClientExports;
    exports.hasDirectives = hasDirectives;
    exports.isDocumentNode = isDocumentNode;
    exports.isField = isField;
    exports.isInlineFragment = isInlineFragment;
    exports.isNonEmptyArray = isNonEmptyArray;
    exports.isNonNullObject = isNonNullObject;
    exports.isReference = isReference;
    exports.iterateObserversSafely = iterateObserversSafely;
    exports.makeReference = makeReference;
    exports.makeUniqueId = makeUniqueId;
    exports.maybeDeepFreeze = maybeDeepFreeze;
    exports.mergeDeep = mergeDeep;
    exports.mergeDeepArray = mergeDeepArray;
    exports.offsetLimitPagination = offsetLimitPagination;
    exports.relayStylePagination = relayStylePagination;
    exports.removeArgumentsFromDocument = removeArgumentsFromDocument;
    exports.removeClientSetsFromDocument = removeClientSetsFromDocument;
    exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
    exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
    exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
    exports.resultKeyNameFromField = resultKeyNameFromField;
    exports.shouldInclude = shouldInclude;
    exports.storeKeyNameFromField = storeKeyNameFromField;
    exports.stringifyForDisplay = stringifyForDisplay;
    exports.valueToObjectRepresentation = valueToObjectRepresentation;
  }
});

// node_modules/@apollo/client/link/utils/utils.cjs.js
var require_utils_cjs = __commonJS({
  "node_modules/@apollo/client/link/utils/utils.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var utilities = require_utilities_cjs();
    var tslib = require_tslib();
    function fromError(errorValue) {
      return new utilities.Observable(function(observer) {
        observer.error(errorValue);
      });
    }
    function toPromise(observable) {
      var completed = false;
      return new Promise(function(resolve, reject) {
        observable.subscribe({
          next: function(data) {
            if (completed) {
              __DEV__ && globals.invariant.warn("Promise Wrapper does not support multiple results from Observable");
            } else {
              completed = true;
              resolve(data);
            }
          },
          error: reject
        });
      });
    }
    function fromPromise(promise) {
      return new utilities.Observable(function(observer) {
        promise.then(function(value) {
          observer.next(value);
          observer.complete();
        }).catch(observer.error.bind(observer));
      });
    }
    var throwServerError = function(response, result, message) {
      var error = new Error(message);
      error.name = "ServerError";
      error.response = response;
      error.statusCode = response.status;
      error.result = result;
      throw error;
    };
    function validateOperation(operation) {
      var OPERATION_FIELDS = [
        "query",
        "operationName",
        "variables",
        "extensions",
        "context"
      ];
      for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
          throw __DEV__ ? new globals.InvariantError("illegal argument: " + key) : new globals.InvariantError(26);
        }
      }
      return operation;
    }
    function createOperation(starting, operation) {
      var context = tslib.__assign({}, starting);
      var setContext = function(next) {
        if (typeof next === "function") {
          context = tslib.__assign(tslib.__assign({}, context), next(context));
        } else {
          context = tslib.__assign(tslib.__assign({}, context), next);
        }
      };
      var getContext = function() {
        return tslib.__assign({}, context);
      };
      Object.defineProperty(operation, "setContext", {
        enumerable: false,
        value: setContext
      });
      Object.defineProperty(operation, "getContext", {
        enumerable: false,
        value: getContext
      });
      return operation;
    }
    function transformOperation(operation) {
      var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query
      };
      if (!transformedOperation.operationName) {
        transformedOperation.operationName = typeof transformedOperation.query !== "string" ? utilities.getOperationName(transformedOperation.query) || void 0 : "";
      }
      return transformedOperation;
    }
    exports.createOperation = createOperation;
    exports.fromError = fromError;
    exports.fromPromise = fromPromise;
    exports.throwServerError = throwServerError;
    exports.toPromise = toPromise;
    exports.transformOperation = transformOperation;
    exports.validateOperation = validateOperation;
  }
});

// node_modules/@apollo/client/link/core/core.cjs.js
var require_core_cjs = __commonJS({
  "node_modules/@apollo/client/link/core/core.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var tslib = require_tslib();
    var utilities = require_utilities_cjs();
    var utils = require_utils_cjs();
    function passthrough(op, forward) {
      return forward ? forward(op) : utilities.Observable.of();
    }
    function toLink(handler) {
      return typeof handler === "function" ? new ApolloLink(handler) : handler;
    }
    function isTerminating(link) {
      return link.request.length <= 1;
    }
    var LinkError = function(_super) {
      tslib.__extends(LinkError2, _super);
      function LinkError2(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
      }
      return LinkError2;
    }(Error);
    var ApolloLink = function() {
      function ApolloLink2(request) {
        if (request)
          this.request = request;
      }
      ApolloLink2.empty = function() {
        return new ApolloLink2(function() {
          return utilities.Observable.of();
        });
      };
      ApolloLink2.from = function(links) {
        if (links.length === 0)
          return ApolloLink2.empty();
        return links.map(toLink).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink2.split = function(test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink2(passthrough));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
          return new ApolloLink2(function(operation) {
            return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
          });
        } else {
          return new ApolloLink2(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
          });
        }
      };
      ApolloLink2.execute = function(link, operation) {
        return link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of();
      };
      ApolloLink2.concat = function(first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
          __DEV__ && globals.invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
          return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
          return new ApolloLink2(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        } else {
          return new ApolloLink2(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        }
      };
      ApolloLink2.prototype.split = function(test, left, right) {
        return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
      };
      ApolloLink2.prototype.concat = function(next) {
        return ApolloLink2.concat(this, next);
      };
      ApolloLink2.prototype.request = function(operation, forward) {
        throw __DEV__ ? new globals.InvariantError("request is not implemented") : new globals.InvariantError(21);
      };
      ApolloLink2.prototype.onError = function(error, observer) {
        if (observer && observer.error) {
          observer.error(error);
          return false;
        }
        throw error;
      };
      ApolloLink2.prototype.setOnError = function(fn) {
        this.onError = fn;
        return this;
      };
      return ApolloLink2;
    }();
    var empty = ApolloLink.empty;
    var from = ApolloLink.from;
    var split = ApolloLink.split;
    var concat = ApolloLink.concat;
    var execute = ApolloLink.execute;
    exports.ApolloLink = ApolloLink;
    exports.concat = concat;
    exports.empty = empty;
    exports.execute = execute;
    exports.from = from;
    exports.split = split;
  }
});

// node_modules/@apollo/client/link/http/http.cjs.js
var require_http_cjs = __commonJS({
  "node_modules/@apollo/client/link/http/http.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var utils = require_utils_cjs();
    var tslib = require_tslib();
    var graphql = require_graphql2();
    var core = require_core_cjs();
    var utilities = require_utilities_cjs();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function parseAndCheckHttpResponse(operations) {
      return function(response) {
        return response.text().then(function(bodyText) {
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            var parseError = err;
            parseError.name = "ServerParseError";
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
          }
        }).then(function(result) {
          if (response.status >= 300) {
            utils.throwServerError(response, result, "Response not successful: Received status code " + response.status);
          }
          if (!Array.isArray(result) && !hasOwnProperty.call(result, "data") && !hasOwnProperty.call(result, "errors")) {
            utils.throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations) ? operations.map(function(op) {
              return op.operationName;
            }) : operations.operationName) + "'.");
          }
          return result;
        });
      };
    }
    var serializeFetchParameter = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = __DEV__ ? new globals.InvariantError("Network request failed. " + label + " is not serializable: " + e.message) : new globals.InvariantError(23);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
    var defaultHttpOptions = {
      includeQuery: true,
      includeExtensions: false
    };
    var defaultHeaders = {
      accept: "*/*",
      "content-type": "application/json"
    };
    var defaultOptions = {
      method: "POST"
    };
    var fallbackHttpConfig = {
      http: defaultHttpOptions,
      headers: defaultHeaders,
      options: defaultOptions
    };
    var selectHttpOptionsAndBody = function(operation, fallbackConfig) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      var options = tslib.__assign(tslib.__assign({}, fallbackConfig.options), { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
      var http = fallbackConfig.http || {};
      configs.forEach(function(config) {
        options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), headersToLowerCase(config.headers)) });
        if (config.credentials)
          options.credentials = config.credentials;
        http = tslib.__assign(tslib.__assign({}, http), config.http);
      });
      var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
      var body = { operationName, variables };
      if (http.includeExtensions)
        body.extensions = extensions;
      if (http.includeQuery)
        body.query = graphql.print(query);
      return {
        options,
        body
      };
    };
    function headersToLowerCase(headers) {
      if (headers) {
        var normalized_1 = /* @__PURE__ */ Object.create(null);
        Object.keys(Object(headers)).forEach(function(name) {
          normalized_1[name.toLowerCase()] = headers[name];
        });
        return normalized_1;
      }
      return headers;
    }
    var checkFetcher = function(fetcher) {
      if (!fetcher && typeof fetch === "undefined") {
        throw __DEV__ ? new globals.InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new globals.InvariantError(22);
      }
    };
    var createSignalIfSupported = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
    var selectURI = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
    function rewriteURIForGET(chosenURI, body) {
      var queryParams = [];
      var addQueryParam = function(key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
      };
      if ("query" in body) {
        addQueryParam("query", body.query);
      }
      if (body.operationName) {
        addQueryParam("operationName", body.operationName);
      }
      if (body.variables) {
        var serializedVariables = void 0;
        try {
          serializedVariables = serializeFetchParameter(body.variables, "Variables map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("variables", serializedVariables);
      }
      if (body.extensions) {
        var serializedExtensions = void 0;
        try {
          serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("extensions", serializedExtensions);
      }
      var fragment = "", preFragment = chosenURI;
      var fragmentStart = chosenURI.indexOf("#");
      if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
      }
      var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
      var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
      return { newURI };
    }
    var backupFetch = utilities.maybe(function() {
      return fetch;
    });
    var createHttpLink = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _b = linkOptions.includeUnusedVariables, includeUnusedVariables = _b === void 0 ? false : _b, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
      if (__DEV__) {
        checkFetcher(preferredFetch || backupFetch);
      }
      var linkConfig = {
        http: { includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new core.ApolloLink(function(operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a2 = context.clientAwareness, name_1 = _a2.name, version = _a2.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version) {
            clientAwarenessHeaders["apollographql-client-version"] = version;
          }
        }
        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        var _b2 = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
        if (body.variables && !includeUnusedVariables) {
          var unusedNames_1 = new Set(Object.keys(body.variables));
          graphql.visit(operation.query, {
            Variable: function(node, _key, parent) {
              if (parent && parent.kind !== "VariableDefinition") {
                unusedNames_1.delete(node.name.value);
              }
            }
          });
          if (unusedNames_1.size) {
            body.variables = tslib.__assign({}, body.variables);
            unusedNames_1.forEach(function(name) {
              delete body.variables[name];
            });
          }
        }
        var controller;
        if (!options.signal) {
          var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
          controller = _controller;
          if (controller)
            options.signal = signal;
        }
        var definitionIsMutation = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "mutation";
        };
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options.method = "GET";
        }
        if (options.method === "GET") {
          var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
          if (parseError) {
            return utils.fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options.body = serializeFetchParameter(body, "Payload");
          } catch (parseError2) {
            return utils.fromError(parseError2);
          }
        }
        return new utilities.Observable(function(observer) {
          var currentFetch = preferredFetch || utilities.maybe(function() {
            return fetch;
          }) || backupFetch;
          currentFetch(chosenURI, options).then(function(response) {
            operation.setContext({ response });
            return response;
          }).then(parseAndCheckHttpResponse(operation)).then(function(result) {
            observer.next(result);
            observer.complete();
            return result;
          }).catch(function(err) {
            if (err.name === "AbortError")
              return;
            if (err.result && err.result.errors && err.result.data) {
              observer.next(err.result);
            }
            observer.error(err);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
    var HttpLink = function(_super) {
      tslib.__extends(HttpLink2, _super);
      function HttpLink2(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this, createHttpLink(options).request) || this;
        _this.options = options;
        return _this;
      }
      return HttpLink2;
    }(core.ApolloLink);
    exports.HttpLink = HttpLink;
    exports.checkFetcher = checkFetcher;
    exports.createHttpLink = createHttpLink;
    exports.createSignalIfSupported = createSignalIfSupported;
    exports.fallbackHttpConfig = fallbackHttpConfig;
    exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;
    exports.rewriteURIForGET = rewriteURIForGET;
    exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;
    exports.selectURI = selectURI;
    exports.serializeFetchParameter = serializeFetchParameter;
  }
});

// node_modules/@wry/equality/lib/equality.js
var require_equality = __commonJS({
  "node_modules/@wry/equality/lib/equality.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a = Object.prototype;
    var toString = _a.toString;
    var hasOwnProperty = _a.hasOwnProperty;
    var fnToStr = Function.prototype.toString;
    var previousComparisons = /* @__PURE__ */ new Map();
    function equal(a, b) {
      try {
        return check(a, b);
      } finally {
        previousComparisons.clear();
      }
    }
    function check(a, b) {
      if (a === b) {
        return true;
      }
      var aTag = toString.call(a);
      var bTag = toString.call(b);
      if (aTag !== bTag) {
        return false;
      }
      switch (aTag) {
        case "[object Array]":
          if (a.length !== b.length)
            return false;
        case "[object Object]": {
          if (previouslyCompared(a, b))
            return true;
          var aKeys = definedKeys(a);
          var bKeys = definedKeys(b);
          var keyCount = aKeys.length;
          if (keyCount !== bKeys.length)
            return false;
          for (var k = 0; k < keyCount; ++k) {
            if (!hasOwnProperty.call(b, aKeys[k])) {
              return false;
            }
          }
          for (var k = 0; k < keyCount; ++k) {
            var key = aKeys[k];
            if (!check(a[key], b[key])) {
              return false;
            }
          }
          return true;
        }
        case "[object Error]":
          return a.name === b.name && a.message === b.message;
        case "[object Number]":
          if (a !== a)
            return b !== b;
        case "[object Boolean]":
        case "[object Date]":
          return +a === +b;
        case "[object RegExp]":
        case "[object String]":
          return a == "" + b;
        case "[object Map]":
        case "[object Set]": {
          if (a.size !== b.size)
            return false;
          if (previouslyCompared(a, b))
            return true;
          var aIterator = a.entries();
          var isMap = aTag === "[object Map]";
          while (true) {
            var info = aIterator.next();
            if (info.done)
              break;
            var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
            if (!b.has(aKey)) {
              return false;
            }
            if (isMap && !check(aValue, b.get(aKey))) {
              return false;
            }
          }
          return true;
        }
        case "[object Uint16Array]":
        case "[object Uint8Array]":
        case "[object Uint32Array]":
        case "[object Int32Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object ArrayBuffer]":
          a = new Uint8Array(a);
          b = new Uint8Array(b);
        case "[object DataView]": {
          var len = a.byteLength;
          if (len === b.byteLength) {
            while (len-- && a[len] === b[len]) {
            }
          }
          return len === -1;
        }
        case "[object AsyncFunction]":
        case "[object GeneratorFunction]":
        case "[object AsyncGeneratorFunction]":
        case "[object Function]": {
          var aCode = fnToStr.call(a);
          if (aCode !== fnToStr.call(b)) {
            return false;
          }
          return !endsWith(aCode, nativeCodeSuffix);
        }
      }
      return false;
    }
    function definedKeys(obj) {
      return Object.keys(obj).filter(isDefinedKey, obj);
    }
    function isDefinedKey(key) {
      return this[key] !== void 0;
    }
    var nativeCodeSuffix = "{ [native code] }";
    function endsWith(full, suffix) {
      var fromIndex = full.length - suffix.length;
      return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
    }
    function previouslyCompared(a, b) {
      var bSet = previousComparisons.get(a);
      if (bSet) {
        if (bSet.has(b))
          return true;
      } else {
        previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
      }
      bSet.add(b);
      return false;
    }
    exports["default"] = equal;
    exports.equal = equal;
  }
});

// node_modules/@wry/trie/lib/trie.js
var require_trie = __commonJS({
  "node_modules/@wry/trie/lib/trie.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultMakeData = function() {
      return /* @__PURE__ */ Object.create(null);
    };
    var _a = Array.prototype;
    var forEach = _a.forEach;
    var slice = _a.slice;
    var Trie = function() {
      function Trie2(weakness, makeData) {
        if (weakness === void 0) {
          weakness = true;
        }
        if (makeData === void 0) {
          makeData = defaultMakeData;
        }
        this.weakness = weakness;
        this.makeData = makeData;
      }
      Trie2.prototype.lookup = function() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
      };
      Trie2.prototype.lookupArray = function(array) {
        var node = this;
        forEach.call(array, function(key) {
          return node = node.getChildTrie(key);
        });
        return node.data || (node.data = this.makeData(slice.call(array)));
      };
      Trie2.prototype.getChildTrie = function(key) {
        var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
        var child = map.get(key);
        if (!child)
          map.set(key, child = new Trie2(this.weakness, this.makeData));
        return child;
      };
      return Trie2;
    }();
    function isObjRef(value) {
      switch (typeof value) {
        case "object":
          if (value === null)
            break;
        case "function":
          return true;
      }
      return false;
    }
    exports.Trie = Trie;
  }
});

// node_modules/@wry/context/lib/context.js
var require_context = __commonJS({
  "node_modules/@wry/context/lib/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var currentContext = null;
    var MISSING_VALUE = {};
    var idCounter = 1;
    var makeSlotClass = function() {
      return function() {
        function Slot2() {
          this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2)
          ].join(":");
        }
        Slot2.prototype.hasValue = function() {
          for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            if (this.id in context_1.slots) {
              var value = context_1.slots[this.id];
              if (value === MISSING_VALUE)
                break;
              if (context_1 !== currentContext) {
                currentContext.slots[this.id] = value;
              }
              return true;
            }
          }
          if (currentContext) {
            currentContext.slots[this.id] = MISSING_VALUE;
          }
          return false;
        };
        Slot2.prototype.getValue = function() {
          if (this.hasValue()) {
            return currentContext.slots[this.id];
          }
        };
        Slot2.prototype.withValue = function(value, callback, args, thisArg) {
          var _a;
          var slots = (_a = {
            __proto__: null
          }, _a[this.id] = value, _a);
          var parent = currentContext;
          currentContext = { parent, slots };
          try {
            return callback.apply(thisArg, args);
          } finally {
            currentContext = parent;
          }
        };
        Slot2.bind = function(callback) {
          var context = currentContext;
          return function() {
            var saved = currentContext;
            try {
              currentContext = context;
              return callback.apply(this, arguments);
            } finally {
              currentContext = saved;
            }
          };
        };
        Slot2.noContext = function(callback, args, thisArg) {
          if (currentContext) {
            var saved = currentContext;
            try {
              currentContext = null;
              return callback.apply(thisArg, args);
            } finally {
              currentContext = saved;
            }
          } else {
            return callback.apply(thisArg, args);
          }
        };
        return Slot2;
      }();
    };
    var globalKey = "@wry/context:Slot";
    var host = Array;
    var Slot = host[globalKey] || function() {
      var Slot2 = makeSlotClass();
      try {
        Object.defineProperty(host, globalKey, {
          value: host[globalKey] = Slot2,
          enumerable: false,
          writable: false,
          configurable: false
        });
      } finally {
        return Slot2;
      }
    }();
    var bind = Slot.bind;
    var noContext = Slot.noContext;
    function setTimeoutWithContext(callback, delay) {
      return setTimeout(bind(callback), delay);
    }
    function asyncFromGen(genFn) {
      return function() {
        var gen = genFn.apply(this, arguments);
        var boundNext = bind(gen.next);
        var boundThrow = bind(gen.throw);
        return new Promise(function(resolve, reject) {
          function invoke(method, argument) {
            try {
              var result = method.call(gen, argument);
            } catch (error) {
              return reject(error);
            }
            var next = result.done ? resolve : invokeNext;
            if (isPromiseLike(result.value)) {
              result.value.then(next, result.done ? reject : invokeThrow);
            } else {
              next(result.value);
            }
          }
          var invokeNext = function(value) {
            return invoke(boundNext, value);
          };
          var invokeThrow = function(error) {
            return invoke(boundThrow, error);
          };
          invokeNext();
        });
      };
    }
    function isPromiseLike(value) {
      return value && typeof value.then === "function";
    }
    var wrappedFibers = [];
    function wrapYieldingFiberMethods(Fiber) {
      if (wrappedFibers.indexOf(Fiber) < 0) {
        var wrap = function(obj, method) {
          var fn = obj[method];
          obj[method] = function() {
            return noContext(fn, arguments, this);
          };
        };
        wrap(Fiber, "yield");
        wrap(Fiber.prototype, "run");
        wrap(Fiber.prototype, "throwInto");
        wrappedFibers.push(Fiber);
      }
      return Fiber;
    }
    exports.Slot = Slot;
    exports.asyncFromGen = asyncFromGen;
    exports.bind = bind;
    exports.noContext = noContext;
    exports.setTimeout = setTimeoutWithContext;
    exports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;
  }
});

// node_modules/optimism/lib/bundle.cjs.js
var require_bundle_cjs = __commonJS({
  "node_modules/optimism/lib/bundle.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var trie = require_trie();
    var context = require_context();
    function defaultDispose() {
    }
    var Cache = function() {
      function Cache2(max, dispose) {
        if (max === void 0) {
          max = Infinity;
        }
        if (dispose === void 0) {
          dispose = defaultDispose;
        }
        this.max = max;
        this.dispose = dispose;
        this.map = /* @__PURE__ */ new Map();
        this.newest = null;
        this.oldest = null;
      }
      Cache2.prototype.has = function(key) {
        return this.map.has(key);
      };
      Cache2.prototype.get = function(key) {
        var node = this.getNode(key);
        return node && node.value;
      };
      Cache2.prototype.getNode = function(key) {
        var node = this.map.get(key);
        if (node && node !== this.newest) {
          var older = node.older, newer = node.newer;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      };
      Cache2.prototype.set = function(key, value) {
        var node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
      };
      Cache2.prototype.clean = function() {
        while (this.oldest && this.map.size > this.max) {
          this.delete(this.oldest.key);
        }
      };
      Cache2.prototype.delete = function(key) {
        var node = this.map.get(key);
        if (node) {
          if (node === this.newest) {
            this.newest = node.older;
          }
          if (node === this.oldest) {
            this.oldest = node.newer;
          }
          if (node.newer) {
            node.newer.older = node.older;
          }
          if (node.older) {
            node.older.newer = node.newer;
          }
          this.map.delete(key);
          this.dispose(node.value, key);
          return true;
        }
        return false;
      };
      return Cache2;
    }();
    var parentEntrySlot = new context.Slot();
    var _a;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var toArray = (_a = Array.from, _a === void 0 ? function(collection) {
      var array = [];
      collection.forEach(function(item) {
        return array.push(item);
      });
      return array;
    } : _a);
    function maybeUnsubscribe(entryOrDep) {
      var unsubscribe = entryOrDep.unsubscribe;
      if (typeof unsubscribe === "function") {
        entryOrDep.unsubscribe = void 0;
        unsubscribe();
      }
    }
    var emptySetPool = [];
    var POOL_TARGET_SIZE = 100;
    function assert(condition, optionalMessage) {
      if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
      }
    }
    function valueIs(a, b) {
      var len = a.length;
      return len > 0 && len === b.length && a[len - 1] === b[len - 1];
    }
    function valueGet(value) {
      switch (value.length) {
        case 0:
          throw new Error("unknown value");
        case 1:
          return value[0];
        case 2:
          throw value[1];
      }
    }
    function valueCopy(value) {
      return value.slice(0);
    }
    var Entry = function() {
      function Entry2(fn) {
        this.fn = fn;
        this.parents = /* @__PURE__ */ new Set();
        this.childValues = /* @__PURE__ */ new Map();
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++Entry2.count;
      }
      Entry2.prototype.peek = function() {
        if (this.value.length === 1 && !mightBeDirty(this)) {
          rememberParent(this);
          return this.value[0];
        }
      };
      Entry2.prototype.recompute = function(args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
      };
      Entry2.prototype.setDirty = function() {
        if (this.dirty)
          return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        maybeUnsubscribe(this);
      };
      Entry2.prototype.dispose = function() {
        var _this = this;
        this.setDirty();
        forgetChildren(this);
        eachParent(this, function(parent, child) {
          parent.setDirty();
          forgetChild(parent, _this);
        });
      };
      Entry2.prototype.forget = function() {
        this.dispose();
      };
      Entry2.prototype.dependOn = function(dep2) {
        dep2.add(this);
        if (!this.deps) {
          this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
        }
        this.deps.add(dep2);
      };
      Entry2.prototype.forgetDeps = function() {
        var _this = this;
        if (this.deps) {
          toArray(this.deps).forEach(function(dep2) {
            return dep2.delete(_this);
          });
          this.deps.clear();
          emptySetPool.push(this.deps);
          this.deps = null;
        }
      };
      Entry2.count = 0;
      return Entry2;
    }();
    function rememberParent(child) {
      var parent = parentEntrySlot.getValue();
      if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
          parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
          reportDirtyChild(parent, child);
        } else {
          reportCleanChild(parent, child);
        }
        return parent;
      }
    }
    function reallyRecompute(entry, args) {
      forgetChildren(entry);
      parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
      if (maybeSubscribe(entry, args)) {
        setClean(entry);
      }
      return valueGet(entry.value);
    }
    function recomputeNewValue(entry, args) {
      entry.recomputing = true;
      entry.value.length = 0;
      try {
        entry.value[0] = entry.fn.apply(null, args);
      } catch (e) {
        entry.value[1] = e;
      }
      entry.recomputing = false;
    }
    function mightBeDirty(entry) {
      return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
    }
    function setClean(entry) {
      entry.dirty = false;
      if (mightBeDirty(entry)) {
        return;
      }
      reportClean(entry);
    }
    function reportDirty(child) {
      eachParent(child, reportDirtyChild);
    }
    function reportClean(child) {
      eachParent(child, reportCleanChild);
    }
    function eachParent(child, callback) {
      var parentCount = child.parents.size;
      if (parentCount) {
        var parents = toArray(child.parents);
        for (var i = 0; i < parentCount; ++i) {
          callback(parents[i], child);
        }
      }
    }
    function reportDirtyChild(parent, child) {
      assert(parent.childValues.has(child));
      assert(mightBeDirty(child));
      var parentWasClean = !mightBeDirty(parent);
      if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
      } else if (parent.dirtyChildren.has(child)) {
        return;
      }
      parent.dirtyChildren.add(child);
      if (parentWasClean) {
        reportDirty(parent);
      }
    }
    function reportCleanChild(parent, child) {
      assert(parent.childValues.has(child));
      assert(!mightBeDirty(child));
      var childValue = parent.childValues.get(child);
      if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
      } else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
      }
      removeDirtyChild(parent, child);
      if (mightBeDirty(parent)) {
        return;
      }
      reportClean(parent);
    }
    function removeDirtyChild(parent, child) {
      var dc = parent.dirtyChildren;
      if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
          if (emptySetPool.length < POOL_TARGET_SIZE) {
            emptySetPool.push(dc);
          }
          parent.dirtyChildren = null;
        }
      }
    }
    function forgetChildren(parent) {
      if (parent.childValues.size > 0) {
        parent.childValues.forEach(function(_value, child) {
          forgetChild(parent, child);
        });
      }
      parent.forgetDeps();
      assert(parent.dirtyChildren === null);
    }
    function forgetChild(parent, child) {
      child.parents.delete(parent);
      parent.childValues.delete(child);
      removeDirtyChild(parent, child);
    }
    function maybeSubscribe(entry, args) {
      if (typeof entry.subscribe === "function") {
        try {
          maybeUnsubscribe(entry);
          entry.unsubscribe = entry.subscribe.apply(null, args);
        } catch (e) {
          entry.setDirty();
          return false;
        }
      }
      return true;
    }
    var EntryMethods = {
      setDirty: true,
      dispose: true,
      forget: true
    };
    function dep(options) {
      var depsByKey = /* @__PURE__ */ new Map();
      var subscribe = options && options.subscribe;
      function depend(key) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
          var dep_1 = depsByKey.get(key);
          if (!dep_1) {
            depsByKey.set(key, dep_1 = /* @__PURE__ */ new Set());
          }
          parent.dependOn(dep_1);
          if (typeof subscribe === "function") {
            maybeUnsubscribe(dep_1);
            dep_1.unsubscribe = subscribe(key);
          }
        }
      }
      depend.dirty = function dirty(key, entryMethodName) {
        var dep2 = depsByKey.get(key);
        if (dep2) {
          var m_1 = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
          toArray(dep2).forEach(function(entry) {
            return entry[m_1]();
          });
          depsByKey.delete(key);
          maybeUnsubscribe(dep2);
        }
      };
      return depend;
    }
    function makeDefaultMakeCacheKeyFunction() {
      var keyTrie = new trie.Trie(typeof WeakMap === "function");
      return function() {
        return keyTrie.lookupArray(arguments);
      };
    }
    var defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();
    var caches = /* @__PURE__ */ new Set();
    function wrap(originalFunction, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      var cache = new Cache(options.max || Math.pow(2, 16), function(entry) {
        return entry.dispose();
      });
      var keyArgs = options.keyArgs;
      var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();
      var optimistic = function() {
        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
        if (key === void 0) {
          return originalFunction.apply(null, arguments);
        }
        var entry = cache.get(key);
        if (!entry) {
          cache.set(key, entry = new Entry(originalFunction));
          entry.subscribe = options.subscribe;
          entry.forget = function() {
            return cache.delete(key);
          };
        }
        var value = entry.recompute(Array.prototype.slice.call(arguments));
        cache.set(key, entry);
        caches.add(cache);
        if (!parentEntrySlot.hasValue()) {
          caches.forEach(function(cache2) {
            return cache2.clean();
          });
          caches.clear();
        }
        return value;
      };
      Object.defineProperty(optimistic, "size", {
        get: function() {
          return cache["map"].size;
        },
        configurable: false,
        enumerable: false
      });
      function dirtyKey(key) {
        var entry = cache.get(key);
        if (entry) {
          entry.setDirty();
        }
      }
      optimistic.dirtyKey = dirtyKey;
      optimistic.dirty = function dirty() {
        dirtyKey(makeCacheKey.apply(null, arguments));
      };
      function peekKey(key) {
        var entry = cache.get(key);
        if (entry) {
          return entry.peek();
        }
      }
      optimistic.peekKey = peekKey;
      optimistic.peek = function peek() {
        return peekKey(makeCacheKey.apply(null, arguments));
      };
      function forgetKey(key) {
        return cache.delete(key);
      }
      optimistic.forgetKey = forgetKey;
      optimistic.forget = function forget() {
        return forgetKey(makeCacheKey.apply(null, arguments));
      };
      optimistic.makeCacheKey = makeCacheKey;
      optimistic.getKey = keyArgs ? function getKey() {
        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
      } : makeCacheKey;
      return Object.freeze(optimistic);
    }
    Object.defineProperty(exports, "KeyTrie", {
      enumerable: true,
      get: function() {
        return trie.Trie;
      }
    });
    Object.defineProperty(exports, "asyncFromGen", {
      enumerable: true,
      get: function() {
        return context.asyncFromGen;
      }
    });
    Object.defineProperty(exports, "bindContext", {
      enumerable: true,
      get: function() {
        return context.bind;
      }
    });
    Object.defineProperty(exports, "noContext", {
      enumerable: true,
      get: function() {
        return context.noContext;
      }
    });
    Object.defineProperty(exports, "setTimeout", {
      enumerable: true,
      get: function() {
        return context.setTimeout;
      }
    });
    exports.defaultMakeCacheKey = defaultMakeCacheKey;
    exports.dep = dep;
    exports.wrap = wrap;
  }
});

// node_modules/@apollo/client/cache/cache.cjs.js
var require_cache_cjs = __commonJS({
  "node_modules/@apollo/client/cache/cache.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var tslib = require_tslib();
    var optimism = require_bundle_cjs();
    var utilities = require_utilities_cjs();
    var equality = require_equality();
    var trie = require_trie();
    var context = require_context();
    var ApolloCache = function() {
      function ApolloCache2() {
        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument);
      }
      ApolloCache2.prototype.batch = function(options) {
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
        this.performTransaction(options.update, optimisticId);
      };
      ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache2.prototype.transformDocument = function(document) {
        return document;
      };
      ApolloCache2.prototype.identify = function(object) {
        return;
      };
      ApolloCache2.prototype.gc = function() {
        return [];
      };
      ApolloCache2.prototype.modify = function(options) {
        return false;
      };
      ApolloCache2.prototype.transformForLink = function(document) {
        return document;
      };
      ApolloCache2.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache2.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
      };
      ApolloCache2.prototype.writeQuery = function(_a) {
        var id = _a.id, data = _a.data, options = tslib.__rest(_a, ["id", "data"]);
        return this.write(Object.assign(options, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache2.prototype.writeFragment = function(_a) {
        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = tslib.__rest(_a, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      return ApolloCache2;
    }();
    exports.Cache = void 0;
    (function(Cache) {
    })(exports.Cache || (exports.Cache = {}));
    var MissingFieldError = function(_super) {
      tslib.__extends(MissingFieldError2, _super);
      function MissingFieldError2(message, path, query, variables) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        _this.__proto__ = MissingFieldError2.prototype;
        return _this;
      }
      return MissingFieldError2;
    }(Error);
    var hasOwn = Object.prototype.hasOwnProperty;
    function defaultDataIdFromObject(_a, context2) {
      var __typename = _a.__typename, id = _a.id, _id = _a._id;
      if (typeof __typename === "string") {
        if (context2) {
          context2.keyObject = id !== void 0 ? { id } : _id !== void 0 ? { _id } : void 0;
        }
        if (id === void 0)
          id = _id;
        if (id !== void 0) {
          return __typename + ":" + (typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
        }
      }
    }
    var defaultConfig = {
      dataIdFromObject: defaultDataIdFromObject,
      addTypename: true,
      resultCaching: true,
      canonizeResults: false
    };
    function normalizeConfig(config) {
      return utilities.compact(defaultConfig, config);
    }
    function shouldCanonizeResults(config) {
      var value = config.canonizeResults;
      return value === void 0 ? defaultConfig.canonizeResults : value;
    }
    function getTypenameFromStoreObject(store, objectOrReference) {
      return utilities.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
    }
    var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
    function fieldNameFromStoreName(storeFieldName) {
      var match = storeFieldName.match(TypeOrFieldNameRegExp);
      return match ? match[0] : storeFieldName;
    }
    function selectionSetMatchesResult(selectionSet, result, variables) {
      if (utilities.isNonNullObject(result)) {
        return Array.isArray(result) ? result.every(function(item) {
          return selectionSetMatchesResult(selectionSet, item, variables);
        }) : selectionSet.selections.every(function(field) {
          if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
            var key = utilities.resultKeyNameFromField(field);
            return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
          }
          return true;
        });
      }
      return false;
    }
    function storeValueIsStoreObject(value) {
      return utilities.isNonNullObject(value) && !utilities.isReference(value) && !Array.isArray(value);
    }
    function makeProcessedFieldsMerger() {
      return new utilities.DeepMerger();
    }
    var DELETE = /* @__PURE__ */ Object.create(null);
    var delModifier = function() {
      return DELETE;
    };
    var INVALIDATE = /* @__PURE__ */ Object.create(null);
    exports.EntityStore = function() {
      function EntityStore(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = /* @__PURE__ */ Object.create(null);
        this.rootIds = /* @__PURE__ */ Object.create(null);
        this.refs = /* @__PURE__ */ Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return utilities.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return utilities.makeReference(objOrIdOrRef);
          }
          if (utilities.isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = utilities.makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore.prototype.toObject = function() {
        return tslib.__assign({}, this.data);
      };
      EntityStore.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return /* @__PURE__ */ Object.create(null);
        }
      };
      EntityStore.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (utilities.isReference(older))
          older = older.__ref;
        if (utilities.isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        __DEV__ ? globals.invariant(typeof dataId === "string", "store.merge expects a string ID") : globals.invariant(typeof dataId === "string", 1);
        var merged = new utilities.DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = /* @__PURE__ */ Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE,
            INVALIDATE,
            isReference: utilities.isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from || utilities.makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier ? DELETE : modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore.prototype.delete = function(dataId, fieldName, args) {
        var _a;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);
        }
        return false;
      };
      EntityStore.prototype.evict = function(options, limit) {
        var evicted = false;
        if (options.id) {
          if (hasOwn.call(this.data, options.id)) {
            evicted = this.delete(options.id, options.fieldName, options.args);
          }
          if (this instanceof Layer && this !== limit) {
            evicted = this.parent.evict(options, limit) || evicted;
          }
          if (options.fieldName || evicted) {
            this.group.dirty(options.id, options.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = /* @__PURE__ */ new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
          var root = this.data[dataId];
          if (!root)
            return found_1;
          var workSet_1 = /* @__PURE__ */ new Set([root]);
          workSet_1.forEach(function(obj) {
            if (utilities.isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (utilities.isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (utilities.isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore;
    }();
    var CacheGroup = function() {
      function CacheGroup2(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup2.prototype.resetCaching = function() {
        this.d = this.caching ? optimism.dep() : null;
        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
      };
      CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
        }
      };
      return CacheGroup2;
    }();
    function makeDepKey(dataId, storeFieldName) {
      return storeFieldName + "#" + dataId;
    }
    function maybeDependOnExistenceOfEntity(store, entityId) {
      if (supportsResultCaching(store)) {
        store.group.depend(entityId, "__exists");
      }
    }
    (function(EntityStore) {
      var Root = function(_super) {
        tslib.__extends(Root2, _super);
        function Root2(_a) {
          var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
          var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
          _this.stump = new Stump(_this);
          _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
          if (seed)
            _this.replace(seed);
          return _this;
        }
        Root2.prototype.addLayer = function(layerId, replay) {
          return this.stump.addLayer(layerId, replay);
        };
        Root2.prototype.removeLayer = function() {
          return this;
        };
        Root2.prototype.getStorage = function() {
          return this.storageTrie.lookupArray(arguments);
        };
        return Root2;
      }(EntityStore);
      EntityStore.Root = Root;
    })(exports.EntityStore || (exports.EntityStore = {}));
    var Layer = function(_super) {
      tslib.__extends(Layer2, _super);
      function Layer2(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer2.prototype.addLayer = function(layerId, replay) {
        return new Layer2(layerId, this, replay, this.group);
      };
      Layer2.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equality.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer2.prototype.toObject = function() {
        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
      };
      Layer2.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer2.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(p, arguments);
      };
      return Layer2;
    }(exports.EntityStore);
    var Stump = function(_super) {
      tslib.__extends(Stump2, _super);
      function Stump2(root) {
        return _super.call(this, "EntityStore.Stump", root, function() {
        }, new CacheGroup(root.group.caching, root.group)) || this;
      }
      Stump2.prototype.removeLayer = function() {
        return this;
      };
      Stump2.prototype.merge = function() {
        return this.parent.merge.apply(this.parent, arguments);
      };
      return Stump2;
    }(Layer);
    function storeObjectReconciler(existingObject, incomingObject, property) {
      var existingValue = existingObject[property];
      var incomingValue = incomingObject[property];
      return equality.equal(existingValue, incomingValue) ? existingValue : incomingValue;
    }
    function supportsResultCaching(store) {
      return !!(store instanceof exports.EntityStore && store.group.caching);
    }
    function shallowCopy(value) {
      if (utilities.isNonNullObject(value)) {
        return Array.isArray(value) ? value.slice(0) : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
      }
      return value;
    }
    var ObjectCanon = function() {
      function ObjectCanon2() {
        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.pool = new trie.Trie(utilities.canUseWeakMap);
        this.passes = /* @__PURE__ */ new WeakMap();
        this.keysByJSON = /* @__PURE__ */ new Map();
        this.empty = this.admit({});
      }
      ObjectCanon2.prototype.isKnown = function(value) {
        return utilities.isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon2.prototype.pass = function(value) {
        if (utilities.isNonNullObject(value)) {
          var copy = shallowCopy(value);
          this.passes.set(copy, value);
          return copy;
        }
        return value;
      };
      ObjectCanon2.prototype.admit = function(value) {
        var _this = this;
        if (utilities.isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node = this.pool.lookupArray(array);
              if (!node.array) {
                this.known.add(node.array = array);
                if (__DEV__) {
                  Object.freeze(array);
                }
              }
              return node.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node = this.pool.lookupArray(array_1);
              if (!node.object) {
                var obj_1 = node.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (__DEV__) {
                  Object.freeze(obj_1);
                }
              }
              return node.object;
            }
          }
        }
        return value;
      };
      ObjectCanon2.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node.keys = { sorted: keys, json });
          }
        }
        return node.keys;
      };
      return ObjectCanon2;
    }();
    var canonicalStringify = Object.assign(function(value) {
      if (utilities.isNonNullObject(value)) {
        if (stringifyCanon === void 0) {
          resetCanonicalStringify();
        }
        var canonical = stringifyCanon.admit(value);
        var json = stringifyCache.get(canonical);
        if (json === void 0) {
          stringifyCache.set(canonical, json = JSON.stringify(canonical));
        }
        return json;
      }
      return JSON.stringify(value);
    }, {
      reset: resetCanonicalStringify
    });
    var stringifyCanon;
    var stringifyCache;
    function resetCanonicalStringify() {
      stringifyCanon = new ObjectCanon();
      stringifyCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
    }
    function missingFromInvariant(err, context2) {
      return new MissingFieldError(err.message, context2.path.slice(), context2.query, context2.variables);
    }
    function execSelectionSetKeyArgs(options) {
      return [
        options.selectionSet,
        options.objectOrReference,
        options.context,
        options.context.canonizeResults
      ];
    }
    var StoreReader = function() {
      function StoreReader2(config) {
        var _this = this;
        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.config = utilities.compact(config, {
          addTypename: config.addTypename !== false,
          canonizeResults: shouldCanonizeResults(config)
        });
        this.canon = config.canon || new ObjectCanon();
        this.executeSelectionSet = optimism.wrap(function(options) {
          var _a;
          var canonizeResults = options.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs(options);
          peekArgs[3] = !canonizeResults;
          var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
          if (other) {
            if (canonizeResults) {
              return tslib.__assign(tslib.__assign({}, other), { result: _this.canon.admit(other.result) });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options);
        }, {
          max: this.config.resultCacheMaxSize,
          keyArgs: execSelectionSetKeyArgs,
          makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
            if (supportsResultCaching(context2.store)) {
              return context2.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = optimism.wrap(function(options) {
          maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options);
        }, {
          max: this.config.resultCacheMaxSize,
          makeCacheKey: function(_a) {
            var field = _a.field, array = _a.array, context2 = _a.context;
            if (supportsResultCaching(context2.store)) {
              return context2.store.makeCacheKey(field, array, context2.varString);
            }
          }
        });
      }
      StoreReader2.prototype.resetCanon = function() {
        this.canon = new ObjectCanon();
      };
      StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
        var rootRef = utilities.makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: utilities.getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: {
            store,
            query,
            policies,
            variables,
            varString: canonicalStringify(variables),
            canonizeResults,
            fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
            path: []
          }
        });
        var hasMissingFields = execResult.missing && execResult.missing.length > 0;
        if (hasMissingFields && !returnPartialData) {
          throw execResult.missing[0];
        }
        return {
          result: execResult.result,
          missing: execResult.missing,
          complete: !hasMissingFields
        };
      };
      StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
        if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
          var latest = this.executeSelectionSet.peek(selectionSet, parent, context2, this.canon.isKnown(result));
          if (latest && result === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader2.prototype.execSelectionSetImpl = function(_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context2 = _a.context;
        if (utilities.isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: [missingFromInvariant(__DEV__ ? new globals.InvariantError("Dangling reference to missing " + objectOrReference.__ref + " object") : new globals.InvariantError(5), context2)]
          };
        }
        var variables = context2.variables, policies = context2.policies, store = context2.store;
        var objectsToMerge = [];
        var finalResult = { result: null };
        var typename = store.getFieldValue(objectOrReference, "__typename");
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function getMissing() {
          return finalResult.missing || (finalResult.missing = []);
        }
        function handleMissing(result) {
          var _a2;
          if (result.missing)
            (_a2 = getMissing()).push.apply(_a2, result.missing);
          return result.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a2;
          if (!utilities.shouldInclude(selection, variables))
            return;
          if (utilities.isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context2.variables,
              from: objectOrReference
            }, context2);
            var resultName = utilities.resultKeyNameFromField(selection);
            context2.path.push(resultName);
            if (fieldValue === void 0) {
              if (!utilities.addTypenameToDocument.added(selection)) {
                getMissing().push(missingFromInvariant(__DEV__ ? new globals.InvariantError("Can't find field '" + selection.name.value + "' on " + (utilities.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2))) : new globals.InvariantError(6), context2));
              }
            } else if (Array.isArray(fieldValue)) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context: context2
              }));
            } else if (!selection.selectionSet) {
              if (context2.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                context: context2
              }));
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_a2 = {}, _a2[resultName] = fieldValue, _a2));
            }
            globals.invariant(context2.path.pop() === resultName);
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var merged = utilities.mergeDeepArray(objectsToMerge);
        finalResult.result = context2.canonizeResults ? this.canon.admit(merged) : utilities.maybeDeepFreeze(merged);
        this.knownResults.set(finalResult.result, selectionSet);
        return finalResult;
      };
      StoreReader2.prototype.execSubSelectedArrayImpl = function(_a) {
        var _this = this;
        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context2 = _a.context;
        var missing;
        function handleMissing(childResult, i) {
          if (childResult.missing) {
            missing = missing || [];
            missing.push.apply(missing, childResult.missing);
          }
          globals.invariant(context2.path.pop() === i);
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context2.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          context2.path.push(i);
          if (Array.isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context: context2
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: utilities.isReference(item) ? item : enclosingRef,
              context: context2
            }), i);
          }
          if (__DEV__) {
            assertSelectionSetForIdValue(context2.store, field, item);
          }
          globals.invariant(context2.path.pop() === i);
          return item;
        });
        return {
          result: context2.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader2;
    }();
    function assertSelectionSetForIdValue(store, field, fieldValue) {
      if (!field.selectionSet) {
        var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
        workSet_1.forEach(function(value) {
          if (utilities.isNonNullObject(value)) {
            __DEV__ ? globals.invariant(!utilities.isReference(value), "Missing selection set for object of type " + getTypenameFromStoreObject(store, value) + " returned for query field " + field.name.value) : globals.invariant(!utilities.isReference(value), 7);
            Object.values(value).forEach(workSet_1.add, workSet_1);
          }
        });
      }
    }
    var StoreWriter = function() {
      function StoreWriter2(cache, reader) {
        this.cache = cache;
        this.reader = reader;
      }
      StoreWriter2.prototype.writeToStore = function(store, _a) {
        var _this = this;
        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
        var operationDefinition = utilities.getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
        var context2 = {
          store,
          written: /* @__PURE__ */ Object.create(null),
          merge: function(existing, incoming) {
            return merger.merge(existing, incoming);
          },
          variables,
          varString: canonicalStringify(variables),
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
          overwrite: !!overwrite,
          incomingById: /* @__PURE__ */ new Map(),
          clientOnly: false
        };
        var ref = this.processSelectionSet({
          result: result || /* @__PURE__ */ Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: /* @__PURE__ */ new Map() },
          context: context2
        });
        if (!utilities.isReference(ref)) {
          throw __DEV__ ? new globals.InvariantError("Could not identify object " + JSON.stringify(result)) : new globals.InvariantError(8);
        }
        context2.incomingById.forEach(function(_a2, dataId2) {
          var fields = _a2.fields, mergeTree = _a2.mergeTree, selections = _a2.selections;
          var entityRef = utilities.makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, fields, context2);
            if (utilities.isReference(applied)) {
              return;
            }
            fields = applied;
          }
          if (__DEV__ && !context2.overwrite) {
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1.has(fieldNameFromStoreName(storeFieldName));
            };
            var fieldsWithSelectionSets_1 = /* @__PURE__ */ new Set();
            selections.forEach(function(selection) {
              if (utilities.isField(selection) && selection.selectionSet) {
                fieldsWithSelectionSets_1.add(selection.name.value);
              }
            });
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(fields).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss(entityRef, fields, storeFieldName, context2.store);
              }
            });
          }
          store.merge(dataId2, fields);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter2.prototype.processSelectionSet = function(_a) {
        var _this = this;
        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context2 = _a.context, mergeTree = _a.mergeTree;
        var policies = this.cache.policies;
        var _b = policies.identify(result, selectionSet, context2.fragmentMap), id = _b[0], keyObject = _b[1];
        dataId = dataId || id;
        if (typeof dataId === "string") {
          var sets = context2.written[dataId] || (context2.written[dataId] = []);
          var ref = utilities.makeReference(dataId);
          if (sets.indexOf(selectionSet) >= 0)
            return ref;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result, ref, selectionSet, context2)) {
            return ref;
          }
        }
        var incomingFields = /* @__PURE__ */ Object.create(null);
        if (keyObject) {
          incomingFields = context2.merge(incomingFields, keyObject);
        }
        var typename = dataId && policies.rootTypenamesById[dataId] || utilities.getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
        if (typeof typename === "string") {
          incomingFields.__typename = typename;
        }
        var selections = new Set(selectionSet.selections);
        selections.forEach(function(selection) {
          var _a2;
          if (!utilities.shouldInclude(selection, context2.variables))
            return;
          if (utilities.isField(selection)) {
            var resultFieldKey = utilities.resultKeyNameFromField(selection);
            var value = result[resultFieldKey];
            var wasClientOnly = context2.clientOnly;
            context2.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function(d) {
              return d.name.value === "client";
            }));
            if (value !== void 0) {
              var storeFieldName = policies.getStoreFieldName({
                typename,
                fieldName: selection.name.value,
                field: selection,
                variables: context2.variables
              });
              var childTree = getChildMergeTree(mergeTree, storeFieldName);
              var incomingValue = _this.processFieldValue(value, selection, context2, childTree);
              var childTypename = void 0;
              if (selection.selectionSet) {
                childTypename = context2.store.getFieldValue(incomingValue, "__typename");
                if (!childTypename && utilities.isReference(incomingValue)) {
                  var info = context2.incomingById.get(incomingValue.__ref);
                  childTypename = info && info.fields.__typename;
                }
              }
              var merge = policies.getMergeFunction(typename, selection.name.value, childTypename);
              if (merge) {
                childTree.info = {
                  field: selection,
                  typename,
                  merge
                };
              } else {
                maybeRecycleChildMergeTree(mergeTree, storeFieldName);
              }
              incomingFields = context2.merge(incomingFields, (_a2 = {}, _a2[storeFieldName] = incomingValue, _a2));
            } else if (!context2.clientOnly && !utilities.addTypenameToDocument.added(selection)) {
              __DEV__ && globals.invariant.error(("Missing field '" + utilities.resultKeyNameFromField(selection) + "' while writing result " + JSON.stringify(result, null, 2)).substring(0, 1e3));
            }
            context2.clientOnly = wasClientOnly;
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
              fragment.selectionSet.selections.forEach(selections.add, selections);
            }
          }
        });
        if (typeof dataId === "string") {
          var previous = context2.incomingById.get(dataId);
          if (previous) {
            previous.fields = context2.merge(previous.fields, incomingFields);
            previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);
            previous.selections.forEach(selections.add, selections);
            previous.selections = selections;
          } else {
            context2.incomingById.set(dataId, {
              fields: incomingFields,
              mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
              selections
            });
          }
          return utilities.makeReference(dataId);
        }
        return incomingFields;
      };
      StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return __DEV__ ? utilities.cloneDeep(value) : value;
        }
        if (Array.isArray(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i));
            maybeRecycleChildMergeTree(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context: context2,
          mergeTree
        });
      };
      StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
        var _a;
        var _this = this;
        if (mergeTree.map.size && !utilities.isReference(incoming)) {
          var e_1 = !Array.isArray(incoming) && (utilities.isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from, name) {
            return Array.isArray(from) ? typeof name === "number" ? from[name] : void 0 : context2.store.getFieldValue(from, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (iVal === void 0)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              globals.invariant(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = Array.isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a = context2.store).getStorage.apply(_a, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter2;
    }();
    var emptyMergeTreePool = [];
    function getChildMergeTree(_a, name) {
      var map = _a.map;
      if (!map.has(name)) {
        map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
      }
      return map.get(name);
    }
    function mergeMergeTrees(left, right) {
      if (left === right || !right || mergeTreeIsEmpty(right))
        return left;
      if (!left || mergeTreeIsEmpty(left))
        return right;
      var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
      var needToMergeMaps = left.map.size && right.map.size;
      var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
      var merged = { info, map };
      if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function(leftTree, key) {
          merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
          remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function(key) {
          merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
        });
      }
      return merged;
    }
    function mergeTreeIsEmpty(tree) {
      return !tree || !(tree.info || tree.map.size);
    }
    function maybeRecycleChildMergeTree(_a, name) {
      var map = _a.map;
      var childTree = map.get(name);
      if (childTree && mergeTreeIsEmpty(childTree)) {
        emptyMergeTreePool.push(childTree);
        map.delete(name);
      }
    }
    var warnings = /* @__PURE__ */ new Set();
    function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
      var getChild = function(objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
      };
      var existing = getChild(existingRef);
      if (!existing)
        return;
      var incoming = getChild(incomingObj);
      if (!incoming)
        return;
      if (utilities.isReference(existing))
        return;
      if (equality.equal(existing, incoming))
        return;
      if (Object.keys(existing).every(function(key) {
        return store.getFieldValue(incoming, key) !== void 0;
      })) {
        return;
      }
      var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var typeDotName = parentType + "." + fieldName;
      if (warnings.has(typeDotName))
        return;
      warnings.add(typeDotName);
      var childTypenames = [];
      if (!Array.isArray(existing) && !Array.isArray(incoming)) {
        [existing, incoming].forEach(function(child) {
          var typename = store.getFieldValue(child, "__typename");
          if (typeof typename === "string" && !childTypenames.includes(typename)) {
            childTypenames.push(typename);
          }
        });
      }
      __DEV__ && globals.invariant.warn("Cache data may be lost when replacing the " + fieldName + " field of a " + parentType + " object.\n\nTo address this problem (which is not a bug in Apollo Client), " + (childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "") + "define a custom merge function for the " + typeDotName + " field, so InMemoryCache can safely merge these objects:\n\n  existing: " + JSON.stringify(existing).slice(0, 1e3) + "\n  incoming: " + JSON.stringify(incoming).slice(0, 1e3) + "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n");
    }
    var cacheSlot = new context.Slot();
    var cacheInfoMap = /* @__PURE__ */ new WeakMap();
    function getCacheInfo(cache) {
      var info = cacheInfoMap.get(cache);
      if (!info) {
        cacheInfoMap.set(cache, info = {
          vars: /* @__PURE__ */ new Set(),
          dep: optimism.dep()
        });
      }
      return info;
    }
    function forgetCache(cache) {
      getCacheInfo(cache).vars.forEach(function(rv) {
        return rv.forgetCache(cache);
      });
    }
    function recallCache(cache) {
      getCacheInfo(cache).vars.forEach(function(rv) {
        return rv.attachCache(cache);
      });
    }
    function makeVar(value) {
      var caches = /* @__PURE__ */ new Set();
      var listeners = /* @__PURE__ */ new Set();
      var rv = function(newValue) {
        if (arguments.length > 0) {
          if (value !== newValue) {
            value = newValue;
            caches.forEach(function(cache2) {
              getCacheInfo(cache2).dep.dirty(rv);
              broadcast(cache2);
            });
            var oldListeners = Array.from(listeners);
            listeners.clear();
            oldListeners.forEach(function(listener) {
              return listener(value);
            });
          }
        } else {
          var cache = cacheSlot.getValue();
          if (cache) {
            attach(cache);
            getCacheInfo(cache).dep(rv);
          }
        }
        return value;
      };
      rv.onNextChange = function(listener) {
        listeners.add(listener);
        return function() {
          listeners.delete(listener);
        };
      };
      var attach = rv.attachCache = function(cache) {
        caches.add(cache);
        getCacheInfo(cache).vars.add(rv);
        return rv;
      };
      rv.forgetCache = function(cache) {
        return caches.delete(cache);
      };
      return rv;
    }
    function broadcast(cache) {
      if (cache.broadcastWatches) {
        cache.broadcastWatches();
      }
    }
    utilities.getStoreKeyName.setStringify(canonicalStringify);
    function argsFromFieldSpecifier(spec) {
      return spec.args !== void 0 ? spec.args : spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
    }
    var nullKeyFieldsFn = function() {
      return void 0;
    };
    var simpleKeyArgsFn = function(_args, context2) {
      return context2.fieldName;
    };
    var mergeTrueFn = function(existing, incoming, _a) {
      var mergeObjects = _a.mergeObjects;
      return mergeObjects(existing, incoming);
    };
    var mergeFalseFn = function(_, incoming) {
      return incoming;
    };
    var Policies = function() {
      function Policies2(config) {
        this.config = config;
        this.typePolicies = /* @__PURE__ */ Object.create(null);
        this.toBeAdded = /* @__PURE__ */ Object.create(null);
        this.supertypeMap = /* @__PURE__ */ new Map();
        this.fuzzySubtypes = /* @__PURE__ */ new Map();
        this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
        this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
        this.usingPossibleTypes = false;
        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies2.prototype.identify = function(object, selectionSet, fragmentMap) {
        var typename = selectionSet && fragmentMap ? utilities.getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var context2 = {
          typename,
          selectionSet,
          fragmentMap
        };
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
          var specifierOrId = keyFn(object, context2);
          if (Array.isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
        id = id ? String(id) : void 0;
        return context2.keyObject ? [id, context2.keyObject] : [id];
      };
      Policies2.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = tslib.__rest(_a, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies2.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read === "function") {
                existing2.read = read;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
            }
          });
        }
      };
      Policies2.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          __DEV__ ? globals.invariant(!old || old === which, "Cannot change root " + which + " __typename more than once") : globals.invariant(!old || old === which, 2);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies2.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match = subtype.match(TypeOrFieldNameRegExp);
            if (!match || match[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies2.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
          policy_1.fields = /* @__PURE__ */ Object.create(null);
          var supertypes = this.supertypeMap.get(typename);
          if (supertypes && supertypes.size) {
            supertypes.forEach(function(supertype) {
              var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = tslib.__rest(_a, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
        }
      };
      Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
        }
        return supertypeSet;
      };
      Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  __DEV__ && globals.invariant.warn("Inferring subtype " + typename + " of supertype " + supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match = typename.match(regExp);
                if (match && match[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies2.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context2 = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context2);
            if (Array.isArray(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies2.prototype.readField = function(options, context2) {
        var objectOrReference = options.from;
        if (!objectOrReference)
          return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
          return;
        if (options.typename === void 0) {
          var typename = context2.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
          var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context2, context2.store.getStorage(utilities.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
        }
        return existing;
      };
      Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies2.prototype.runMergeFunction = function(existing, incoming, _a, context2, storage) {
        var field = _a.field, typename = _a.typename, merge = _a.merge;
        if (merge === mergeTrueFn) {
          return makeMergeObjectsFunction(context2.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
          return incoming;
        }
        if (context2.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context2.variables }, context2, storage || /* @__PURE__ */ Object.create(null)));
      };
      return Policies2;
    }();
    function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
      var storeFieldName = policies.getStoreFieldName(fieldSpec);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var variables = fieldSpec.variables || context2.variables;
      var _a = context2.store, toReference = _a.toReference, canRead = _a.canRead;
      return {
        args: argsFromFieldSpecifier(fieldSpec),
        field: fieldSpec.field || null,
        fieldName,
        storeFieldName,
        variables,
        isReference: utilities.isReference,
        toReference,
        storage,
        cache: policies.cache,
        canRead,
        readField: function(fieldNameOrOptions, from) {
          var options;
          if (typeof fieldNameOrOptions === "string") {
            options = {
              fieldName: fieldNameOrOptions,
              from: arguments.length > 1 ? from : objectOrReference
            };
          } else if (utilities.isNonNullObject(fieldNameOrOptions)) {
            options = tslib.__assign({}, fieldNameOrOptions);
            if (!hasOwn.call(fieldNameOrOptions, "from")) {
              options.from = objectOrReference;
            }
          } else {
            __DEV__ && globals.invariant.warn("Unexpected readField arguments: " + utilities.stringifyForDisplay(Array.from(arguments)));
            return;
          }
          if (__DEV__ && options.from === void 0) {
            __DEV__ && globals.invariant.warn("Undefined 'from' passed to readField with arguments " + utilities.stringifyForDisplay(Array.from(arguments)));
          }
          if (options.variables === void 0) {
            options.variables = variables;
          }
          return policies.readField(options, context2);
        },
        mergeObjects: makeMergeObjectsFunction(context2.store)
      };
    }
    function makeMergeObjectsFunction(store) {
      return function mergeObjects(existing, incoming) {
        if (Array.isArray(existing) || Array.isArray(incoming)) {
          throw __DEV__ ? new globals.InvariantError("Cannot automatically merge arrays") : new globals.InvariantError(3);
        }
        if (utilities.isNonNullObject(existing) && utilities.isNonNullObject(incoming)) {
          var eType = store.getFieldValue(existing, "__typename");
          var iType = store.getFieldValue(incoming, "__typename");
          var typesDiffer = eType && iType && eType !== iType;
          if (typesDiffer) {
            return incoming;
          }
          if (utilities.isReference(existing) && storeValueIsStoreObject(incoming)) {
            store.merge(existing.__ref, incoming);
            return existing;
          }
          if (storeValueIsStoreObject(existing) && utilities.isReference(incoming)) {
            store.merge(existing, incoming.__ref);
            return incoming;
          }
          if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
            return tslib.__assign(tslib.__assign({}, existing), incoming);
          }
        }
        return incoming;
      };
    }
    function keyArgsFnFromSpecifier(specifier) {
      return function(args, context2) {
        return args ? context2.fieldName + ":" + JSON.stringify(computeKeyObject(args, specifier, false)) : context2.fieldName;
      };
    }
    function keyFieldsFnFromSpecifier(specifier) {
      var trie$1 = new trie.Trie(utilities.canUseWeakMap);
      return function(object, context2) {
        var aliasMap;
        if (context2.selectionSet && context2.fragmentMap) {
          var info = trie$1.lookupArray([
            context2.selectionSet,
            context2.fragmentMap
          ]);
          aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context2.selectionSet, context2.fragmentMap));
        }
        var keyObject = context2.keyObject = computeKeyObject(object, specifier, true, aliasMap);
        return context2.typename + ":" + JSON.stringify(keyObject);
      };
    }
    function makeAliasMap(selectionSet, fragmentMap) {
      var map = /* @__PURE__ */ Object.create(null);
      var workQueue = /* @__PURE__ */ new Set([selectionSet]);
      workQueue.forEach(function(selectionSet2) {
        selectionSet2.selections.forEach(function(selection) {
          if (utilities.isField(selection)) {
            if (selection.alias) {
              var responseKey = selection.alias.value;
              var storeKey = selection.name.value;
              if (storeKey !== responseKey) {
                var aliases = map.aliases || (map.aliases = /* @__PURE__ */ Object.create(null));
                aliases[storeKey] = responseKey;
              }
            }
            if (selection.selectionSet) {
              var subsets = map.subsets || (map.subsets = /* @__PURE__ */ Object.create(null));
              subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);
            }
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, fragmentMap);
            if (fragment) {
              workQueue.add(fragment.selectionSet);
            }
          }
        });
      });
      return map;
    }
    function computeKeyObject(response, specifier, strict, aliasMap) {
      var keyObj = /* @__PURE__ */ Object.create(null);
      var lastResponseKey;
      var lastActualKey;
      specifier.forEach(function(s) {
        if (Array.isArray(s)) {
          if (typeof lastActualKey === "string" && typeof lastResponseKey === "string") {
            var subsets = aliasMap && aliasMap.subsets;
            var subset = subsets && subsets[lastActualKey];
            keyObj[lastActualKey] = computeKeyObject(response[lastResponseKey], s, strict, subset);
          }
        } else {
          var aliases = aliasMap && aliasMap.aliases;
          var responseName = aliases && aliases[s] || s;
          if (hasOwn.call(response, responseName)) {
            keyObj[lastActualKey = s] = response[lastResponseKey = responseName];
          } else {
            __DEV__ ? globals.invariant(!strict, "Missing field '" + responseName + "' while computing key fields") : globals.invariant(!strict, 4);
            lastResponseKey = lastActualKey = void 0;
          }
        }
      });
      return keyObj;
    }
    var InMemoryCache = function(_super) {
      tslib.__extends(InMemoryCache2, _super);
      function InMemoryCache2(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.typenameDocumentCache = /* @__PURE__ */ new Map();
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = normalizeConfig(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache2.prototype.init = function() {
        var rootStore = this.data = new exports.EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canonizeResults: shouldCanonizeResults(this.config),
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon
        }));
        this.maybeBroadcastWatch = optimism.wrap(function(c, options) {
          return _this.broadcastWatch(c, options);
        }, {
          max: this.config.resultCacheMaxSize,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching(store)) {
              var optimistic = c.optimistic, rootId = c.rootId, variables = c.variables;
              return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic, rootId, variables }));
            }
          }
        });
        (/* @__PURE__ */ new Set([
          this.data.group,
          this.optimisticData.group
        ])).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache2.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache2.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache2.prototype.read = function(options) {
        var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
        try {
          return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache2.prototype.write = function(options) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.modify = function(options) {
        if (hasOwn.call(options, "id") && !options.id) {
          return false;
        }
        var store = options.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options.id || "ROOT_QUERY", options.fields);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.diff = function(options) {
        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache2.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache2.prototype.gc = function(options) {
        canonicalStringify.reset();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
          if (options.resetResultCache) {
            this.resetResultCache(options.resetResultIdentities);
          } else if (options.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache2.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache2.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache2.prototype.identify = function(object) {
        return utilities.isReference(object) ? object.__ref : this.policies.identify(object)[0];
      };
      InMemoryCache2.prototype.evict = function(options) {
        if (!options.id) {
          if (hasOwn.call(options, "id")) {
            return false;
          }
          options = tslib.__assign(tslib.__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options, this.data);
        } finally {
          if (!--this.txCount && options.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache2.prototype.reset = function(options) {
        var _this = this;
        this.init();
        canonicalStringify.reset();
        if (options && options.discardWatches) {
          this.watches.forEach(function(watch) {
            return _this.maybeBroadcastWatch.forget(watch);
          });
          this.watches.clear();
          forgetCache(this);
        } else {
          this.broadcastWatches();
        }
        return Promise.resolve();
      };
      InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache2.prototype.batch = function(options) {
        var _this = this;
        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var perform = function(layer) {
          var _a2 = _this, data = _a2.data, optimisticData = _a2.optimisticData;
          ++_this.txCount;
          if (layer) {
            _this.data = _this.optimisticData = layer;
          }
          try {
            update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = /* @__PURE__ */ new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function(watch, diff) {
            var result = onWatchUpdated.call(this, watch, diff);
            if (result !== false) {
              alreadyDirty.delete(watch);
            }
            return result;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options);
        }
      };
      InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache2.prototype.transformDocument = function(document) {
        if (this.addTypename) {
          var result = this.typenameDocumentCache.get(document);
          if (!result) {
            result = utilities.addTypenameToDocument(document);
            this.typenameDocumentCache.set(document, result);
            this.typenameDocumentCache.set(result, result);
          }
          return result;
        }
        return document;
      };
      InMemoryCache2.prototype.broadcastWatches = function(options) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options);
          });
        }
      };
      InMemoryCache2.prototype.broadcastWatch = function(c, options) {
        var lastDiff = c.lastDiff;
        var diff = this.diff(c);
        if (options) {
          if (c.optimistic && typeof options.optimistic === "string") {
            diff.fromOptimisticTransaction = true;
          }
          if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equality.equal(lastDiff.result, diff.result)) {
          c.callback(c.lastDiff = diff, lastDiff);
        }
      };
      return InMemoryCache2;
    }(ApolloCache);
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.ApolloCache = ApolloCache;
    exports.InMemoryCache = InMemoryCache;
    exports.MissingFieldError = MissingFieldError;
    exports.Policies = Policies;
    exports.cacheSlot = cacheSlot;
    exports.canonicalStringify = canonicalStringify;
    exports.defaultDataIdFromObject = defaultDataIdFromObject;
    exports.fieldNameFromStoreName = fieldNameFromStoreName;
    exports.makeVar = makeVar;
  }
});

// node_modules/@apollo/client/errors/errors.cjs.js
var require_errors_cjs = __commonJS({
  "node_modules/@apollo/client/errors/errors.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = require_tslib();
    require_globals_cjs();
    var utilities = require_utilities_cjs();
    function isApolloError(err) {
      return err.hasOwnProperty("graphQLErrors");
    }
    var generateErrorMessage = function(err) {
      var message = "";
      if (utilities.isNonEmptyArray(err.graphQLErrors) || utilities.isNonEmptyArray(err.clientErrors)) {
        var errors = (err.graphQLErrors || []).concat(err.clientErrors || []);
        errors.forEach(function(error) {
          var errorMessage = error ? error.message : "Error message not found.";
          message += errorMessage + "\n";
        });
      }
      if (err.networkError) {
        message += err.networkError.message + "\n";
      }
      message = message.replace(/\n$/, "");
      return message;
    };
    var ApolloError = function(_super) {
      tslib.__extends(ApolloError2, _super);
      function ApolloError2(_a) {
        var graphQLErrors = _a.graphQLErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError2.prototype;
        return _this;
      }
      return ApolloError2;
    }(Error);
    exports.ApolloError = ApolloError;
    exports.isApolloError = isApolloError;
  }
});

// node_modules/graphql-tag/lib/graphql-tag.umd.js
var require_graphql_tag_umd = __commonJS({
  "node_modules/graphql-tag/lib/graphql-tag.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_tslib(), require_graphql2()) : typeof define === "function" && define.amd ? define(["exports", "tslib", "graphql"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["graphql-tag"] = {}, global2.tslib, global2.graphql));
    })(exports, function(exports2, tslib, graphql) {
      "use strict";
      var docCache = /* @__PURE__ */ new Map();
      var fragmentSourceMap = /* @__PURE__ */ new Map();
      var printFragmentWarnings = true;
      var experimentalFragmentVariables = false;
      function normalize(string) {
        return string.replace(/[\s,]+/g, " ").trim();
      }
      function cacheKeyFromLoc(loc) {
        return normalize(loc.source.body.substring(loc.start, loc.end));
      }
      function processFragments(ast) {
        var seenKeys = /* @__PURE__ */ new Set();
        var definitions = [];
        ast.definitions.forEach(function(fragmentDefinition) {
          if (fragmentDefinition.kind === "FragmentDefinition") {
            var fragmentName = fragmentDefinition.name.value;
            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
            var sourceKeySet = fragmentSourceMap.get(fragmentName);
            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
              if (printFragmentWarnings) {
                console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
              }
            } else if (!sourceKeySet) {
              fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
            }
            sourceKeySet.add(sourceKey);
            if (!seenKeys.has(sourceKey)) {
              seenKeys.add(sourceKey);
              definitions.push(fragmentDefinition);
            }
          } else {
            definitions.push(fragmentDefinition);
          }
        });
        return tslib.__assign(tslib.__assign({}, ast), { definitions });
      }
      function stripLoc(doc) {
        var workSet = new Set(doc.definitions);
        workSet.forEach(function(node) {
          if (node.loc)
            delete node.loc;
          Object.keys(node).forEach(function(key) {
            var value = node[key];
            if (value && typeof value === "object") {
              workSet.add(value);
            }
          });
        });
        var loc = doc.loc;
        if (loc) {
          delete loc.startToken;
          delete loc.endToken;
        }
        return doc;
      }
      function parseDocument(source) {
        var cacheKey = normalize(source);
        if (!docCache.has(cacheKey)) {
          var parsed = graphql.parse(source, {
            experimentalFragmentVariables
          });
          if (!parsed || parsed.kind !== "Document") {
            throw new Error("Not a valid GraphQL document.");
          }
          docCache.set(cacheKey, stripLoc(processFragments(parsed)));
        }
        return docCache.get(cacheKey);
      }
      function gql2(literals) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof literals === "string") {
          literals = [literals];
        }
        var result = literals[0];
        args.forEach(function(arg, i) {
          if (arg && arg.kind === "Document") {
            result += arg.loc.source.body;
          } else {
            result += arg;
          }
          result += literals[i + 1];
        });
        return parseDocument(result);
      }
      function resetCaches() {
        docCache.clear();
        fragmentSourceMap.clear();
      }
      function disableFragmentWarnings() {
        printFragmentWarnings = false;
      }
      function enableExperimentalFragmentVariables() {
        experimentalFragmentVariables = true;
      }
      function disableExperimentalFragmentVariables() {
        experimentalFragmentVariables = false;
      }
      var extras = {
        gql: gql2,
        resetCaches,
        disableFragmentWarnings,
        enableExperimentalFragmentVariables,
        disableExperimentalFragmentVariables
      };
      (function(gql_1) {
        gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
      })(gql2 || (gql2 = {}));
      gql2["default"] = gql2;
      var gql$1 = gql2;
      exports2.default = gql$1;
      exports2.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
      exports2.disableFragmentWarnings = disableFragmentWarnings;
      exports2.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
      exports2.gql = gql2;
      exports2.resetCaches = resetCaches;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/graphql-tag/main.js
var require_main2 = __commonJS({
  "node_modules/graphql-tag/main.js"(exports, module2) {
    module2.exports = require_graphql_tag_umd().gql;
  }
});

// node_modules/@apollo/client/core/core.cjs.js
var require_core_cjs2 = __commonJS({
  "node_modules/@apollo/client/core/core.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var tslib = require_tslib();
    var core = require_core_cjs();
    var utilities = require_utilities_cjs();
    var http = require_http_cjs();
    var equality = require_equality();
    var cache = require_cache_cjs();
    var errors = require_errors_cjs();
    var graphql = require_graphql2();
    var utils = require_utils_cjs();
    var tsInvariant = require_invariant();
    var graphqlTag = require_main2();
    var version = "3.4.16";
    exports.NetworkStatus = void 0;
    (function(NetworkStatus) {
      NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
      NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
      NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
      NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
      NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
      NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
      NetworkStatus[NetworkStatus["error"] = 8] = "error";
    })(exports.NetworkStatus || (exports.NetworkStatus = {}));
    function isNetworkRequestInFlight(networkStatus) {
      return networkStatus ? networkStatus < 7 : false;
    }
    var assign = Object.assign;
    var hasOwnProperty$1 = Object.hasOwnProperty;
    var warnedAboutUpdateQuery = false;
    var ObservableQuery = function(_super) {
      tslib.__extends(ObservableQuery2, _super);
      function ObservableQuery2(_a) {
        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
        var _this = _super.call(this, function(observer) {
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback;
            }
          } catch (_a2) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          var last = _this.last;
          if (last && last.error) {
            observer.error && observer.error(last.error);
          } else if (last && last.result) {
            observer.next && observer.next(last.result);
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = /* @__PURE__ */ new Set();
        _this.subscriptions = /* @__PURE__ */ new Set();
        _this.isTornDown = false;
        _this.options = options;
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = utilities.getOperationDefinition(options.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        _this.initialFetchPolicy = options.fetchPolicy || "cache-first";
        _this.queryManager = queryManager;
        _this.queryInfo = queryInfo;
        return _this;
      }
      Object.defineProperty(ObservableQuery2.prototype, "variables", {
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery2.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var observer = {
            next: function(result) {
              resolve(result);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
        var result = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
        var shouldReturnCachedData = lastResult || fetchPolicy !== "network-only" && fetchPolicy !== "no-cache" && fetchPolicy !== "standby";
        if (shouldReturnCachedData && !this.queryManager.transform(this.options.query).hasForcedResolvers) {
          var diff = this.queryInfo.getDiff();
          if (diff.complete || this.options.returnPartialData) {
            result.data = diff.result;
          }
          if (equality.equal(result.data, {})) {
            result.data = void 0;
          }
          if (diff.complete) {
            if (result.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result.networkStatus = exports.NetworkStatus.ready;
              result.loading = false;
            }
            delete result.partial;
          } else if (fetchPolicy !== "no-cache") {
            result.partial = true;
          }
          if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
            logMissingFieldErrors(diff.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result);
        }
        return result;
      };
      ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
        return !this.last || !equality.equal(this.last.result, newResult);
      };
      ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
        var last = this.last;
        if (last && last[key] && (!variablesMustMatch || equality.equal(last.variables, this.variables))) {
          return last[key];
        }
      };
      ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
      };
      ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
      };
      ObservableQuery2.prototype.resetLastResults = function() {
        delete this.last;
        this.isTornDown = false;
      };
      ObservableQuery2.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery2.prototype.refetch = function(variables) {
        var _a;
        var reobserveOptions = {
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else if (fetchPolicy !== "cache-and-network") {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (__DEV__ && variables && hasOwnProperty$1.call(variables, "variables")) {
          var queryDef = utilities.getQueryDefinition(this.options.query);
          var vars = queryDef.variableDefinitions;
          if (!vars || !vars.some(function(v) {
            return v.variable.name.value === "variables";
          })) {
            __DEV__ && globals.invariant.warn("Called refetch(" + JSON.stringify(variables) + ") for query " + (((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || JSON.stringify(queryDef)) + ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?");
          }
        }
        if (variables && !equality.equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
      };
      ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = tslib.__assign(tslib.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
        var qid = this.queryManager.generateQueryId();
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
          this.observe();
        }
        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          var data = fetchMoreResult.data;
          var updateQuery = fetchMoreOptions.updateQuery;
          if (updateQuery) {
            if (__DEV__ && !warnedAboutUpdateQuery) {
              __DEV__ && globals.invariant.warn("The updateQuery callback for fetchMore is deprecated, and will be removed\nin the next major version of Apollo Client.\n\nPlease convert updateQuery functions to field policies with appropriate\nread and merge functions, or use/adapt a helper function (such as\nconcatPagination, offsetLimitPagination, or relayStylePagination) from\n@apollo/client/utilities.\n\nThe field policy system handles pagination more effectively than a\nhand-written updateQuery function, and you only need to define the policy\nonce, rather than every time you call fetchMore.");
              warnedAboutUpdateQuery = true;
            }
            _this.updateQuery(function(previous) {
              return updateQuery(previous, {
                fetchMoreResult: data,
                variables: combinedOptions.variables
              });
            });
          } else {
            _this.queryManager.cache.writeQuery({
              query: combinedOptions.query,
              variables: combinedOptions.variables,
              data
            });
          }
          return fetchMoreResult;
        }).finally(function() {
          _this.queryManager.stopQuery(qid);
          _this.reobserve();
        });
      };
      ObservableQuery2.prototype.subscribeToMore = function(options) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options.document,
          variables: options.variables,
          context: options.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, _a) {
                var variables = _a.variables;
                return updateQuery(previous, {
                  subscriptionData,
                  variables
                });
              });
            }
          },
          error: function(err) {
            if (options.onError) {
              options.onError(err);
              return;
            }
            __DEV__ && globals.invariant.error("Unhandled GraphQL subscription error", err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery2.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery2.prototype.setVariables = function(variables) {
        if (equality.equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          fetchPolicy: this.initialFetchPolicy,
          variables
        }, exports.NetworkStatus.setVariables);
      };
      ObservableQuery2.prototype.updateQuery = function(mapFn) {
        var queryManager = this.queryManager;
        var result = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          returnPartialData: true,
          optimistic: false
        }).result;
        var newResult = mapFn(result, {
          variables: this.variables
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery2.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery2.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
      };
      ObservableQuery2.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
        if (!pollInterval) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        __DEV__ ? globals.invariant(pollInterval, "Attempted to start a polling query without a polling interval.") : globals.invariant(pollInterval, 12);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
              _this.reobserve({
                fetchPolicy: "network-only"
              }, exports.NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        this.last = tslib.__assign(tslib.__assign({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult), variables });
        if (!utilities.isNonEmptyArray(newResult.errors)) {
          delete this.last.error;
        }
        return this.last;
      };
      ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var options = useDisposableConcast ? utilities.compact(this.options, newOptions) : assign(this.options, utilities.compact(newOptions));
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !newOptions.fetchPolicy && !equality.equal(newOptions.variables, oldVariables)) {
            options.fetchPolicy = this.initialFetchPolicy;
            if (newNetworkStatus === void 0) {
              newNetworkStatus = exports.NetworkStatus.setVariables;
            }
          }
        }
        var variables = options.variables && tslib.__assign({}, options.variables);
        var concast = this.fetch(options, newNetworkStatus);
        var observer = {
          next: function(result) {
            _this.reportResult(result, variables);
          },
          error: function(error) {
            _this.reportError(error, variables);
          }
        };
        if (!useDisposableConcast) {
          if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer, true);
          }
          this.concast = concast;
          this.observer = observer;
        }
        concast.addObserver(observer);
        return concast.promise;
      };
      ObservableQuery2.prototype.observe = function() {
        this.reportResult(this.getCurrentResult(false), this.variables);
      };
      ObservableQuery2.prototype.reportResult = function(result, variables) {
        if (this.getLastError() || this.isDifferentFromLastResult(result)) {
          this.updateLastResult(result, variables);
          utilities.iterateObserversSafely(this.observers, "next", result);
        }
      };
      ObservableQuery2.prototype.reportError = function(error, variables) {
        var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        utilities.iterateObserversSafely(this.observers, "error", this.last.error = error);
      };
      ObservableQuery2.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery2.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
          delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      return ObservableQuery2;
    }(utilities.Observable);
    utilities.fixObservableSubclass(ObservableQuery);
    function defaultSubscriptionObserverErrorCallback(error) {
      __DEV__ && globals.invariant.error("Unhandled error", error.message, error.stack);
    }
    function logMissingFieldErrors(missing) {
      if (__DEV__ && utilities.isNonEmptyArray(missing)) {
        __DEV__ && globals.invariant.debug("Missing cache result fields: " + missing.map(function(m) {
          return m.path.join(".");
        }).join(", "), missing);
      }
    }
    function applyNextFetchPolicy(options) {
      var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, nextFetchPolicy = options.nextFetchPolicy;
      if (nextFetchPolicy) {
        options.fetchPolicy = typeof nextFetchPolicy === "function" ? nextFetchPolicy.call(options, fetchPolicy) : nextFetchPolicy;
      }
    }
    var LocalState = function() {
      function LocalState2(_a) {
        var cache2 = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
        this.cache = cache2;
        if (client) {
          this.client = client;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState2.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState2.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState2.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState2.prototype.runResolvers = function(_a) {
        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_c) {
            if (document) {
              return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState2.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState2.prototype.clientQuery = function(document) {
        if (utilities.hasDirectives(["client"], document)) {
          if (this.resolvers) {
            return document;
          }
        }
        return null;
      };
      LocalState2.prototype.serverQuery = function(document) {
        return utilities.removeClientSetsFromDocument(document);
      };
      LocalState2.prototype.prepareContext = function(context) {
        var cache2 = this.cache;
        return tslib.__assign(tslib.__assign({}, context), { cache: cache2, getCacheKey: function(obj) {
          return cache2.identify(obj);
        } });
      };
      LocalState2.prototype.addExportedVariables = function(document, variables, context) {
        if (variables === void 0) {
          variables = {};
        }
        if (context === void 0) {
          context = {};
        }
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_a) {
            if (document) {
              return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return tslib.__assign(tslib.__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, tslib.__assign({}, variables)];
          });
        });
      };
      LocalState2.prototype.shouldForceResolvers = function(document) {
        var forceResolvers = false;
        graphql.visit(document, {
          Directive: {
            enter: function(node) {
              if (node.name.value === "client" && node.arguments) {
                forceResolvers = node.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return graphql.BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState2.prototype.buildRootValueFromCache = function(document, variables) {
        return this.cache.diff({
          query: utilities.buildQueryFromSelectionSet(document),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState2.prototype.resolveDocument = function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        if (context === void 0) {
          context = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return tslib.__awaiter(this, void 0, void 0, function() {
          var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache2, client, execContext;
          return tslib.__generator(this, function(_b) {
            mainDefinition = utilities.getMainDefinition(document);
            fragments = utilities.getFragmentDefinitions(document);
            fragmentMap = utilities.createFragmentMap(fragments);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a = this, cache2 = _a.cache, client = _a.client;
            execContext = {
              fragmentMap,
              context: tslib.__assign(tslib.__assign({}, context), { cache: cache2, client }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              onlyRunForcedResolvers
            };
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
              return {
                result,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute;
          var _this = this;
          return tslib.__generator(this, function(_a) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute = function(selection) {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return tslib.__generator(this, function(_a2) {
                  if (!utilities.shouldInclude(selection, variables)) {
                    return [2];
                  }
                  if (utilities.isField(selection)) {
                    return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                      var _a3;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a3 = {}, _a3[utilities.resultKeyNameFromField(selection)] = fieldResult, _a3));
                      }
                    })];
                  }
                  if (utilities.isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    __DEV__ ? globals.invariant(fragment, "No fragment named " + selection.name.value) : globals.invariant(fragment, 11);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [2];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute)).then(function() {
              return utilities.mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
          var _this = this;
          return tslib.__generator(this, function(_a) {
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = utilities.resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve) {
                  resultPromise = Promise.resolve(cache.cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    utilities.argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ]));
                }
              }
            }
            return [2, resultPromise.then(function(result) {
              if (result === void 0) {
                result = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result;
              }
              if (result == null) {
                return result;
              }
              if (Array.isArray(result)) {
                return _this.resolveSubSelectedArray(field, result, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, result, execContext);
              }
            })];
          });
        });
      };
      LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
        var _this = this;
        return Promise.all(result.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, item, execContext);
          }
        }));
      };
      return LocalState2;
    }();
    var destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();
    function wrapDestructiveCacheMethod(cache2, methodName) {
      var original = cache2[methodName];
      if (typeof original === "function") {
        cache2[methodName] = function() {
          destructiveMethodCounts.set(cache2, (destructiveMethodCounts.get(cache2) + 1) % 1e15);
          return original.apply(this, arguments);
        };
      }
    }
    function cancelNotifyTimeout(info) {
      if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
      }
    }
    var QueryInfo = function() {
      function QueryInfo2(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.listeners = /* @__PURE__ */ new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.subscriptions = /* @__PURE__ */ new Set();
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache2 = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache2)) {
          destructiveMethodCounts.set(cache2, 0);
          wrapDestructiveCacheMethod(cache2, "evict");
          wrapDestructiveCacheMethod(cache2, "modify");
          wrapDestructiveCacheMethod(cache2, "reset");
        }
      }
      QueryInfo2.prototype.init = function(query) {
        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
        if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equality.equal(this.variables, query.variables)) {
          networkStatus = exports.NetworkStatus.setVariables;
        }
        if (!equality.equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo2.prototype.reset = function() {
        cancelNotifyTimeout(this);
        this.lastDiff = void 0;
        this.dirty = false;
      };
      QueryInfo2.prototype.getDiff = function(variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var options = this.getDiffOptions(variables);
        if (this.lastDiff && equality.equal(options, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables = variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff = this.cache.diff(options);
        this.updateLastDiff(diff, options);
        return diff;
      };
      QueryInfo2.prototype.updateLastDiff = function(diff, options) {
        this.lastDiff = diff ? {
          diff,
          options: options || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo2.prototype.getDiffOptions = function(variables) {
        var _a;
        if (variables === void 0) {
          variables = this.variables;
        }
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults
        };
      };
      QueryInfo2.prototype.setDiff = function(diff) {
        var _this = this;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        this.updateLastDiff(diff);
        if (!this.dirty && !equality.equal(oldDiff && oldDiff.result, diff && diff.result)) {
          this.dirty = true;
          if (!this.notifyTimeout) {
            this.notifyTimeout = setTimeout(function() {
              return _this.notify();
            }, 0);
          }
        }
      };
      QueryInfo2.prototype.setObservableQuery = function(oq) {
        var _this = this;
        if (oq === this.observableQuery)
          return;
        if (this.oqListener) {
          this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
          this.listeners.add(this.oqListener = function() {
            if (_this.getDiff().fromOptimisticTransaction) {
              oq["observe"]();
            } else {
              oq.reobserve();
            }
          });
        } else {
          delete this.oqListener;
        }
      };
      QueryInfo2.prototype.notify = function() {
        var _this = this;
        cancelNotifyTimeout(this);
        if (this.shouldNotify()) {
          this.listeners.forEach(function(listener) {
            return listener(_this);
          });
        }
        this.dirty = false;
      };
      QueryInfo2.prototype.shouldNotify = function() {
        if (!this.dirty || !this.listeners.size) {
          return false;
        }
        if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
          var fetchPolicy = this.observableQuery.options.fetchPolicy;
          if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
            return false;
          }
        }
        return true;
      };
      QueryInfo2.prototype.stop = function() {
        if (!this.stopped) {
          this.stopped = true;
          this.reset();
          this.cancel();
          this.cancel = QueryInfo2.prototype.cancel;
          this.subscriptions.forEach(function(sub) {
            return sub.unsubscribe();
          });
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo2.prototype.cancel = function() {
      };
      QueryInfo2.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
          return _this.setDiff(diff);
        } });
        if (!this.lastWatch || !equality.equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo2.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo2.prototype.shouldWrite = function(result, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equality.equal(variables, lastWrite.variables) && equality.equal(result.data, lastWrite.result.data));
      };
      QueryInfo2.prototype.markResult = function(result, options, cacheWriteBehavior) {
        var _this = this;
        this.graphQLErrors = utilities.isNonEmptyArray(result.errors) ? result.errors : [];
        this.reset();
        if (options.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult(result, options.errorPolicy)) {
            this.cache.performTransaction(function(cache2) {
              if (_this.shouldWrite(result, options.variables)) {
                cache2.writeQuery({
                  query: _this.document,
                  data: result.data,
                  variables: options.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result,
                  variables: options.variables,
                  dmCount: destructiveMethodCounts.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options.variables);
              var diff = cache2.diff(diffOptions);
              if (!_this.stopped) {
                _this.updateWatch(options.variables);
              }
              _this.updateLastDiff(diff, diffOptions);
              if (diff.complete) {
                result.data = diff.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo2.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = exports.NetworkStatus.ready;
      };
      QueryInfo2.prototype.markError = function(error) {
        this.networkStatus = exports.NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
          this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
          this.networkError = error.networkError;
        }
        return error;
      };
      return QueryInfo2;
    }();
    function shouldWriteResult(result, errorPolicy) {
      if (errorPolicy === void 0) {
        errorPolicy = "none";
      }
      var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
      var writeWithErrors = !utilities.graphQLResultHasError(result);
      if (!writeWithErrors && ignoreErrors && result.data) {
        writeWithErrors = true;
      }
      return writeWithErrors;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var QueryManager = function() {
      function QueryManager2(_a) {
        var cache2 = _a.cache, link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
        this.clientAwareness = {};
        this.queries = /* @__PURE__ */ new Map();
        this.fetchCancelFns = /* @__PURE__ */ new Map();
        this.transformCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = /* @__PURE__ */ new Map();
        this.cache = cache2;
        this.link = link;
        this.queryDeduplication = queryDeduplication;
        this.clientAwareness = clientAwareness;
        this.localState = localState || new LocalState({ cache: cache2 });
        this.ssrMode = ssrMode;
        this.assumeImmutableResults = !!assumeImmutableResults;
        if (this.onBroadcast = onBroadcast) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
      }
      QueryManager2.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError("QueryManager stopped while query was in flight") : new globals.InvariantError(13));
      };
      QueryManager2.prototype.cancelPendingFetches = function(error) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager2.prototype.mutate = function(_a) {
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? "none" : _d, _e = _a.fetchPolicy, fetchPolicy = _e === void 0 ? "network-only" : _e, keepRootFields = _a.keepRootFields, context = _a.context;
        return tslib.__awaiter(this, void 0, void 0, function() {
          var mutationId, mutationStoreValue, self2;
          return tslib.__generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                __DEV__ ? globals.invariant(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : globals.invariant(mutation, 14);
                __DEV__ ? globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 15);
                mutationId = this.generateMutationId();
                mutation = this.transform(mutation).document;
                variables = this.getVariables(mutation, variables);
                if (!this.transform(mutation).hasClientExports)
                  return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _f.sent();
                _f.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                if (optimisticResponse) {
                  this.markMutationOptimistic(optimisticResponse, {
                    mutationId,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    updateQueries,
                    update: updateWithProxyFn,
                    keepRootFields
                  });
                }
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve, reject) {
                  return utilities.asyncMap(self2.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse }), variables, false), function(result) {
                    if (utilities.graphQLResultHasError(result) && errorPolicy === "none") {
                      throw new errors.ApolloError({
                        graphQLErrors: result.errors
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = tslib.__assign({}, result);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: optimisticResponse ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      resolve(storeResult);
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (optimisticResponse) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
        var _this = this;
        if (cache2 === void 0) {
          cache2 = this.cache;
        }
        var result = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a, queryId) {
              var observableQuery = _a.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
              var _c = cache2.diff({
                query: document,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result,
                  queryName: document && utilities.getOperationName(document) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache3) {
              if (!skipCache) {
                cacheWrites.forEach(function(write) {
                  return cache3.write(write);
                });
              }
              var update = mutation.update;
              if (update) {
                if (!skipCache) {
                  var diff = cache3.diff({
                    id: "ROOT_MUTATION",
                    query: _this.transform(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff.complete) {
                    result = tslib.__assign(tslib.__assign({}, result), { data: diff.result });
                  }
                }
                update(cache3, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
              if (!skipCache && !mutation.keepRootFields) {
                cache3.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a) {
                    var fieldName = _a.fieldName, DELETE = _a.DELETE;
                    return fieldName === "__typename" ? value : DELETE;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            optimistic: false,
            removeOptimistic: mutation.removeOptimistic,
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result2) {
            return results_1.push(result2);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result;
            });
          }
        }
        return Promise.resolve(result);
      };
      QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
        return this.cache.recordOptimisticTransaction(function(cache2) {
          try {
            _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data } }), cache2);
          } catch (error) {
            __DEV__ && globals.invariant.error(error);
          }
        }, mutation.mutationId);
      };
      QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
        return this.fetchQueryObservable(queryId, options, networkStatus).promise;
      };
      QueryManager2.prototype.getQueryStore = function() {
        var store = /* @__PURE__ */ Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager2.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager2.prototype.transform = function(document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
          var transformed = this.cache.transformDocument(document);
          var forLink = utilities.removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
          var clientQuery = this.localState.clientQuery(transformed);
          var serverQuery = forLink && this.localState.serverQuery(forLink);
          var cacheEntry_1 = {
            document: transformed,
            hasClientExports: utilities.hasClientExports(transformed),
            hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
            clientQuery,
            serverQuery,
            defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(transformed)),
            asQuery: tslib.__assign(tslib.__assign({}, transformed), { definitions: transformed.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          var add = function(doc) {
            if (doc && !transformCache.has(doc)) {
              transformCache.set(doc, cacheEntry_1);
            }
          };
          add(document);
          add(transformed);
          add(clientQuery);
          add(serverQuery);
        }
        return transformCache.get(document);
      };
      QueryManager2.prototype.getVariables = function(document, variables) {
        return tslib.__assign(tslib.__assign({}, this.transform(document).defaultVars), variables);
      };
      QueryManager2.prototype.watchQuery = function(options) {
        options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(options.query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === "undefined") {
          options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
          queryManager: this,
          queryInfo,
          options
        });
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
          document: options.query,
          observableQuery: observable,
          variables: options.variables
        });
        return observable;
      };
      QueryManager2.prototype.query = function(options, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        __DEV__ ? globals.invariant(options.query, "query option is required. You must specify your GraphQL document in the query option.") : globals.invariant(options.query, 16);
        __DEV__ ? globals.invariant(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : globals.invariant(options.query.kind === "Document", 17);
        __DEV__ ? globals.invariant(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : globals.invariant(!options.returnPartialData, 18);
        __DEV__ ? globals.invariant(!options.pollInterval, "pollInterval option only supported on watchQuery.") : globals.invariant(!options.pollInterval, 19);
        return this.fetchQuery(queryId, options).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager2.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager2.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager2.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager2.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager2.prototype.clearStore = function(options) {
        if (options === void 0) {
          options = {
            discardWatches: true
          };
        }
        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError("Store reset while query was in flight (not completed in link chain)") : new globals.InvariantError(20));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = exports.NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = /* @__PURE__ */ Object.create(null);
        }
        return this.cache.reset(options);
      };
      QueryManager2.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries = /* @__PURE__ */ new Map();
        var queryNamesAndDocs = /* @__PURE__ */ new Map();
        var legacyQueryOptions = /* @__PURE__ */ new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNamesAndDocs.set(desc, false);
            } else if (utilities.isDocumentNode(desc)) {
              queryNamesAndDocs.set(_this.transform(desc).document, false);
            } else if (utilities.isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a, queryId) {
          var oq = _a.observableQuery, document = _a.document;
          if (oq) {
            if (include === "all") {
              queries.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {
              queries.set(queryId, oq);
              if (queryName)
                queryNamesAndDocs.set(queryName, true);
              if (document)
                queryNamesAndDocs.set(document, true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options) {
            var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getQuery(queryId).init({
              document: options.query,
              variables: options.variables
            });
            var oq = new ObservableQuery({
              queryManager: _this,
              queryInfo,
              options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "network-only" })
            });
            globals.invariant(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries.set(queryId, oq);
          });
        }
        if (__DEV__ && queryNamesAndDocs.size) {
          queryNamesAndDocs.forEach(function(included, nameOrDoc) {
            if (!included) {
              __DEV__ && globals.invariant.warn("Unknown query " + (typeof nameOrDoc === "string" ? "named " : "") + JSON.stringify(nameOrDoc, null, 2) + " requested in refetchQueries options.include array");
            }
          });
        }
        return queries;
      };
      QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager2.prototype.setObservableQuery = function(observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
      };
      QueryManager2.prototype.startGraphQLSubscription = function(_a) {
        var _this = this;
        var query = _a.query, fetchPolicy = _a.fetchPolicy, errorPolicy = _a.errorPolicy, variables = _a.variables, _b = _a.context, context = _b === void 0 ? {} : _b;
        query = this.transform(query).document;
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2).map(function(result) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult(result, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            if (utilities.graphQLResultHasError(result)) {
              throw new errors.ApolloError({
                graphQLErrors: result.errors
              });
            }
            return result;
          });
        };
        if (this.transform(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new utilities.Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager2.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager2.prototype.removeQuery = function(queryId) {
        this.fetchCancelFns.delete(queryId);
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      };
      QueryManager2.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          return info.notify();
        });
      };
      QueryManager2.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {
        var _this = this;
        var _a;
        if (deduplication === void 0) {
          deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;
        }
        var observable;
        var serverQuery = this.transform(query).serverQuery;
        if (serverQuery) {
          var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: utilities.getOperationName(serverQuery) || void 0,
            context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication }))
          };
          context = operation.context;
          if (deduplication) {
            var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
            inFlightLinkObservables_1.set(serverQuery, byVariables_1);
            var varJson_1 = cache.canonicalStringify(variables);
            observable = byVariables_1.get(varJson_1);
            if (!observable) {
              var concast = new utilities.Concast([
                core.execute(link, operation)
              ]);
              byVariables_1.set(varJson_1, observable = concast);
              concast.cleanup(function() {
                if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
                  inFlightLinkObservables_1.delete(serverQuery);
                }
              });
            }
          } else {
            observable = new utilities.Concast([
              core.execute(link, operation)
            ]);
          }
        } else {
          observable = new utilities.Concast([
            utilities.Observable.of({ data: {} })
          ]);
          context = this.prepareContext(context);
        }
        var clientQuery = this.transform(query).clientQuery;
        if (clientQuery) {
          observable = utilities.asyncMap(observable, function(result) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        return utilities.asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function(result) {
          var hasErrors = utilities.isNonEmptyArray(result.errors);
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && options.errorPolicy === "none") {
              throw queryInfo.markError(new errors.ApolloError({
                graphQLErrors: result.errors
              }));
            }
            queryInfo.markResult(result, options, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result.data,
            loading: false,
            networkStatus: queryInfo.networkStatus || exports.NetworkStatus.ready
          };
          if (hasErrors && options.errorPolicy !== "ignore") {
            aqr.errors = result.errors;
          }
          return aqr;
        }, function(networkError) {
          var error = errors.isApolloError(networkError) ? networkError : new errors.ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error);
          }
          throw error;
        });
      };
      QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = exports.NetworkStatus.loading;
        }
        var query = this.transform(options.query).document;
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        };
        this.fetchCancelFns.set(queryId, function(reason) {
          setTimeout(function() {
            return concast.cancel(reason);
          });
        });
        var concast = new utilities.Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
        concast.cleanup(function() {
          _this.fetchCancelFns.delete(queryId);
          applyNextFetchPolicy(options);
        });
        return concast;
      };
      QueryManager2.prototype.refetchQueries = function(_a) {
        var _this = this;
        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
        var includedQueriesById = /* @__PURE__ */ new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: _this.getQuery(queryId).getDiff()
            });
          });
        }
        var results = /* @__PURE__ */ new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            optimistic: optimistic && removeOptimistic || false,
            removeOptimistic,
            onWatchUpdated: function(watch, diff, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result = onQueryUpdated(oq, diff, lastDiff);
                  if (result === true) {
                    result = oq.refetch();
                  }
                  if (result !== false) {
                    results.set(oq, result);
                  }
                  return false;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a2, queryId) {
            var oq = _a2.oq, lastDiff = _a2.lastDiff, diff = _a2.diff;
            var result;
            if (onQueryUpdated) {
              if (!diff) {
                var info = oq["queryInfo"];
                info.reset();
                diff = info.getDiff();
              }
              result = onQueryUpdated(oq, diff, lastDiff);
            }
            if (!onQueryUpdated || result === true) {
              result = oq.refetch();
            }
            if (result !== false) {
              results.set(oq, result);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {
        var _this = this;
        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff(variables);
        };
        var resultsFromCache = function(diff2, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
          }
          var data = diff2.result;
          if (__DEV__ && !returnPartialData && !equality.equal(data, {})) {
            logMissingFieldErrors(diff2.missing);
          }
          var fromData = function(data2) {
            return utilities.Observable.of(tslib.__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
          };
          if (data && _this.transform(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff = readCache();
            if (diff.complete) {
              return [
                resultsFromCache(diff, queryInfo.markReady())
              ];
            }
            if (returnPartialData || shouldNotify) {
              return [
                resultsFromCache(diff),
                resultsFromLink()
              ];
            }
            return [
              resultsFromLink()
            ];
          }
          case "cache-and-network": {
            var diff = readCache();
            if (diff.complete || returnPartialData || shouldNotify) {
              return [
                resultsFromCache(diff),
                resultsFromLink()
              ];
            }
            return [
              resultsFromLink()
            ];
          }
          case "cache-only":
            return [
              resultsFromCache(readCache(), queryInfo.markReady())
            ];
          case "network-only":
            if (shouldNotify) {
              return [
                resultsFromCache(readCache()),
                resultsFromLink()
              ];
            }
            return [resultsFromLink()];
          case "no-cache":
            if (shouldNotify) {
              return [
                resultsFromCache(queryInfo.getDiff()),
                resultsFromLink()
              ];
            }
            return [resultsFromLink()];
          case "standby":
            return [];
        }
      };
      QueryManager2.prototype.getQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager2.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return tslib.__assign(tslib.__assign({}, newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager2;
    }();
    var hasSuggestedDevtools = false;
    function mergeOptions(defaults, options) {
      return utilities.compact(defaults, options, options.variables && {
        variables: tslib.__assign(tslib.__assign({}, defaults.variables), options.variables)
      });
    }
    var ApolloClient = function() {
      function ApolloClient2(options) {
        var _this = this;
        this.defaultOptions = {};
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
        var link = options.link;
        if (!link) {
          link = uri ? new http.HttpLink({ uri, credentials, headers }) : core.ApolloLink.empty();
        }
        if (!cache2) {
          throw __DEV__ ? new globals.InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new globals.InvariantError(9);
        }
        this.link = link;
        this.cache = cache2;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions || {};
        this.typeDefs = typeDefs;
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        if (connectToDevTools && typeof window === "object") {
          window.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && __DEV__) {
          hasSuggestedDevtools = true;
          if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
            var nav = window.navigator;
            var ua = nav && nav.userAgent;
            var url = void 0;
            if (typeof ua === "string") {
              if (ua.indexOf("Chrome/") > -1) {
                url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
              } else if (ua.indexOf("Firefox/") > -1) {
                url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
              }
            }
            if (url) {
              __DEV__ && globals.invariant.log("Download the Apollo DevTools for a better development experience: " + url);
            }
          }
        }
        this.version = version;
        this.localState = new LocalState({
          cache: cache2,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager({
          cache: this.cache,
          link: this.link,
          queryDeduplication,
          ssrMode,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: connectToDevTools ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
      }
      ApolloClient2.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient2.prototype.watchQuery = function(options) {
        if (this.defaultOptions.watchQuery) {
          options = mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options);
      };
      ApolloClient2.prototype.query = function(options) {
        if (this.defaultOptions.query) {
          options = mergeOptions(this.defaultOptions.query, options);
        }
        __DEV__ ? globals.invariant(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : globals.invariant(options.fetchPolicy !== "cache-and-network", 10);
        if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
          options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options);
      };
      ApolloClient2.prototype.mutate = function(options) {
        if (this.defaultOptions.mutate) {
          options = mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
      };
      ApolloClient2.prototype.subscribe = function(options) {
        return this.queryManager.startGraphQLSubscription(options);
      };
      ApolloClient2.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options, optimistic);
      };
      ApolloClient2.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options, optimistic);
      };
      ApolloClient2.prototype.writeQuery = function(options) {
        this.cache.writeQuery(options);
        this.queryManager.broadcastQueries();
      };
      ApolloClient2.prototype.writeFragment = function(options) {
        this.cache.writeFragment(options);
        this.queryManager.broadcastQueries();
      };
      ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient2.prototype.__requestRaw = function(payload) {
        return core.execute(this.link, payload);
      };
      ApolloClient2.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: false
          });
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient2.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore({
            discardWatches: true
          });
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
            return fn();
          }));
        });
      };
      ApolloClient2.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient2.prototype.refetchQueries = function(options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function(result2, obsQuery) {
          queries.push(obsQuery);
          results.push(result2);
        });
        var result = Promise.all(results);
        result.queries = queries;
        result.results = results;
        result.catch(function(error) {
          __DEV__ && globals.invariant.debug("In client.refetchQueries, Promise.all promise rejected with error " + error);
        });
        return result;
      };
      ApolloClient2.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient2.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient2.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient2.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient2.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient2.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient2.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      return ApolloClient2;
    }();
    tsInvariant.setVerbosity(globals.DEV ? "log" : "silent");
    exports.Observable = utilities.Observable;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.ApolloCache = cache.ApolloCache;
    exports.Cache = cache.Cache;
    exports.InMemoryCache = cache.InMemoryCache;
    exports.MissingFieldError = cache.MissingFieldError;
    exports.defaultDataIdFromObject = cache.defaultDataIdFromObject;
    exports.makeVar = cache.makeVar;
    exports.ApolloError = errors.ApolloError;
    exports.isApolloError = errors.isApolloError;
    exports.fromError = utils.fromError;
    exports.fromPromise = utils.fromPromise;
    exports.throwServerError = utils.throwServerError;
    exports.toPromise = utils.toPromise;
    exports.setLogVerbosity = tsInvariant.setVerbosity;
    exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
    exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
    exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
    exports.gql = graphqlTag.gql;
    exports.resetCaches = graphqlTag.resetCaches;
    exports.ApolloClient = ApolloClient;
    exports.ObservableQuery = ObservableQuery;
    exports.applyNextFetchPolicy = applyNextFetchPolicy;
    exports.mergeOptions = mergeOptions;
    Object.keys(core).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = core[k];
    });
    Object.keys(http).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = http[k];
    });
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = require_object_assign();
    var n = 60103;
    var p = 60106;
    exports.Fragment = 60107;
    exports.StrictMode = 60108;
    exports.Profiler = 60114;
    var q = 60109;
    var r = 60110;
    var t = 60112;
    exports.Suspense = 60113;
    var u = 60115;
    var v = 60116;
    if (typeof Symbol === "function" && Symbol.for) {
      w = Symbol.for;
      n = w("react.element");
      p = w("react.portal");
      exports.Fragment = w("react.fragment");
      exports.StrictMode = w("react.strict_mode");
      exports.Profiler = w("react.profiler");
      q = w("react.provider");
      r = w("react.context");
      t = w("react.forward_ref");
      exports.Suspense = w("react.suspense");
      u = w("react.memo");
      v = w("react.lazy");
    }
    var w;
    var x = typeof Symbol === "function" && Symbol.iterator;
    function y(a) {
      if (a === null || typeof a !== "object")
        return null;
      a = x && a[x] || a["@@iterator"];
      return typeof a === "function" ? a : null;
    }
    function z(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var B = {};
    function C(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = B;
      this.updater = c || A;
    }
    C.prototype.isReactComponent = {};
    C.prototype.setState = function(a, b) {
      if (typeof a !== "object" && typeof a !== "function" && a != null)
        throw Error(z(85));
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    C.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function D() {
    }
    D.prototype = C.prototype;
    function E(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = B;
      this.updater = c || A;
    }
    var F = E.prototype = new D();
    F.constructor = E;
    l(F, C.prototype);
    F.isPureReactComponent = true;
    var G = { current: null };
    var H = Object.prototype.hasOwnProperty;
    var I = { key: true, ref: true, __self: true, __source: true };
    function J(a, b, c) {
      var e, d = {}, k = null, h = null;
      if (b != null)
        for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
      var g = arguments.length - 2;
      if (g === 1)
        d.children = c;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        d.children = f;
      }
      if (a && a.defaultProps)
        for (e in g = a.defaultProps, g)
          d[e] === void 0 && (d[e] = g[e]);
      return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current };
    }
    function K(a, b) {
      return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function L(a) {
      return typeof a === "object" && a !== null && a.$$typeof === n;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var M = /\/+/g;
    function N(a, b) {
      return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
    }
    function O(a, b, c, e, d) {
      var k = typeof a;
      if (k === "undefined" || k === "boolean")
        a = null;
      var h = false;
      if (a === null)
        h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case n:
              case p:
                h = true;
            }
        }
      if (h)
        return h = a, d = d(h), a = e === "" ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", a != null && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function(a2) {
          return a2;
        })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
      h = 0;
      e = e === "" ? "." : e + ":";
      if (Array.isArray(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = e + N(k, g);
          h += O(k, b, c, f, d);
        }
      else if (f = y(a), typeof f === "function")
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
      else if (k === "object")
        throw b = "" + a, Error(z(31, b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
      return h;
    }
    function P(a, b, c) {
      if (a == null)
        return a;
      var e = [], d = 0;
      O(a, e, "", "", function(a2) {
        return b.call(c, a2, d++);
      });
      return e;
    }
    function Q(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b();
        a._status = 0;
        a._result = b;
        b.then(function(b2) {
          a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);
        }, function(b2) {
          a._status === 0 && (a._status = 2, a._result = b2);
        });
      }
      if (a._status === 1)
        return a._result;
      throw a._result;
    }
    var R = { current: null };
    function S() {
      var a = R.current;
      if (a === null)
        throw Error(z(321));
      return a;
    }
    var T = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G, IsSomeRendererActing: { current: false }, assign: l };
    exports.Children = { map: P, forEach: function(a, b, c) {
      P(a, function() {
        b.apply(this, arguments);
      }, c);
    }, count: function(a) {
      var b = 0;
      P(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return P(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!L(a))
        throw Error(z(143));
      return a;
    } };
    exports.Component = C;
    exports.PureComponent = E;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
    exports.cloneElement = function(a, b, c) {
      if (a === null || a === void 0)
        throw Error(z(267, a));
      var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        b.ref !== void 0 && (k = b.ref, h = G.current);
        b.key !== void 0 && (d = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1)
        e.children = c;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        e.children = g;
      }
      return {
        $$typeof: n,
        type: a.type,
        key: d,
        ref: k,
        props: e,
        _owner: h
      };
    };
    exports.createContext = function(a, b) {
      b === void 0 && (b = null);
      a = { $$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
      a.Provider = { $$typeof: q, _context: a };
      return a.Consumer = a;
    };
    exports.createElement = J;
    exports.createFactory = function(a) {
      var b = J.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: t, render: a };
    };
    exports.isValidElement = L;
    exports.lazy = function(a) {
      return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
    };
    exports.memo = function(a, b) {
      return { $$typeof: u, type: a, compare: b === void 0 ? null : b };
    };
    exports.useCallback = function(a, b) {
      return S().useCallback(a, b);
    };
    exports.useContext = function(a, b) {
      return S().useContext(a, b);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a, b) {
      return S().useEffect(a, b);
    };
    exports.useImperativeHandle = function(a, b, c) {
      return S().useImperativeHandle(a, b, c);
    };
    exports.useLayoutEffect = function(a, b) {
      return S().useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return S().useMemo(a, b);
    };
    exports.useReducer = function(a, b, c) {
      return S().useReducer(a, b, c);
    };
    exports.useRef = function(a) {
      return S().useRef(a);
    };
    exports.useState = function(a) {
      return S().useState(a);
    };
    exports.version = "17.0.2";
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            /* @__PURE__ */ new Map([[frozenObject, null]]);
            /* @__PURE__ */ new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/@apollo/client/react/context/context.cjs.js
var require_context_cjs = __commonJS({
  "node_modules/@apollo/client/react/context/context.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var React = require_react();
    var utilities = require_utilities_cjs();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    var contextKey = utilities.canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
    function getApolloContext() {
      var context = React__namespace.createContext[contextKey];
      if (!context) {
        Object.defineProperty(React__namespace.createContext, contextKey, {
          value: context = React__namespace.createContext({}),
          enumerable: false,
          writable: false,
          configurable: true
        });
        context.displayName = "ApolloContext";
      }
      return context;
    }
    var ApolloConsumer = function(props) {
      var ApolloContext = getApolloContext();
      return React__namespace.createElement(ApolloContext.Consumer, null, function(context) {
        __DEV__ ? globals.invariant(context && context.client, 'Could not find "client" in the context of ApolloConsumer. Wrap the root component in an <ApolloProvider>.') : globals.invariant(context && context.client, 27);
        return props.children(context.client);
      });
    };
    var ApolloProvider = function(_a) {
      var client = _a.client, children = _a.children;
      var ApolloContext = getApolloContext();
      return React__namespace.createElement(ApolloContext.Consumer, null, function(context) {
        if (context === void 0) {
          context = {};
        }
        if (client && context.client !== client) {
          context = Object.assign({}, context, { client });
        }
        __DEV__ ? globals.invariant(context.client, 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.') : globals.invariant(context.client, 28);
        return React__namespace.createElement(ApolloContext.Provider, { value: context }, children);
      });
    };
    exports.ApolloConsumer = ApolloConsumer;
    exports.ApolloProvider = ApolloProvider;
    exports.getApolloContext = getApolloContext;
    exports.resetApolloContext = getApolloContext;
  }
});

// node_modules/@apollo/client/react/parser/parser.cjs.js
var require_parser_cjs = __commonJS({
  "node_modules/@apollo/client/react/parser/parser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    exports.DocumentType = void 0;
    (function(DocumentType) {
      DocumentType[DocumentType["Query"] = 0] = "Query";
      DocumentType[DocumentType["Mutation"] = 1] = "Mutation";
      DocumentType[DocumentType["Subscription"] = 2] = "Subscription";
    })(exports.DocumentType || (exports.DocumentType = {}));
    var cache = /* @__PURE__ */ new Map();
    function operationName(type) {
      var name;
      switch (type) {
        case exports.DocumentType.Query:
          name = "Query";
          break;
        case exports.DocumentType.Mutation:
          name = "Mutation";
          break;
        case exports.DocumentType.Subscription:
          name = "Subscription";
          break;
      }
      return name;
    }
    function parser(document) {
      var cached = cache.get(document);
      if (cached)
        return cached;
      var variables, type, name;
      __DEV__ ? globals.invariant(!!document && !!document.kind, "Argument of " + document + " passed to parser was not a valid GraphQL DocumentNode. You may need to use 'graphql-tag' or another method to convert your operation into a document") : globals.invariant(!!document && !!document.kind, 34);
      var fragments = document.definitions.filter(function(x) {
        return x.kind === "FragmentDefinition";
      });
      var queries = document.definitions.filter(function(x) {
        return x.kind === "OperationDefinition" && x.operation === "query";
      });
      var mutations = document.definitions.filter(function(x) {
        return x.kind === "OperationDefinition" && x.operation === "mutation";
      });
      var subscriptions = document.definitions.filter(function(x) {
        return x.kind === "OperationDefinition" && x.operation === "subscription";
      });
      __DEV__ ? globals.invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. You must include a query, subscription or mutation as well") : globals.invariant(!fragments.length || (queries.length || mutations.length || subscriptions.length), 35);
      __DEV__ ? globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " + (document + " had " + queries.length + " queries, " + subscriptions.length + " ") + ("subscriptions and " + mutations.length + " mutations. ") + "You can use 'compose' to join multiple operation types to a component") : globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, 36);
      type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;
      if (!queries.length && !mutations.length)
        type = exports.DocumentType.Subscription;
      var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
      __DEV__ ? globals.invariant(definitions.length === 1, "react-apollo only supports one definition per HOC. " + document + " had " + (definitions.length + " definitions. ") + "You can use 'compose' to join multiple operation types to a component") : globals.invariant(definitions.length === 1, 37);
      var definition = definitions[0];
      variables = definition.variableDefinitions || [];
      if (definition.name && definition.name.kind === "Name") {
        name = definition.name.value;
      } else {
        name = "data";
      }
      var payload = { name, type, variables };
      cache.set(document, payload);
      return payload;
    }
    exports.operationName = operationName;
    exports.parser = parser;
  }
});

// node_modules/@apollo/client/react/data/data.cjs.js
var require_data_cjs = __commonJS({
  "node_modules/@apollo/client/react/data/data.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var tslib = require_tslib();
    var equality = require_equality();
    var parser = require_parser_cjs();
    var errors = require_errors_cjs();
    var core = require_core_cjs2();
    var OperationData = function() {
      function OperationData2(options, context) {
        this.isMounted = false;
        this.previousOptions = {};
        this.context = {};
        this.options = {};
        this.options = options || {};
        this.context = context || {};
      }
      OperationData2.prototype.getOptions = function() {
        return this.options;
      };
      OperationData2.prototype.setOptions = function(newOptions, storePrevious) {
        if (storePrevious === void 0) {
          storePrevious = false;
        }
        if (storePrevious && !equality.equal(this.options, newOptions)) {
          this.previousOptions = this.options;
        }
        this.options = newOptions;
      };
      OperationData2.prototype.unmount = function() {
        this.isMounted = false;
      };
      OperationData2.prototype.refreshClient = function() {
        var client = this.options && this.options.client || this.context && this.context.client;
        __DEV__ ? globals.invariant(!!client, 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.') : globals.invariant(!!client, 29);
        var isNew = false;
        if (client !== this.client) {
          isNew = true;
          this.client = client;
          this.cleanup();
        }
        return {
          client: this.client,
          isNew
        };
      };
      OperationData2.prototype.verifyDocumentType = function(document, type) {
        var operation = parser.parser(document);
        var requiredOperationName = parser.operationName(type);
        var usedOperationName = parser.operationName(operation.type);
        __DEV__ ? globals.invariant(operation.type === type, "Running a " + requiredOperationName + " requires a graphql " + (requiredOperationName + ", but a " + usedOperationName + " was used instead.")) : globals.invariant(operation.type === type, 30);
      };
      return OperationData2;
    }();
    var SubscriptionData = function(_super) {
      tslib.__extends(SubscriptionData2, _super);
      function SubscriptionData2(_a) {
        var options = _a.options, context = _a.context, setResult = _a.setResult;
        var _this = _super.call(this, options, context) || this;
        _this.currentObservable = {};
        _this.setResult = setResult;
        _this.initialize(options);
        return _this;
      }
      SubscriptionData2.prototype.execute = function(result) {
        if (this.getOptions().skip === true) {
          this.cleanup();
          return {
            loading: false,
            error: void 0,
            data: void 0,
            variables: this.getOptions().variables
          };
        }
        var currentResult = result;
        if (this.refreshClient().isNew) {
          currentResult = this.getLoadingResult();
        }
        var shouldResubscribe = this.getOptions().shouldResubscribe;
        if (typeof shouldResubscribe === "function") {
          shouldResubscribe = !!shouldResubscribe(this.getOptions());
        }
        if (shouldResubscribe !== false && this.previousOptions && Object.keys(this.previousOptions).length > 0 && (this.previousOptions.subscription !== this.getOptions().subscription || !equality.equal(this.previousOptions.variables, this.getOptions().variables) || this.previousOptions.skip !== this.getOptions().skip)) {
          this.cleanup();
          currentResult = this.getLoadingResult();
        }
        this.initialize(this.getOptions());
        this.startSubscription();
        this.previousOptions = this.getOptions();
        return tslib.__assign(tslib.__assign({}, currentResult), { variables: this.getOptions().variables });
      };
      SubscriptionData2.prototype.afterExecute = function() {
        this.isMounted = true;
      };
      SubscriptionData2.prototype.cleanup = function() {
        this.endSubscription();
        delete this.currentObservable.query;
      };
      SubscriptionData2.prototype.initialize = function(options) {
        if (this.currentObservable.query || this.getOptions().skip === true)
          return;
        this.currentObservable.query = this.refreshClient().client.subscribe({
          query: options.subscription,
          variables: options.variables,
          fetchPolicy: options.fetchPolicy,
          context: options.context
        });
      };
      SubscriptionData2.prototype.startSubscription = function() {
        if (this.currentObservable.subscription)
          return;
        this.currentObservable.subscription = this.currentObservable.query.subscribe({
          next: this.updateCurrentData.bind(this),
          error: this.updateError.bind(this),
          complete: this.completeSubscription.bind(this)
        });
      };
      SubscriptionData2.prototype.getLoadingResult = function() {
        return {
          loading: true,
          error: void 0,
          data: void 0
        };
      };
      SubscriptionData2.prototype.updateResult = function(result) {
        if (this.isMounted) {
          this.setResult(result);
        }
      };
      SubscriptionData2.prototype.updateCurrentData = function(result) {
        var onSubscriptionData = this.getOptions().onSubscriptionData;
        this.updateResult({
          data: result.data,
          loading: false,
          error: void 0
        });
        if (onSubscriptionData) {
          onSubscriptionData({
            client: this.refreshClient().client,
            subscriptionData: result
          });
        }
      };
      SubscriptionData2.prototype.updateError = function(error) {
        this.updateResult({
          error,
          loading: false
        });
      };
      SubscriptionData2.prototype.completeSubscription = function() {
        var _this = this;
        Promise.resolve().then(function() {
          var onSubscriptionComplete = _this.getOptions().onSubscriptionComplete;
          if (onSubscriptionComplete)
            onSubscriptionComplete();
          _this.endSubscription();
        });
      };
      SubscriptionData2.prototype.endSubscription = function() {
        if (this.currentObservable.subscription) {
          this.currentObservable.subscription.unsubscribe();
          delete this.currentObservable.subscription;
        }
      };
      return SubscriptionData2;
    }(OperationData);
    var MutationData = function(_super) {
      tslib.__extends(MutationData2, _super);
      function MutationData2(_a) {
        var options = _a.options, context = _a.context, result = _a.result, setResult = _a.setResult;
        var _this = _super.call(this, options, context) || this;
        _this.runMutation = function(mutationFunctionOptions) {
          if (mutationFunctionOptions === void 0) {
            mutationFunctionOptions = {};
          }
          _this.onMutationStart();
          var mutationId = _this.generateNewMutationId();
          return _this.mutate(mutationFunctionOptions).then(function(response) {
            _this.onMutationCompleted(response, mutationId);
            return response;
          }).catch(function(error) {
            var onError = _this.getOptions().onError;
            _this.onMutationError(error, mutationId);
            if (onError) {
              onError(error);
              return {
                data: void 0,
                errors: error
              };
            } else {
              throw error;
            }
          });
        };
        _this.verifyDocumentType(options.mutation, parser.DocumentType.Mutation);
        _this.result = result;
        _this.setResult = setResult;
        _this.mostRecentMutationId = 0;
        return _this;
      }
      MutationData2.prototype.execute = function(result) {
        this.isMounted = true;
        this.verifyDocumentType(this.getOptions().mutation, parser.DocumentType.Mutation);
        return [
          this.runMutation,
          tslib.__assign(tslib.__assign({}, result), { client: this.refreshClient().client })
        ];
      };
      MutationData2.prototype.afterExecute = function() {
        this.isMounted = true;
        return this.unmount.bind(this);
      };
      MutationData2.prototype.cleanup = function() {
      };
      MutationData2.prototype.mutate = function(options) {
        return this.refreshClient().client.mutate(core.mergeOptions(this.getOptions(), options));
      };
      MutationData2.prototype.onMutationStart = function() {
        if (!this.result.loading && !this.getOptions().ignoreResults) {
          this.updateResult({
            loading: true,
            error: void 0,
            data: void 0,
            called: true
          });
        }
      };
      MutationData2.prototype.onMutationCompleted = function(response, mutationId) {
        var _a = this.getOptions(), onCompleted = _a.onCompleted, ignoreResults = _a.ignoreResults;
        var data = response.data, errors$1 = response.errors;
        var error = errors$1 && errors$1.length > 0 ? new errors.ApolloError({ graphQLErrors: errors$1 }) : void 0;
        var callOncomplete = function() {
          return onCompleted ? onCompleted(data) : null;
        };
        if (this.isMostRecentMutation(mutationId) && !ignoreResults) {
          this.updateResult({
            called: true,
            loading: false,
            data,
            error
          });
        }
        callOncomplete();
      };
      MutationData2.prototype.onMutationError = function(error, mutationId) {
        if (this.isMostRecentMutation(mutationId)) {
          this.updateResult({
            loading: false,
            error,
            data: void 0,
            called: true
          });
        }
      };
      MutationData2.prototype.generateNewMutationId = function() {
        return ++this.mostRecentMutationId;
      };
      MutationData2.prototype.isMostRecentMutation = function(mutationId) {
        return this.mostRecentMutationId === mutationId;
      };
      MutationData2.prototype.updateResult = function(result) {
        if (this.isMounted && (!this.previousResult || !equality.equal(this.previousResult, result))) {
          this.setResult(result);
          this.previousResult = result;
          return result;
        }
      };
      return MutationData2;
    }(OperationData);
    var QueryData = function(_super) {
      tslib.__extends(QueryData2, _super);
      function QueryData2(_a) {
        var options = _a.options, context = _a.context, onNewData = _a.onNewData;
        var _this = _super.call(this, options, context) || this;
        _this.runLazy = false;
        _this.previous = /* @__PURE__ */ Object.create(null);
        _this.runLazyQuery = function(options2) {
          _this.cleanup();
          _this.runLazy = true;
          _this.lazyOptions = options2;
          _this.onNewData();
        };
        _this.obsRefetch = function(variables) {
          var _a2;
          return (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.refetch(variables);
        };
        _this.obsFetchMore = function(fetchMoreOptions) {
          var _a2;
          return (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.fetchMore(fetchMoreOptions);
        };
        _this.obsUpdateQuery = function(mapFn) {
          var _a2;
          return (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.updateQuery(mapFn);
        };
        _this.obsStartPolling = function(pollInterval) {
          var _a2;
          (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.startPolling(pollInterval);
        };
        _this.obsStopPolling = function() {
          var _a2;
          (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.stopPolling();
        };
        _this.obsSubscribeToMore = function(options2) {
          var _a2;
          return (_a2 = _this.currentObservable) === null || _a2 === void 0 ? void 0 : _a2.subscribeToMore(options2);
        };
        _this.onNewData = onNewData;
        return _this;
      }
      QueryData2.prototype.execute = function() {
        this.refreshClient();
        var _a = this.getOptions(), skip = _a.skip, query = _a.query;
        if (skip || query !== this.previous.query) {
          this.removeQuerySubscription();
          this.removeObservable(!skip);
          this.previous.query = query;
        }
        this.updateObservableQuery();
        return this.getExecuteSsrResult() || this.getExecuteResult();
      };
      QueryData2.prototype.executeLazy = function() {
        return !this.runLazy ? [
          this.runLazyQuery,
          {
            loading: false,
            networkStatus: core.NetworkStatus.ready,
            called: false,
            data: void 0
          }
        ] : [this.runLazyQuery, this.execute()];
      };
      QueryData2.prototype.fetchData = function() {
        var _this = this;
        var options = this.getOptions();
        if (options.skip || options.ssr === false)
          return false;
        return new Promise(function(resolve) {
          return _this.startQuerySubscription(resolve);
        });
      };
      QueryData2.prototype.afterExecute = function(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.lazy, lazy = _c === void 0 ? false : _c;
        this.isMounted = true;
        var options = this.getOptions();
        if (this.currentObservable && !this.ssrInitiated()) {
          this.startQuerySubscription();
        }
        if (!lazy || this.runLazy) {
          this.handleErrorOrCompleted();
        }
        this.previousOptions = options;
        return this.unmount.bind(this);
      };
      QueryData2.prototype.cleanup = function() {
        this.removeQuerySubscription();
        this.removeObservable(true);
        delete this.previous.result;
      };
      QueryData2.prototype.getOptions = function() {
        var options = _super.prototype.getOptions.call(this);
        if (this.lazyOptions) {
          options.variables = tslib.__assign(tslib.__assign({}, options.variables), this.lazyOptions.variables);
          options.context = tslib.__assign(tslib.__assign({}, options.context), this.lazyOptions.context);
        }
        if (this.runLazy) {
          delete options.skip;
        }
        return options;
      };
      QueryData2.prototype.ssrInitiated = function() {
        return this.context && this.context.renderPromises;
      };
      QueryData2.prototype.getExecuteSsrResult = function() {
        var _a = this.getOptions(), ssr = _a.ssr, skip = _a.skip;
        var ssrDisabled = ssr === false;
        var fetchDisabled = this.refreshClient().client.disableNetworkFetches;
        var ssrLoading = tslib.__assign({ loading: true, networkStatus: core.NetworkStatus.loading, called: true, data: void 0, stale: false, client: this.client }, this.observableQueryFields());
        if (ssrDisabled && (this.ssrInitiated() || fetchDisabled)) {
          this.previous.result = ssrLoading;
          return ssrLoading;
        }
        if (this.ssrInitiated()) {
          var result = this.getExecuteResult() || ssrLoading;
          if (result.loading && !skip) {
            this.context.renderPromises.addQueryPromise(this, function() {
              return null;
            });
          }
          return result;
        }
      };
      QueryData2.prototype.prepareObservableQueryOptions = function() {
        var options = this.getOptions();
        this.verifyDocumentType(options.query, parser.DocumentType.Query);
        var displayName = options.displayName || "Query";
        if (this.ssrInitiated() && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
          options.fetchPolicy = "cache-first";
        }
        return tslib.__assign(tslib.__assign({}, options), { displayName, context: options.context });
      };
      QueryData2.prototype.initializeObservableQuery = function() {
        if (this.ssrInitiated()) {
          this.currentObservable = this.context.renderPromises.getSSRObservable(this.getOptions());
        }
        if (!this.currentObservable) {
          var observableQueryOptions = this.prepareObservableQueryOptions();
          this.previous.observableQueryOptions = tslib.__assign(tslib.__assign({}, observableQueryOptions), { children: void 0 });
          this.currentObservable = this.refreshClient().client.watchQuery(tslib.__assign({}, observableQueryOptions));
          if (this.ssrInitiated()) {
            this.context.renderPromises.registerSSRObservable(this.currentObservable, observableQueryOptions);
          }
        }
      };
      QueryData2.prototype.updateObservableQuery = function() {
        if (!this.currentObservable) {
          this.initializeObservableQuery();
          return;
        }
        var newObservableQueryOptions = tslib.__assign(tslib.__assign({}, this.prepareObservableQueryOptions()), { children: void 0 });
        if (this.getOptions().skip) {
          this.previous.observableQueryOptions = newObservableQueryOptions;
          return;
        }
        if (!equality.equal(newObservableQueryOptions, this.previous.observableQueryOptions)) {
          this.previous.observableQueryOptions = newObservableQueryOptions;
          this.currentObservable.setOptions(newObservableQueryOptions).catch(function() {
          });
        }
      };
      QueryData2.prototype.startQuerySubscription = function(onNewData) {
        var _this = this;
        if (onNewData === void 0) {
          onNewData = this.onNewData;
        }
        if (this.currentSubscription || this.getOptions().skip)
          return;
        this.currentSubscription = this.currentObservable.subscribe({
          next: function(_a) {
            var loading = _a.loading, networkStatus = _a.networkStatus, data = _a.data;
            var previousResult = _this.previous.result;
            if (previousResult && previousResult.loading === loading && previousResult.networkStatus === networkStatus && equality.equal(previousResult.data, data)) {
              return;
            }
            onNewData();
          },
          error: function(error) {
            _this.resubscribeToQuery();
            if (!error.hasOwnProperty("graphQLErrors"))
              throw error;
            var previousResult = _this.previous.result;
            if (previousResult && previousResult.loading || !equality.equal(error, _this.previous.error)) {
              _this.previous.error = error;
              onNewData();
            }
          }
        });
      };
      QueryData2.prototype.resubscribeToQuery = function() {
        this.removeQuerySubscription();
        var currentObservable = this.currentObservable;
        if (currentObservable) {
          var last = currentObservable["last"];
          try {
            currentObservable.resetLastResults();
            this.startQuerySubscription();
          } finally {
            currentObservable["last"] = last;
          }
        }
      };
      QueryData2.prototype.getExecuteResult = function() {
        var result = this.observableQueryFields();
        var options = this.getOptions();
        if (options.skip) {
          result = tslib.__assign(tslib.__assign({}, result), { data: void 0, error: void 0, loading: false, networkStatus: core.NetworkStatus.ready, called: true });
        } else if (this.currentObservable) {
          var currentResult = this.currentObservable.getCurrentResult();
          var data = currentResult.data, loading = currentResult.loading, partial = currentResult.partial, networkStatus = currentResult.networkStatus, errors$1 = currentResult.errors;
          var error = currentResult.error;
          if (errors$1 && errors$1.length > 0) {
            error = new errors.ApolloError({ graphQLErrors: errors$1 });
          }
          result = tslib.__assign(tslib.__assign({}, result), { data, loading, networkStatus, error, called: true });
          if (loading)
            ;
          else if (error) {
            Object.assign(result, {
              data: (this.currentObservable.getLastResult() || {}).data
            });
          } else {
            var fetchPolicy = this.currentObservable.options.fetchPolicy;
            var partialRefetch = options.partialRefetch;
            if (partialRefetch && partial && (!data || Object.keys(data).length === 0) && fetchPolicy !== "cache-only") {
              Object.assign(result, {
                loading: true,
                networkStatus: core.NetworkStatus.loading
              });
              result.refetch();
              return result;
            }
          }
        }
        result.client = this.client;
        this.setOptions(options, true);
        var previousResult = this.previous.result;
        this.previous.loading = previousResult && previousResult.loading || false;
        result.previousData = previousResult && (previousResult.data || previousResult.previousData);
        this.previous.result = result;
        this.currentObservable && this.currentObservable.resetQueryStoreErrors();
        return result;
      };
      QueryData2.prototype.handleErrorOrCompleted = function() {
        if (!this.currentObservable || !this.previous.result)
          return;
        var _a = this.previous.result, data = _a.data, loading = _a.loading, error = _a.error;
        if (!loading) {
          var _b = this.getOptions(), query = _b.query, variables = _b.variables, onCompleted = _b.onCompleted, onError = _b.onError, skip = _b.skip;
          if (this.previousOptions && !this.previous.loading && equality.equal(this.previousOptions.query, query) && equality.equal(this.previousOptions.variables, variables)) {
            return;
          }
          if (onCompleted && !error && !skip) {
            onCompleted(data);
          } else if (onError && error) {
            onError(error);
          }
        }
      };
      QueryData2.prototype.removeQuerySubscription = function() {
        if (this.currentSubscription) {
          this.currentSubscription.unsubscribe();
          delete this.currentSubscription;
        }
      };
      QueryData2.prototype.removeObservable = function(andDelete) {
        if (this.currentObservable) {
          this.currentObservable["tearDownQuery"]();
          if (andDelete) {
            delete this.currentObservable;
          }
        }
      };
      QueryData2.prototype.observableQueryFields = function() {
        var _a;
        return {
          variables: (_a = this.currentObservable) === null || _a === void 0 ? void 0 : _a.variables,
          refetch: this.obsRefetch,
          fetchMore: this.obsFetchMore,
          updateQuery: this.obsUpdateQuery,
          startPolling: this.obsStartPolling,
          stopPolling: this.obsStopPolling,
          subscribeToMore: this.obsSubscribeToMore
        };
      };
      return QueryData2;
    }(OperationData);
    exports.MutationData = MutationData;
    exports.OperationData = OperationData;
    exports.QueryData = QueryData;
    exports.SubscriptionData = SubscriptionData;
  }
});

// node_modules/@apollo/client/react/hooks/hooks.cjs.js
var require_hooks_cjs = __commonJS({
  "node_modules/@apollo/client/react/hooks/hooks.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals = require_globals_cjs();
    var React = require_react();
    var context = require_context_cjs();
    var tslib = require_tslib();
    var data = require_data_cjs();
    var equality = require_equality();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useApolloClient() {
      var client = React__namespace.useContext(context.getApolloContext()).client;
      __DEV__ ? globals.invariant(client, "No Apollo Client instance can be found. Please ensure that you have called `ApolloProvider` higher up in your tree.") : globals.invariant(client, 33);
      return client;
    }
    function useDeepMemo(memoFn, key) {
      var ref = React.useRef();
      if (!ref.current || !equality.equal(key, ref.current.key)) {
        ref.current = { key, value: memoFn() };
      }
      return ref.current.value;
    }
    function useAfterFastRefresh(effectFn) {
      if (__DEV__) {
        var didRefresh_1 = React.useRef(false);
        React.useEffect(function() {
          return function() {
            didRefresh_1.current = true;
          };
        }, []);
        React.useEffect(function() {
          if (didRefresh_1.current === true) {
            didRefresh_1.current = false;
            effectFn();
          }
        }, []);
      }
    }
    function useBaseQuery(query, options, lazy) {
      if (lazy === void 0) {
        lazy = false;
      }
      var context$1 = React.useContext(context.getApolloContext());
      var _a = React.useReducer(function(x) {
        return x + 1;
      }, 0), tick = _a[0], forceUpdate = _a[1];
      var updatedOptions = options ? tslib.__assign(tslib.__assign({}, options), { query }) : { query };
      var queryDataRef = React.useRef();
      var queryData = queryDataRef.current || (queryDataRef.current = new data.QueryData({
        options: updatedOptions,
        context: context$1,
        onNewData: function() {
          if (!queryData.ssrInitiated()) {
            Promise.resolve().then(function() {
              return queryDataRef.current && queryDataRef.current.isMounted && forceUpdate();
            });
          } else {
            forceUpdate();
          }
        }
      }));
      queryData.setOptions(updatedOptions);
      queryData.context = context$1;
      var memo = {
        options: tslib.__assign(tslib.__assign({}, updatedOptions), { onError: void 0, onCompleted: void 0 }),
        context: context$1,
        tick
      };
      var result = useDeepMemo(function() {
        return lazy ? queryData.executeLazy() : queryData.execute();
      }, memo);
      var queryResult = lazy ? result[1] : result;
      if (__DEV__) {
        useAfterFastRefresh(forceUpdate);
      }
      React.useEffect(function() {
        return function() {
          queryData.cleanup();
          queryDataRef.current = void 0;
        };
      }, []);
      React.useEffect(function() {
        return queryData.afterExecute({ lazy });
      }, [
        queryResult.loading,
        queryResult.networkStatus,
        queryResult.error,
        queryResult.data,
        queryData.currentObservable
      ]);
      return result;
    }
    function useLazyQuery(query, options) {
      return useBaseQuery(query, options, true);
    }
    function useMutation(mutation, options) {
      var context$1 = React.useContext(context.getApolloContext());
      var _a = React.useState({ called: false, loading: false }), result = _a[0], setResult = _a[1];
      var updatedOptions = options ? tslib.__assign(tslib.__assign({}, options), { mutation }) : { mutation };
      var mutationDataRef = React.useRef();
      function getMutationDataRef() {
        if (!mutationDataRef.current) {
          mutationDataRef.current = new data.MutationData({
            options: updatedOptions,
            context: context$1,
            result,
            setResult
          });
        }
        return mutationDataRef.current;
      }
      var mutationData = getMutationDataRef();
      mutationData.setOptions(updatedOptions);
      mutationData.context = context$1;
      React.useEffect(function() {
        return mutationData.afterExecute();
      });
      return mutationData.execute(result);
    }
    function useQuery(query, options) {
      return useBaseQuery(query, options, false);
    }
    function useSubscription(subscription, options) {
      var _a = React.useReducer(function(x) {
        return x + 1;
      }, 0), forceUpdate = _a[1];
      var context$1 = React.useContext(context.getApolloContext());
      var updatedOptions = options ? tslib.__assign(tslib.__assign({}, options), { subscription }) : { subscription };
      var _b = React.useState({
        loading: !updatedOptions.skip,
        error: void 0,
        data: void 0
      }), result = _b[0], setResult = _b[1];
      var subscriptionDataRef = React.useRef();
      function getSubscriptionDataRef() {
        if (!subscriptionDataRef.current) {
          subscriptionDataRef.current = new data.SubscriptionData({
            options: updatedOptions,
            context: context$1,
            setResult
          });
        }
        return subscriptionDataRef.current;
      }
      var subscriptionData = getSubscriptionDataRef();
      subscriptionData.setOptions(updatedOptions, true);
      subscriptionData.context = context$1;
      if (__DEV__) {
        useAfterFastRefresh(forceUpdate);
      }
      React.useEffect(function() {
        return subscriptionData.afterExecute();
      });
      React.useEffect(function() {
        return function() {
          subscriptionData.cleanup();
          subscriptionDataRef.current = void 0;
        };
      }, []);
      return subscriptionData.execute(result);
    }
    function useReactiveVar(rv) {
      var value = rv();
      var setValue = React.useState(value)[1];
      React.useEffect(function() {
        var probablySameValue = rv();
        if (value !== probablySameValue) {
          setValue(probablySameValue);
        } else {
          return rv.onNextChange(setValue);
        }
      }, [value]);
      return value;
    }
    exports.useApolloClient = useApolloClient;
    exports.useLazyQuery = useLazyQuery;
    exports.useMutation = useMutation;
    exports.useQuery = useQuery;
    exports.useReactiveVar = useReactiveVar;
    exports.useSubscription = useSubscription;
  }
});

// node_modules/@apollo/client/react/react.cjs.js
var require_react_cjs = __commonJS({
  "node_modules/@apollo/client/react/react.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_globals_cjs();
    var context = require_context_cjs();
    var hooks = require_hooks_cjs();
    var parser = require_parser_cjs();
    exports.ApolloConsumer = context.ApolloConsumer;
    exports.ApolloProvider = context.ApolloProvider;
    exports.getApolloContext = context.getApolloContext;
    exports.resetApolloContext = context.resetApolloContext;
    exports.DocumentType = parser.DocumentType;
    exports.operationName = parser.operationName;
    exports.parser = parser.parser;
    Object.keys(hooks).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = hooks[k];
    });
  }
});

// node_modules/@apollo/client/main.cjs.js
var require_main_cjs = __commonJS({
  "node_modules/@apollo/client/main.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_core_cjs2();
    var react = require_react_cjs();
    Object.keys(core).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = core[k];
    });
    Object.keys(react).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = react[k];
    });
  }
});

// src/formElements/ExportUtils.ts
var ExportUtils_exports = {};
__export(ExportUtils_exports, {
  getAnswers: () => getAnswers,
  getDataForExport: () => getDataForExport,
  getPath: () => getPath,
  normalizeSpatialProperties: () => normalizeSpatialProperties
});

// src/formElements/sortFormElements.ts
function sortFormElements(elements) {
  if (elements.length === 0) {
    return [];
  }
  const Welcome = elements.find((el) => el.typeId === "WelcomeMessage");
  const ThankYou = elements.find((el) => el.typeId === "ThankYou");
  const SaveScreen = elements.find((el) => el.typeId === "SaveScreen");
  const FeatureName = elements.find((el) => el.typeId === "FeatureName");
  const SAPRange = elements.find((el) => el.typeId === "SAPRange");
  const Consent = elements.find((el) => el.typeId === "Consent");
  const bodyElements = elements.filter((el) => el.typeId !== "WelcomeMessage" && el.typeId !== "ThankYou" && el.typeId !== "SaveScreen" && el.typeId !== "FeatureName" && el.typeId !== "SAPRange" && el.typeId !== "Consent");
  bodyElements.sort((a, b) => {
    return a.position - b.position;
  });
  const pre = [];
  const post = [];
  if (Welcome) {
    pre.push(Welcome);
  }
  if (Consent) {
    pre.push(Consent);
  }
  if (FeatureName) {
    pre.push(FeatureName);
  }
  if (SAPRange) {
    pre.push(SAPRange);
  }
  if (SaveScreen) {
    post.push(SaveScreen);
  }
  if (ThankYou) {
    post.push(ThankYou);
  }
  if (Welcome || ThankYou) {
    if (!Welcome) {
      throw new Error("WelcomeMessage FormElement not in Form");
    }
    if (!ThankYou) {
      throw new Error("ThankYou FormElement not in Form");
    }
    if (!SaveScreen) {
      throw new Error("SaveScreen FormElement is not in Form");
    }
    return [...pre, ...bodyElements, ...post];
  } else {
    return [...pre, ...bodyElements, ...post];
  }
}

// src/formElements/registerComponent.ts
var components = {};
var componentExportHelpers = {};
var defaultColumnsGetter = (settings, exportId) => [
  exportId
];
var defaultAnswersGetter = (settings, exportId, answer) => ({ [exportId]: answer });
var defaultGetValueForRuleEvaluation = (value) => value;
var defaultShouldDisplaySubordinateElementFunction = () => false;
function registerComponent(options) {
  componentExportHelpers[options.name] = {
    getColumns: options.getColumns || defaultColumnsGetter,
    getAnswers: options.getAnswers || defaultAnswersGetter,
    getValueForRuleEvaluation: options.getValueForRuleEvaluation || defaultGetValueForRuleEvaluation,
    shouldDisplaySubordinateElement: options.shouldDisplaySubordinateElement || defaultShouldDisplaySubordinateElementFunction
  };
  if (global.window) {
    import(
      /* webpackMode: "eager" */
      `./${options.fname || options.name}.tsx`
    ).then((component) => {
      components[options.name] = component.default;
    });
  }
}

// src/formElements/index.ts
registerComponent({ name: "WelcomeMessage" });
registerComponent({
  name: "Name",
  getColumns: (componentSettings, exportId) => {
    return [exportId, `is_facilitated`, `facilitator_name`];
  },
  getAnswers: (settings, exportId, answer) => {
    return {
      [exportId]: answer.name,
      is_facilitated: !!(answer.facilitator && answer.facilitator.length > 0),
      facilitator_name: answer.facilitator
    };
  }
});
registerComponent({ name: "Email" });
registerComponent({
  name: "Consent",
  getColumns: (componentSettings, exportId) => {
    return [exportId, `${exportId}_doc_version`, `${exportId}_doc_clicked`];
  },
  getAnswers: (settings, exportId, answer) => {
    return {
      [exportId]: !!answer.consented,
      [`${exportId}_doc_version`]: answer.docVersion,
      [`${exportId}_doc_clicked`]: !!answer.clickedDoc
    };
  }
});
registerComponent({
  name: "MultipleChoice",
  getColumns: (componentSettings, exportId) => {
    return [exportId];
  },
  getAnswers: (settings, exportId, answer) => {
    return {
      [exportId]: Array.isArray(answer) ? answer[0] : answer || void 0
    };
  }
});
registerComponent({ name: "ShortText" });
registerComponent({ name: "TextArea" });
registerComponent({ name: "Number" });
registerComponent({ name: "Rating" });
registerComponent({ name: "Statement" });
registerComponent({ name: "YesNo" });
registerComponent({ name: "ComboBox" });
registerComponent({
  name: "Matrix",
  getColumns: (componentSettings, exportId) => {
    return (componentSettings.rows || []).map((option) => `${exportId}_${option.value || option.label}`);
  },
  getAnswers: (settings, exportId, answer) => {
    return (settings.rows || []).reduce((prev, option) => {
      prev[`${exportId}_${option.value || option.label}`] = answer[option.value || option.label];
      return prev;
    }, {});
  }
});
registerComponent({ name: "ThankYou" });
registerComponent({ name: "SingleSpatialInput" });
registerComponent({ name: "MultiSpatialInput" });
registerComponent({
  name: "SpatialAccessPriorityInput",
  fname: "SpatialAccessPriority/SpatialAccessPriority",
  getColumns: (componentSettings, exportId) => {
    return [`${exportId}_sectors`, `${exportId}_feature_ids`];
  },
  getAnswers: (settings, exportId, answer) => {
    if (Array.isArray(answer)) {
      return {
        [`${exportId}_sectors`]: [
          "Unknown -- https://github.com/seasketch/next/commit/3a69e33b14dd444b240edc24aa95d754099e2c25"
        ],
        [`${exportId}_feature_ids`]: answer
      };
    } else {
      return {
        [`${exportId}_sectors`]: answer.sectors,
        [`${exportId}_feature_ids`]: answer.collection || []
      };
    }
  },
  getValueForRuleEvaluation: (value, componentSettings) => {
    return value.sectors;
  },
  shouldDisplaySubordinateElement: function(elementId, componentSettings, value) {
    const sectors = (value == null ? void 0 : value.sectors) || [];
    const visibilitySettings = (componentSettings == null ? void 0 : componentSettings.subordinateVisibilitySettings) || {};
    for (const sector of sectors) {
      if (visibilitySettings[elementId] && visibilitySettings[elementId].indexOf(sector) !== -1) {
        return true;
      }
    }
    return false;
  }
});
registerComponent({ name: "FeatureName" });
registerComponent({ name: "SAPRange" });
registerComponent({ name: "SaveScreen" });

// src/generated/graphql.ts
var import_client = __toESM(require_main_cjs());
var UpdateTerrainExaggerationFragmentDoc = import_client.gql`
    fragment UpdateTerrainExaggeration on Basemap {
  terrainExaggeration
}
    `;
var NewLabelsLayerFragmentDoc = import_client.gql`
    fragment NewLabelsLayer on Basemap {
  labelsLayerId
}
    `;
var NewTerrainFragmentDoc = import_client.gql`
    fragment NewTerrain on Basemap {
  terrainUrl
  terrainOptional
  terrainVisibilityDefault
}
    `;
var NewBasemapFragmentDoc = import_client.gql`
    fragment NewBasemap on Basemap {
  id
  projectId
  attribution
  description
  labelsLayerId
  name
  nodeId
  terrainExaggeration
  terrainOptional
  url
  type
  tileSize
  thumbnail
  terrainUrl
  terrainTileSize
}
    `;
var NewQueryParametersFragmentDoc = import_client.gql`
    fragment NewQueryParameters on DataSource {
  queryParameters
}
    `;
var UpdateHighDpiFragmentDoc = import_client.gql`
    fragment UpdateHighDPI on DataSource {
  useDevicePixelRatio
}
    `;
var UpdateFormatFragmentDoc = import_client.gql`
    fragment UpdateFormat on DataSource {
  queryParameters
}
    `;
var NewGlStyleFragmentDoc = import_client.gql`
    fragment NewGLStyle on DataLayer {
  mapboxGlStyles
}
    `;
var NewRenderUnderFragmentDoc = import_client.gql`
    fragment NewRenderUnder on DataLayer {
  renderUnder
}
    `;
var NewZIndexFragmentDoc = import_client.gql`
    fragment NewZIndex on DataLayer {
  zIndex
}
    `;
var NewElementFragmentDoc = import_client.gql`
    fragment NewElement on FormElement {
  body
  componentSettings
  exportId
  formId
  id
  isRequired
  position
  jumpToId
  type {
    componentName
    isHidden
    isInput
    isSingleUseOnly
    isSurveysOnly
    label
    supportedOperators
  }
  typeId
  backgroundColor
  secondaryColor
  backgroundImage
  layout
  backgroundPalette
  textVariant
  unsplashAuthorUrl
  unsplashAuthorName
  backgroundWidth
  backgroundHeight
}
    `;
var LogicRuleEditorFormElementFragmentDoc = import_client.gql`
    fragment LogicRuleEditorFormElement on FormElement {
  id
  body
  typeId
  formId
  jumpToId
  componentSettings
  exportId
  isRequired
  type {
    supportedOperators
    isInput
  }
}
    `;
var LogicRuleEditorRuleFragmentDoc = import_client.gql`
    fragment LogicRuleEditorRule on FormLogicRule {
  booleanOperator
  command
  formElementId
  id
  jumpToId
  position
  conditions {
    id
    operator
    ruleId
    subjectId
    value
  }
}
    `;
var NewRuleFragmentDoc = import_client.gql`
    fragment NewRule on FormLogicRule {
  booleanOperator
  command
  id
  jumpToId
  position
  formElementId
  conditions {
    id
    operator
    value
    subjectId
    ruleId
  }
}
    `;
var NewSurveyFragmentDoc = import_client.gql`
    fragment NewSurvey on Survey {
  id
  accessType
  invitedGroups {
    id
    name
  }
  isDisabled
  limitToSingleResponse
  name
  submittedResponseCount
  projectId
}
    `;
var NewGroupFragmentDoc = import_client.gql`
    fragment NewGroup on Group {
  id
  projectId
  name
}
    `;
var NewInviteEmailFragmentDoc = import_client.gql`
    fragment NewInviteEmail on InviteEmail {
  id
  toAddress
  createdAt
  status
  tokenExpiresAt
  error
  updatedAt
}
    `;
var NewLayerOptionsFragmentDoc = import_client.gql`
    fragment NewLayerOptions on OptionalBasemapLayer {
  options
}
    `;
var UpdateAlternateLanguageSettingsFragmentDoc = import_client.gql`
    fragment UpdateAlternateLanguageSettings on FormElement {
  alternateLanguageSettings
}
    `;
var UpdateComponentSettingsFragmentDoc = import_client.gql`
    fragment UpdateComponentSettings on FormElement {
  componentSettings
}
    `;
var UpdateBodyFragmentDoc = import_client.gql`
    fragment UpdateBody on FormElement {
  body
}
    `;
var BasemapDetailsFragmentDoc = import_client.gql`
    fragment BasemapDetails on Basemap {
  id
  attribution
  interactivitySettings {
    cursor
    id
    layers
    longTemplate
    shortTemplate
    type
  }
  labelsLayerId
  name
  optionalBasemapLayers {
    basemapId
    id
    defaultVisibility
    description
    options
    groupType
    layers
    metadata
    name
  }
  description
  projectId
  terrainExaggeration
  terrainMaxZoom
  terrainOptional
  terrainTileSize
  terrainUrl
  terrainVisibilityDefault
  thumbnail
  tileSize
  type
  url
}
    `;
var SurveyListDetailsFragmentDoc = import_client.gql`
    fragment SurveyListDetails on Survey {
  id
  accessType
  showProgress
  invitedGroups {
    id
    name
  }
  isDisabled
  limitToSingleResponse
  name
  submittedResponseCount
  practiceResponseCount
  projectId
  isTemplate
  showFacilitationOption
  supportedLanguages
}
    `;
var AddFormElementTypeDetailsFragmentDoc = import_client.gql`
    fragment AddFormElementTypeDetails on FormElementType {
  componentName
  isHidden
  isInput
  isSingleUseOnly
  isSurveysOnly
  label
  supportedOperators
  isSpatial
  allowedLayouts
}
    `;
var FormElementDetailsFragmentDoc = import_client.gql`
    fragment FormElementDetails on FormElement {
  body
  componentSettings
  alternateLanguageSettings
  exportId
  formId
  id
  isRequired
  position
  jumpToId
  type {
    ...AddFormElementTypeDetails
  }
  isInput
  typeId
  backgroundColor
  secondaryColor
  backgroundImage
  layout
  backgroundPalette
  textVariant
  unsplashAuthorUrl
  unsplashAuthorName
  backgroundWidth
  backgroundHeight
  subordinateTo
}
    ${AddFormElementTypeDetailsFragmentDoc}`;
var LogicRuleDetailsFragmentDoc = import_client.gql`
    fragment LogicRuleDetails on FormLogicRule {
  booleanOperator
  command
  id
  jumpToId
  position
  formElementId
  conditions {
    id
    operator
    value
    subjectId
    ruleId
  }
}
    `;
var SketchClassDetailsFragmentDoc = import_client.gql`
    fragment SketchClassDetails on SketchClass {
  id
  mapboxGlStyle
  formElementId
  geometryType
  geoprocessingClientName
  geoprocessingClientUrl
  geoprocessingProjectUrl
  allowMulti
  form {
    formElements {
      ...FormElementDetails
    }
    id
    logicRules {
      ...LogicRuleDetails
    }
  }
}
    ${FormElementDetailsFragmentDoc}
${LogicRuleDetailsFragmentDoc}`;
var FormElementFullDetailsFragmentDoc = import_client.gql`
    fragment FormElementFullDetails on FormElement {
  ...FormElementDetails
  sketchClass {
    ...SketchClassDetails
  }
}
    ${FormElementDetailsFragmentDoc}
${SketchClassDetailsFragmentDoc}`;
var SurveyAppRuleFragmentDoc = import_client.gql`
    fragment SurveyAppRule on FormLogicRule {
  booleanOperator
  command
  conditions {
    id
    operator
    ruleId
    subjectId
    value
  }
  formElementId
  id
  jumpToId
  position
}
    `;
var SurveyAppFormElementFragmentDoc = import_client.gql`
    fragment SurveyAppFormElement on FormElement {
  id
  componentSettings
  alternateLanguageSettings
  body
  isRequired
  position
  typeId
  formId
  type {
    componentName
    isInput
    isSingleUseOnly
    isSurveysOnly
    label
    isSpatial
    allowedLayouts
    supportedOperators
    isHidden
  }
  sketchClass {
    ...SketchClassDetails
  }
  backgroundColor
  secondaryColor
  backgroundImage
  layout
  textVariant
  unsplashAuthorName
  unsplashAuthorUrl
  backgroundWidth
  backgroundHeight
  jumpToId
  subordinateTo
}
    ${SketchClassDetailsFragmentDoc}`;
var SurveyAppSurveyFragmentDoc = import_client.gql`
    fragment SurveyAppSurvey on Survey {
  id
  name
  accessType
  isDisabled
  showProgress
  showFacilitationOption
  supportedLanguages
  form {
    id
    logicRules {
      ...SurveyAppRule
    }
    formElements {
      ...SurveyAppFormElement
    }
  }
}
    ${SurveyAppRuleFragmentDoc}
${SurveyAppFormElementFragmentDoc}`;
var ParticipantListDetailsFragmentDoc = import_client.gql`
    fragment ParticipantListDetails on User {
  id
  bannedFromForums
  isAdmin
  profile {
    email
    fullname
    nickname
    picture
  }
  groups {
    id
    name
  }
  canonicalEmail
}
    `;
var UserListDetailsFragmentDoc = import_client.gql`
    fragment UserListDetails on User {
  id
  isAdmin
  canonicalEmail
  bannedFromForums
  groups {
    name
    id
  }
  onboarded
  participationStatus
  profile {
    email
    fullname
    nickname
    picture
  }
}
    `;
var InviteDetailsFragmentDoc = import_client.gql`
    fragment InviteDetails on ProjectInvite {
  createdAt
  email
  fullname
  groups {
    id
    name
  }
  id
  status
  makeAdmin
  wasUsed
}
    `;
var InviteEmailDetailsFragmentDoc = import_client.gql`
    fragment InviteEmailDetails on InviteEmail {
  id
  toAddress
  createdAt
  status
  tokenExpiresAt
  error
  updatedAt
}
    `;
var ProjectBucketSettingDocument = import_client.gql`
    query ProjectBucketSetting($slug: String!) {
  projectBySlug(slug: $slug) {
    __typename
    id
    dataSourcesBucket {
      url
      region
      name
      location {
        geojson
      }
    }
  }
  dataSourcesBucketsConnection {
    nodes {
      url
      name
      region
      location {
        geojson
      }
    }
  }
}
    `;
var UpdateProjectStorageBucketDocument = import_client.gql`
    mutation UpdateProjectStorageBucket($slug: String!, $bucket: String!) {
  updateProjectBySlug(input: {slug: $slug, patch: {dataSourcesBucketId: $bucket}}) {
    clientMutationId
    project {
      __typename
      id
      dataSourcesBucket {
        url
        region
        name
      }
    }
  }
}
    `;
var GetAclDocument = import_client.gql`
    query GetAcl($nodeId: ID!) {
  aclByNodeId(nodeId: $nodeId) {
    id
    nodeId
    type
    groups {
      id
      name
      memberCount
    }
  }
}
    `;
var UpdateAclTypeDocument = import_client.gql`
    mutation UpdateAclType($nodeId: ID!, $type: AccessControlListType!) {
  updateAclByNodeId(input: {nodeId: $nodeId, patch: {type: $type}}) {
    acl {
      id
      nodeId
      type
    }
  }
}
    `;
var AddGroupToAclDocument = import_client.gql`
    mutation AddGroupToAcl($id: Int!, $groupId: Int!) {
  addGroupToAcl(input: {aclId: $id, groupId: $groupId}) {
    acl {
      groups {
        id
        name
      }
    }
  }
}
    `;
var RemoveGroupFromAclDocument = import_client.gql`
    mutation RemoveGroupFromAcl($id: Int!, $groupId: Int!) {
  removeGroupFromAcl(input: {aclId: $id, groupId: $groupId}) {
    acl {
      groups {
        id
        name
      }
    }
  }
}
    `;
var GroupsDocument = import_client.gql`
    query Groups($projectSlug: String!) {
  projectBySlug(slug: $projectSlug) {
    id
    groups {
      id
      name
      memberCount
    }
  }
}
    `;
var CreateTableOfContentsItemDocument = import_client.gql`
    mutation CreateTableOfContentsItem($title: String!, $stableId: String!, $projectId: Int!, $isFolder: Boolean!, $parentStableId: String, $metadata: JSON, $bounds: [BigFloat], $dataLayerId: Int) {
  createTableOfContentsItem(
    input: {tableOfContentsItem: {title: $title, stableId: $stableId, projectId: $projectId, parentStableId: $parentStableId, metadata: $metadata, bounds: $bounds, dataLayerId: $dataLayerId, isFolder: $isFolder}}
  ) {
    tableOfContentsItem {
      id
      title
      stableId
      projectId
      parentStableId
      isClickOffOnly
      isDraft
      isFolder
      metadata
      bounds
      dataLayerId
    }
  }
}
    `;
var CreateArcGisDynamicDataSourceDocument = import_client.gql`
    mutation CreateArcGISDynamicDataSource($projectId: Int!, $url: String!, $attribution: String, $bounds: [BigFloat], $queryParameters: JSON) {
  createDataSource(
    input: {dataSource: {projectId: $projectId, type: ARCGIS_VECTOR, url: $url, attribution: $attribution, bounds: $bounds, queryParameters: $queryParameters}}
  ) {
    dataSource {
      id
      projectId
      type
      url
    }
  }
}
    `;
var CreateArcGisImageSourceDocument = import_client.gql`
    mutation CreateArcGISImageSource($projectId: Int!, $url: String!, $attribution: String, $bounds: [BigFloat], $queryParameters: JSON, $enableHighDPI: Boolean, $supportsDynamicLayers: Boolean!) {
  createDataSource(
    input: {dataSource: {projectId: $projectId, type: ARCGIS_DYNAMIC_MAPSERVER, url: $url, attribution: $attribution, bounds: $bounds, queryParameters: $queryParameters, useDevicePixelRatio: $enableHighDPI, supportsDynamicLayers: $supportsDynamicLayers}}
  ) {
    dataSource {
      id
      url
    }
  }
}
    `;
var CreateSeaSketchVectorSourceDocument = import_client.gql`
    mutation CreateSeaSketchVectorSource($projectId: Int!, $attribution: String, $bounds: [BigFloat]!, $byteLength: Int!, $originalSourceUrl: String, $importType: DataSourceImportTypes!, $enhancedSecurity: Boolean!) {
  createDataSource(
    input: {dataSource: {projectId: $projectId, type: SEASKETCH_VECTOR, attribution: $attribution, bounds: $bounds, byteLength: $byteLength, originalSourceUrl: $originalSourceUrl, importType: $importType, enhancedSecurity: $enhancedSecurity}}
  ) {
    dataSource {
      id
      projectId
      type
      url
      presignedUploadUrl
      bucketId
      enhancedSecurity
      objectKey
    }
  }
}
    `;
var CreateDataLayerDocument = import_client.gql`
    mutation CreateDataLayer($projectId: Int!, $dataSourceId: Int!, $mapboxGlStyles: JSON, $renderUnder: RenderUnderType, $sublayer: String) {
  createDataLayer(
    input: {dataLayer: {projectId: $projectId, dataSourceId: $dataSourceId, mapboxGlStyles: $mapboxGlStyles, renderUnder: $renderUnder, sublayer: $sublayer}}
  ) {
    dataLayer {
      id
      dataSourceId
      zIndex
      interactivitySettings {
        cursor
        id
        longTemplate
        shortTemplate
        type
      }
    }
  }
}
    `;
var GetOrCreateSpriteDocument = import_client.gql`
    mutation GetOrCreateSprite($height: Int!, $width: Int!, $pixelRatio: Int!, $projectId: Int!, $smallestImage: Upload!) {
  getOrCreateSprite(
    height: $height
    pixelRatio: $pixelRatio
    projectId: $projectId
    smallestImage: $smallestImage
    width: $width
  ) {
    id
    md5
    projectId
    type
    spriteImages {
      spriteId
      height
      pixelRatio
      url
      width
    }
  }
}
    `;
var AddImageToSpriteDocument = import_client.gql`
    mutation AddImageToSprite($spriteId: Int!, $width: Int!, $height: Int!, $pixelRatio: Int!, $image: Upload!) {
  addImageToSprite(
    height: $height
    width: $width
    pixelRatio: $pixelRatio
    spriteId: $spriteId
    image: $image
  ) {
    id
    md5
    projectId
    type
    spriteImages {
      spriteId
      height
      pixelRatio
      url
      width
    }
  }
}
    `;
var VerifyProjectInviteDocument = import_client.gql`
    query VerifyProjectInvite($token: String!) {
  verifyProjectInvite(token: $token) {
    claims {
      admin
      email
      fullname
      inviteId
      projectId
      wasUsed
      projectSlug
    }
    error
    existingAccount
  }
}
    `;
var ConfirmProjectInviteDocument = import_client.gql`
    mutation ConfirmProjectInvite($token: String!) {
  confirmProjectInvite(token: $token) {
    admin
    email
    fullname
    inviteId
    projectId
    projectName
    wasUsed
    projectSlug
  }
}
    `;
var ResendEmailVerificationDocument = import_client.gql`
    mutation ResendEmailVerification {
  resendVerificationEmail {
    success
    error
  }
}
    `;
var RequestInviteOnlyProjectAccessDocument = import_client.gql`
    mutation RequestInviteOnlyProjectAccess($projectId: Int!) {
  joinProject(input: {projectId: $projectId}) {
    clientMutationId
  }
}
    `;
var GetBasemapsDocument = import_client.gql`
    query GetBasemaps($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    basemaps {
      ...BasemapDetails
    }
  }
}
    ${BasemapDetailsFragmentDoc}`;
var CreateBasemapDocument = import_client.gql`
    mutation CreateBasemap($projectId: Int, $name: String!, $thumbnail: Upload!, $tileSize: Int, $type: BasemapType!, $url: String!) {
  createBasemap(
    input: {basemap: {projectId: $projectId, name: $name, thumbnail: $thumbnail, tileSize: $tileSize, type: $type, url: $url}}
  ) {
    basemap {
      id
      attribution
      interactivitySettings {
        cursor
        id
        layers
        longTemplate
        shortTemplate
        type
      }
      labelsLayerId
      name
      optionalBasemapLayers {
        basemapId
        id
        defaultVisibility
        description
        options
        groupType
        layers
        metadata
        name
      }
      description
      projectId
      terrainExaggeration
      terrainMaxZoom
      terrainOptional
      terrainTileSize
      terrainUrl
      terrainVisibilityDefault
      thumbnail
      tileSize
      type
      url
    }
  }
}
    `;
var GetBasemapDocument = import_client.gql`
    query GetBasemap($id: Int!) {
  basemap(id: $id) {
    id
    attribution
    interactivitySettings {
      cursor
      id
      layers
      longTemplate
      shortTemplate
      type
    }
    description
    labelsLayerId
    name
    optionalBasemapLayers {
      basemapId
      defaultVisibility
      description
      options
      groupType
      id
      layers
      metadata
      name
    }
    projectId
    terrainExaggeration
    terrainMaxZoom
    terrainOptional
    terrainTileSize
    terrainUrl
    terrainVisibilityDefault
    thumbnail
    tileSize
    type
    url
  }
}
    `;
var UpdateBasemapDocument = import_client.gql`
    mutation UpdateBasemap($id: Int!, $name: String) {
  updateBasemap(input: {id: $id, patch: {name: $name}}) {
    basemap {
      name
      id
    }
  }
}
    `;
var UpdateBasemapUrlDocument = import_client.gql`
    mutation UpdateBasemapUrl($id: Int!, $url: String!) {
  updateBasemap(input: {id: $id, patch: {url: $url}}) {
    basemap {
      url
      id
    }
  }
}
    `;
var UpdateBasemapLabelsLayerDocument = import_client.gql`
    mutation UpdateBasemapLabelsLayer($id: Int!, $layer: String) {
  updateBasemap(input: {id: $id, patch: {labelsLayerId: $layer}}) {
    basemap {
      id
      labelsLayerId
    }
  }
}
    `;
var Toggle3dTerrainDocument = import_client.gql`
    mutation Toggle3dTerrain($id: Int!, $terrainUrl: String) {
  updateBasemap(input: {id: $id, patch: {terrainUrl: $terrainUrl}}) {
    basemap {
      id
      terrainUrl
    }
  }
}
    `;
var Set3dTerrainDocument = import_client.gql`
    mutation Set3dTerrain($id: Int!, $terrainUrl: String, $terrainOptional: Boolean, $terrainVisibilityDefault: Boolean) {
  updateBasemap(
    input: {id: $id, patch: {terrainUrl: $terrainUrl, terrainOptional: $terrainOptional, terrainVisibilityDefault: $terrainVisibilityDefault}}
  ) {
    basemap {
      id
      terrainUrl
      terrainVisibilityDefault
      terrainOptional
    }
  }
}
    `;
var UpdateTerrainExaggerationDocument = import_client.gql`
    mutation UpdateTerrainExaggeration($id: Int!, $terrainExaggeration: BigFloat!) {
  updateBasemap(
    input: {id: $id, patch: {terrainExaggeration: $terrainExaggeration}}
  ) {
    basemap {
      id
      terrainExaggeration
    }
  }
}
    `;
var DeleteBasemapDocument = import_client.gql`
    mutation DeleteBasemap($id: Int!) {
  deleteBasemap(input: {id: $id}) {
    basemap {
      id
    }
  }
}
    `;
var OptionalLayerDocument = import_client.gql`
    query OptionalLayer($id: Int!) {
  optionalBasemapLayer(id: $id) {
    id
    basemapId
    defaultVisibility
    description
    options
    groupType
    layers
    metadata
    name
  }
}
    `;
var UpdateOptionalLayerNameDocument = import_client.gql`
    mutation UpdateOptionalLayerName($id: Int!, $name: String!) {
  updateOptionalBasemapLayer(input: {id: $id, patch: {name: $name}}) {
    optionalBasemapLayer {
      id
      name
    }
  }
}
    `;
var CreateOptionalLayerDocument = import_client.gql`
    mutation CreateOptionalLayer($name: String!, $basemapId: Int!, $groupType: OptionalBasemapLayersGroupType, $options: JSON) {
  createOptionalBasemapLayer(
    input: {optionalBasemapLayer: {name: $name, basemapId: $basemapId, groupType: $groupType, options: $options}}
  ) {
    optionalBasemapLayer {
      id
      basemapId
      defaultVisibility
      description
      options
      groupType
      layers
      metadata
      name
    }
  }
}
    `;
var UpdateOptionalLayerDocument = import_client.gql`
    mutation UpdateOptionalLayer($id: Int!, $name: String, $description: String, $defaultVisibility: Boolean, $metadata: JSON) {
  updateOptionalBasemapLayer(
    input: {id: $id, patch: {name: $name, description: $description, defaultVisibility: $defaultVisibility, metadata: $metadata}}
  ) {
    optionalBasemapLayer {
      name
      description
      id
      defaultVisibility
      metadata
    }
  }
}
    `;
var DeleteOptionalLayerDocument = import_client.gql`
    mutation DeleteOptionalLayer($id: Int!) {
  deleteOptionalBasemapLayer(input: {id: $id}) {
    optionalBasemapLayer {
      id
    }
  }
}
    `;
var UpdateOptionalBasemapLayerLayerListDocument = import_client.gql`
    mutation UpdateOptionalBasemapLayerLayerList($id: Int!, $layers: [String]) {
  updateOptionalBasemapLayer(input: {id: $id, patch: {layers: $layers}}) {
    optionalBasemapLayer {
      id
      layers
    }
  }
}
    `;
var UpdateOptionalBasemapLayerOptionsDocument = import_client.gql`
    mutation UpdateOptionalBasemapLayerOptions($id: Int!, $options: JSON!) {
  updateOptionalBasemapLayer(input: {id: $id, patch: {options: $options}}) {
    optionalBasemapLayer {
      id
      options
    }
  }
}
    `;
var GetOptionalBasemapLayerDocument = import_client.gql`
    query GetOptionalBasemapLayer($id: Int!) {
  optionalBasemapLayer(id: $id) {
    id
    basemapId
    name
    description
    defaultVisibility
    groupType
    layers
    metadata
    options
  }
}
    `;
var GetOptionalBasemapLayerMetadataDocument = import_client.gql`
    query GetOptionalBasemapLayerMetadata($id: Int!) {
  optionalBasemapLayer(id: $id) {
    id
    metadata
  }
}
    `;
var UpdateOptionalBasemapLayerMetadataDocument = import_client.gql`
    mutation UpdateOptionalBasemapLayerMetadata($id: Int!, $metadata: JSON) {
  updateOptionalBasemapLayer(input: {id: $id, patch: {metadata: $metadata}}) {
    optionalBasemapLayer {
      id
      metadata
    }
  }
}
    `;
var UpdateInteractivitySettingsLayersDocument = import_client.gql`
    mutation UpdateInteractivitySettingsLayers($id: Int!, $layers: [String]) {
  updateInteractivitySetting(input: {id: $id, patch: {layers: $layers}}) {
    interactivitySetting {
      layers
      id
    }
  }
}
    `;
var CreateProjectDocument = import_client.gql`
    mutation CreateProject($name: String!, $slug: String!) {
  createProject(input: {name: $name, slug: $slug}) {
    project {
      id
      url
      slug
    }
  }
}
    `;
var CurrentProjectMetadataDocument = import_client.gql`
    query CurrentProjectMetadata {
  currentProject {
    id
    slug
    url
    name
    description
    logoLink
    logoUrl
    accessControl
    sessionIsAdmin
    isFeatured
  }
  currentProjectPublicDetails {
    id
    accessControl
    slug
    name
    logoUrl
    supportEmail
  }
  currentProjectAccessStatus
  me {
    id
    profile {
      fullname
      nickname
      email
      picture
      bio
      affiliations
    }
  }
}
    `;
var DraftTableOfContentsDocument = import_client.gql`
    query DraftTableOfContents($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    draftTableOfContentsItems {
      id
      dataLayerId
      title
      acl {
        id
        type
      }
      isClickOffOnly
      isFolder
      stableId
      parentStableId
      showRadioChildren
      bounds
      sortIndex
      hideChildren
      enableDownload
    }
  }
}
    `;
var LayersAndSourcesForItemsDocument = import_client.gql`
    query layersAndSourcesForItems($slug: String!, $tableOfContentsItemIds: [Int]!) {
  projectBySlug(slug: $slug) {
    id
    dataSourcesForItems(tableOfContentsItemIds: $tableOfContentsItemIds) {
      attribution
      bounds
      bucketId
      buffer
      byteLength
      cluster
      clusterMaxZoom
      clusterProperties
      clusterRadius
      coordinates
      createdAt
      encoding
      enhancedSecurity
      id
      importType
      lineMetrics
      maxzoom
      minzoom
      objectKey
      originalSourceUrl
      queryParameters
      scheme
      tiles
      tileSize
      tolerance
      type
      url
      urls
      useDevicePixelRatio
      supportsDynamicLayers
    }
    dataLayersForItems(tableOfContentsItemIds: $tableOfContentsItemIds) {
      interactivitySettings {
        id
        cursor
        longTemplate
        shortTemplate
        type
      }
      sprites {
        id
        spriteImages {
          pixelRatio
          height
          width
          url
        }
        type
      }
      zIndex
      dataSourceId
      id
      mapboxGlStyles
      renderUnder
      sourceLayer
      sublayer
    }
  }
}
    `;
var CreateFolderDocument = import_client.gql`
    mutation CreateFolder($title: String!, $stableId: String!, $projectId: Int!, $parentStableId: String, $isClickOffOnly: Boolean, $showRadioChildren: Boolean, $hideChildren: Boolean) {
  createTableOfContentsItem(
    input: {tableOfContentsItem: {title: $title, stableId: $stableId, projectId: $projectId, parentStableId: $parentStableId, isFolder: true, isClickOffOnly: $isClickOffOnly, showRadioChildren: $showRadioChildren, hideChildren: $hideChildren}}
  ) {
    tableOfContentsItem {
      id
      title
      stableId
      projectId
      parentStableId
      isClickOffOnly
      isDraft
      isFolder
      showRadioChildren
      isClickOffOnly
      sortIndex
      hideChildren
      enableDownload
    }
  }
}
    `;
var DeleteBranchDocument = import_client.gql`
    mutation DeleteBranch($id: Int!) {
  deleteTableOfContentsBranch(input: {tableOfContentsItemId: $id}) {
    clientMutationId
  }
}
    `;
var UpdateTableOfContentsItemChildrenDocument = import_client.gql`
    mutation UpdateTableOfContentsItemChildren($id: Int, $childIds: [Int]!) {
  updateTableOfContentsItemChildren(input: {parentId: $id, childIds: $childIds}) {
    tableOfContentsItems {
      id
      sortIndex
      parentStableId
    }
  }
}
    `;
var GetFolderDocument = import_client.gql`
    query GetFolder($id: Int!) {
  tableOfContentsItem(id: $id) {
    id
    bounds
    isClickOffOnly
    showRadioChildren
    title
    hideChildren
  }
}
    `;
var UpdateFolderDocument = import_client.gql`
    mutation UpdateFolder($id: Int!, $bounds: [BigFloat], $isClickOffOnly: Boolean, $showRadioChildren: Boolean, $title: String, $hideChildren: Boolean) {
  updateTableOfContentsItem(
    input: {id: $id, patch: {bounds: $bounds, isClickOffOnly: $isClickOffOnly, showRadioChildren: $showRadioChildren, title: $title, hideChildren: $hideChildren}}
  ) {
    tableOfContentsItem {
      id
      bounds
      isClickOffOnly
      showRadioChildren
      hideChildren
      title
    }
  }
}
    `;
var GetLayerItemDocument = import_client.gql`
    query GetLayerItem($id: Int!) {
  tableOfContentsItem(id: $id) {
    id
    acl {
      nodeId
      id
      type
      groups {
        id
        name
      }
    }
    bounds
    dataLayerId
    metadata
    parentStableId
    projectId
    stableId
    title
    enableDownload
    dataLayer {
      id
      zIndex
      mapboxGlStyles
      interactivitySettingsId
      renderUnder
      sourceLayer
      sublayer
      sprites {
        id
        spriteImages {
          pixelRatio
          height
          width
          url
        }
        type
      }
      dataSourceId
      dataSource {
        id
        attribution
        bounds
        bucketId
        buffer
        byteLength
        cluster
        clusterMaxZoom
        clusterProperties
        clusterRadius
        coordinates
        createdAt
        encoding
        enhancedSecurity
        generateId
        importType
        lineMetrics
        maxzoom
        minzoom
        objectKey
        originalSourceUrl
        promoteId
        queryParameters
        scheme
        tiles
        tileSize
        tolerance
        type
        url
        urls
        useDevicePixelRatio
        supportsDynamicLayers
      }
    }
  }
}
    `;
var UpdateTableOfContentsItemDocument = import_client.gql`
    mutation UpdateTableOfContentsItem($id: Int!, $title: String, $bounds: [BigFloat], $metadata: JSON) {
  updateTableOfContentsItem(
    input: {id: $id, patch: {title: $title, bounds: $bounds, metadata: $metadata}}
  ) {
    tableOfContentsItem {
      id
      bounds
      metadata
      title
    }
  }
}
    `;
var UpdateEnableDownloadDocument = import_client.gql`
    mutation UpdateEnableDownload($id: Int!, $enableDownload: Boolean) {
  updateTableOfContentsItem(
    input: {id: $id, patch: {enableDownload: $enableDownload}}
  ) {
    tableOfContentsItem {
      id
      enableDownload
    }
  }
}
    `;
var UpdateLayerDocument = import_client.gql`
    mutation UpdateLayer($id: Int!, $renderUnder: RenderUnderType, $mapboxGlStyles: JSON, $sublayer: String) {
  updateDataLayer(
    input: {id: $id, patch: {renderUnder: $renderUnder, mapboxGlStyles: $mapboxGlStyles, sublayer: $sublayer}}
  ) {
    dataLayer {
      id
      zIndex
      renderUnder
      mapboxGlStyles
      sublayer
      sprites {
        id
        spriteImages {
          pixelRatio
          height
          width
          url
        }
        type
      }
    }
  }
}
    `;
var UpdateDataSourceDocument = import_client.gql`
    mutation UpdateDataSource($id: Int!, $attribution: String) {
  updateDataSource(input: {id: $id, patch: {attribution: $attribution}}) {
    dataSource {
      id
      attribution
      bounds
      bucketId
      buffer
      byteLength
      cluster
      clusterMaxZoom
      clusterProperties
      clusterRadius
      coordinates
      createdAt
      encoding
      enhancedSecurity
      generateId
      importType
      lineMetrics
      maxzoom
      minzoom
      objectKey
      originalSourceUrl
      promoteId
      queryParameters
      scheme
      tiles
      tileSize
      tolerance
      type
      url
      urls
      useDevicePixelRatio
      supportsDynamicLayers
    }
  }
}
    `;
var InteractivitySettingsForLayerDocument = import_client.gql`
    query InteractivitySettingsForLayer($layerId: Int!) {
  dataLayer(id: $layerId) {
    id
    sourceLayer
    interactivitySettings {
      cursor
      id
      longTemplate
      shortTemplate
      type
    }
  }
}
    `;
var UpdateInteractivitySettingsDocument = import_client.gql`
    mutation UpdateInteractivitySettings($id: Int!, $type: InteractivityType, $cursor: CursorType, $longTemplate: String, $shortTemplate: String) {
  updateInteractivitySetting(
    input: {id: $id, patch: {type: $type, cursor: $cursor, longTemplate: $longTemplate, shortTemplate: $shortTemplate}}
  ) {
    interactivitySetting {
      id
      type
      cursor
      longTemplate
      shortTemplate
    }
  }
}
    `;
var DataSourceUrlPropertiesDocument = import_client.gql`
    query DataSourceUrlProperties($id: Int!) {
  dataSource(id: $id) {
    id
    type
    bucketId
    objectKey
    url
    originalSourceUrl
    queryParameters
  }
}
    `;
var UpdateZIndexesDocument = import_client.gql`
    mutation UpdateZIndexes($dataLayerIds: [Int]!) {
  updateZIndexes(input: {dataLayerIds: $dataLayerIds}) {
    dataLayers {
      id
      zIndex
    }
  }
}
    `;
var UpdateRenderUnderTypeDocument = import_client.gql`
    mutation UpdateRenderUnderType($layerId: Int!, $renderUnder: RenderUnderType) {
  updateDataLayer(input: {id: $layerId, patch: {renderUnder: $renderUnder}}) {
    dataLayer {
      id
      renderUnder
    }
  }
}
    `;
var UpdateQueryParametersDocument = import_client.gql`
    mutation UpdateQueryParameters($sourceId: Int!, $queryParameters: JSON!) {
  updateDataSource(
    input: {id: $sourceId, patch: {queryParameters: $queryParameters}}
  ) {
    dataSource {
      id
      queryParameters
    }
  }
}
    `;
var UpdateEnableHighDpiRequestsDocument = import_client.gql`
    mutation UpdateEnableHighDPIRequests($sourceId: Int!, $useDevicePixelRatio: Boolean!) {
  updateDataSource(
    input: {id: $sourceId, patch: {useDevicePixelRatio: $useDevicePixelRatio}}
  ) {
    dataSource {
      id
      useDevicePixelRatio
    }
  }
}
    `;
var GetMetadataDocument = import_client.gql`
    query GetMetadata($itemId: Int!) {
  tableOfContentsItem(id: $itemId) {
    id
    metadata
  }
}
    `;
var UpdateMetadataDocument = import_client.gql`
    mutation UpdateMetadata($itemId: Int!, $metadata: JSON!) {
  updateTableOfContentsItem(input: {id: $itemId, patch: {metadata: $metadata}}) {
    tableOfContentsItem {
      id
      metadata
    }
  }
}
    `;
var ProjectHostingQuotaDocument = import_client.gql`
    query ProjectHostingQuota($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    dataHostingQuota
    dataHostingQuotaUsed
  }
}
    `;
var InteractivitySettingsByIdDocument = import_client.gql`
    query InteractivitySettingsById($id: Int!) {
  interactivitySetting(id: $id) {
    cursor
    id
    layers
    longTemplate
    shortTemplate
    type
  }
}
    `;
var PublishTableOfContentsDocument = import_client.gql`
    mutation PublishTableOfContents($projectId: Int!) {
  publishTableOfContents(input: {projectId: $projectId}) {
    tableOfContentsItems {
      id
    }
  }
}
    `;
var ProjectAccessControlSettingsDocument = import_client.gql`
    query ProjectAccessControlSettings($slug: String!) {
  projectBySlug(slug: $slug) {
    __typename
    id
    accessControl
    isListed
  }
}
    `;
var UpdateProjectAccessControlSettingsDocument = import_client.gql`
    mutation updateProjectAccessControlSettings($slug: String!, $accessControl: ProjectAccessControlSetting, $isListed: Boolean) {
  updateProjectBySlug(
    input: {slug: $slug, patch: {accessControl: $accessControl, isListed: $isListed}}
  ) {
    clientMutationId
    project {
      __typename
      id
      accessControl
      isListed
    }
  }
}
    `;
var ProjectRegionDocument = import_client.gql`
    query ProjectRegion($slug: String!) {
  projectBySlug(slug: $slug) {
    __typename
    id
    region {
      geojson
    }
  }
}
    `;
var UpdateProjectRegionDocument = import_client.gql`
    mutation UpdateProjectRegion($slug: String!, $region: GeoJSON!) {
  updateProjectBySlug(input: {slug: $slug, patch: {region: $region}}) {
    clientMutationId
    project {
      __typename
      id
      region {
        geojson
      }
    }
  }
}
    `;
var GetProjectBySlugDocument = import_client.gql`
    query GetProjectBySlug($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    name
  }
}
    `;
var ProjectSlugExistsDocument = import_client.gql`
    query ProjectSlugExists($slug: String!) {
  projectBySlug(slug: $slug) {
    id
  }
}
    `;
var PublishedTableOfContentsDocument = import_client.gql`
    query PublishedTableOfContents($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    tableOfContentsItems {
      id
      acl {
        id
        type
      }
      bounds
      dataLayerId
      enableDownload
      hideChildren
      isClickOffOnly
      isFolder
      parentStableId
      showRadioChildren
      sortIndex
      stableId
      title
    }
  }
}
    `;
var SimpleProjectListDocument = import_client.gql`
    query SimpleProjectList($first: Int, $offset: Int) {
  projectsConnection(first: $first, offset: $offset) {
    nodes {
      id
      name
      slug
      description
      url
    }
  }
}
    `;
var SurveysDocument = import_client.gql`
    query Surveys($projectId: Int!) {
  project(id: $projectId) {
    id
    surveys {
      ...SurveyListDetails
    }
  }
}
    ${SurveyListDetailsFragmentDoc}`;
var CreateSurveyDocument = import_client.gql`
    mutation CreateSurvey($name: String!, $projectId: Int!, $templateId: Int) {
  makeSurvey(input: {projectId: $projectId, name: $name, templateId: $templateId}) {
    survey {
      ...SurveyListDetails
    }
  }
}
    ${SurveyListDetailsFragmentDoc}`;
var SurveyByIdDocument = import_client.gql`
    query SurveyById($id: Int!) {
  survey(id: $id) {
    ...SurveyListDetails
  }
}
    ${SurveyListDetailsFragmentDoc}`;
var SurveyFormEditorDetailsDocument = import_client.gql`
    query SurveyFormEditorDetails($id: Int!, $slug: String!) {
  projectBySlug(slug: $slug) {
    name
  }
  formElementTypes {
    ...AddFormElementTypeDetails
  }
  survey(id: $id) {
    ...SurveyListDetails
    form {
      id
      isTemplate
      surveyId
      templateName
      templateType
      formElements {
        ...FormElementFullDetails
      }
      logicRules {
        ...LogicRuleDetails
      }
    }
  }
  currentProject {
    name
    url
    region {
      geojson
    }
  }
}
    ${AddFormElementTypeDetailsFragmentDoc}
${SurveyListDetailsFragmentDoc}
${FormElementFullDetailsFragmentDoc}
${LogicRuleDetailsFragmentDoc}`;
var FormElementTypesDocument = import_client.gql`
    query FormElementTypes {
  formElementTypes {
    ...AddFormElementTypeDetails
  }
}
    ${AddFormElementTypeDetailsFragmentDoc}`;
var UpdateSurveyBaseSettingsDocument = import_client.gql`
    mutation UpdateSurveyBaseSettings($id: Int!, $showProgress: Boolean, $showFacilitationOption: Boolean, $supportedLanguages: [String]) {
  updateSurvey(
    input: {id: $id, patch: {showProgress: $showProgress, showFacilitationOption: $showFacilitationOption, supportedLanguages: $supportedLanguages}}
  ) {
    survey {
      id
      showProgress
      showFacilitationOption
      supportedLanguages
    }
  }
}
    `;
var UpdateFormElementSketchClassDocument = import_client.gql`
    mutation UpdateFormElementSketchClass($id: Int!, $geometryType: SketchGeometryType, $allowMulti: Boolean, $mapboxGlStyle: JSON, $geoprocessingClientName: String, $geoprocessingClientUrl: String, $geoprocessingProjectUrl: String) {
  updateSketchClass(
    input: {id: $id, patch: {geometryType: $geometryType, allowMulti: $allowMulti, mapboxGlStyle: $mapboxGlStyle, geoprocessingClientName: $geoprocessingClientName, geoprocessingClientUrl: $geoprocessingClientUrl, geoprocessingProjectUrl: $geoprocessingProjectUrl}}
  ) {
    sketchClass {
      id
      geometryType
      allowMulti
      mapboxGlStyle
      geoprocessingClientName
      geoprocessingClientUrl
      geoprocessingProjectUrl
    }
  }
}
    `;
var UpdateFormElementDocument = import_client.gql`
    mutation UpdateFormElement($id: Int!, $isRequired: Boolean, $body: JSON, $exportId: String, $componentSettings: JSON, $alternateLanguageSettings: JSON, $jumpToId: Int, $typeId: String) {
  updateFormElement(
    input: {id: $id, patch: {isRequired: $isRequired, body: $body, exportId: $exportId, componentSettings: $componentSettings, jumpToId: $jumpToId, typeId: $typeId, alternateLanguageSettings: $alternateLanguageSettings}}
  ) {
    formElement {
      id
      isRequired
      body
      exportId
      componentSettings
      alternateLanguageSettings
      jumpToId
      typeId
    }
  }
}
    `;
var UpdateComponentSettingsDocument = import_client.gql`
    mutation UpdateComponentSettings($id: Int!, $componentSettings: JSON) {
  updateFormElement(
    input: {id: $id, patch: {componentSettings: $componentSettings}}
  ) {
    formElement {
      id
      componentSettings
    }
  }
}
    `;
var UpdateAlternateLanguageSettingsDocument = import_client.gql`
    mutation UpdateAlternateLanguageSettings($id: Int!, $alternateLanguageSettings: JSON) {
  updateFormElement(
    input: {id: $id, patch: {alternateLanguageSettings: $alternateLanguageSettings}}
  ) {
    formElement {
      id
      alternateLanguageSettings
    }
  }
}
    `;
var UpdateFormElementBodyDocument = import_client.gql`
    mutation UpdateFormElementBody($id: Int!, $body: JSON!) {
  updateFormElement(input: {id: $id, patch: {body: $body}}) {
    formElement {
      id
      body
    }
  }
}
    `;
var UpdateFormElementOrderDocument = import_client.gql`
    mutation UpdateFormElementOrder($elementIds: [Int]) {
  setFormElementOrder(input: {elementIds: $elementIds}) {
    formElements {
      id
      position
    }
  }
}
    `;
var AddFormElementDocument = import_client.gql`
    mutation AddFormElement($body: JSON!, $componentSettings: JSON!, $formId: Int!, $componentType: String!, $position: Int, $exportId: String, $subordinateTo: Int, $isRequired: Boolean!) {
  createFormElement(
    input: {formElement: {body: $body, componentSettings: $componentSettings, formId: $formId, isRequired: $isRequired, typeId: $componentType, position: $position, exportId: $exportId, subordinateTo: $subordinateTo}}
  ) {
    formElement {
      ...FormElementFullDetails
    }
  }
}
    ${FormElementFullDetailsFragmentDoc}`;
var DeleteFormElementDocument = import_client.gql`
    mutation DeleteFormElement($id: Int!) {
  deleteFormElement(input: {id: $id}) {
    formElement {
      id
    }
  }
}
    `;
var UpdateFormDocument = import_client.gql`
    mutation UpdateForm($id: Int!, $isTemplate: Boolean, $templateName: String) {
  updateForm(
    input: {id: $id, patch: {isTemplate: $isTemplate, templateName: $templateName}}
  ) {
    form {
      id
      isTemplate
      templateName
    }
  }
}
    `;
var GetPhotosDocument = import_client.gql`
    query GetPhotos($query: String!) {
  getUnsplashPhotos(query: $query) {
    results {
      blur_hash
      color
      description
      height
      width
      id
      links {
        download_location
      }
      urls {
        full
        raw
        regular
        small
        thumb
      }
      user {
        id
        name
        username
        links {
          html
        }
      }
    }
  }
}
    `;
var UpdateFormElementBackgroundDocument = import_client.gql`
    mutation UpdateFormElementBackground($id: Int!, $backgroundColor: String, $secondaryColor: String, $backgroundPalette: [String], $textVariant: FormElementTextVariant, $layout: FormElementLayout) {
  updateFormElement(
    input: {id: $id, patch: {backgroundColor: $backgroundColor, secondaryColor: $secondaryColor, backgroundPalette: $backgroundPalette, textVariant: $textVariant, layout: $layout}}
  ) {
    formElement {
      id
      backgroundColor
      secondaryColor
      backgroundImage
      layout
      backgroundPalette
      textVariant
      unsplashAuthorName
      unsplashAuthorUrl
    }
  }
}
    `;
var SetFormElementBackgroundDocument = import_client.gql`
    mutation SetFormElementBackground($id: Int!, $backgroundColor: String!, $secondaryColor: String!, $backgroundUrl: String!, $downloadUrl: String!, $backgroundPalette: [String]!, $unsplashAuthorUrl: String!, $unsplashAuthorName: String!, $backgroundWidth: Int!, $backgroundHeight: Int!) {
  setFormElementBackground(
    backgroundColor: $backgroundColor
    secondaryColor: $secondaryColor
    backgroundPalette: $backgroundPalette
    backgroundUrl: $backgroundUrl
    downloadUrl: $downloadUrl
    id: $id
    unsplashAuthorName: $unsplashAuthorName
    unsplashAuthorUrl: $unsplashAuthorUrl
    backgroundHeight: $backgroundHeight
    backgroundWidth: $backgroundWidth
  ) {
    id
    backgroundColor
    secondaryColor
    backgroundImage
    backgroundPalette
    unsplashAuthorName
    unsplashAuthorUrl
    backgroundWidth
    backgroundHeight
  }
}
    `;
var ClearFormElementStyleDocument = import_client.gql`
    mutation clearFormElementStyle($id: Int!) {
  clearFormElementStyle(input: {formElementId: $id}) {
    formElement {
      id
      backgroundColor
      backgroundImage
      backgroundPalette
      unsplashAuthorName
      unsplashAuthorUrl
      textVariant
      secondaryColor
    }
  }
}
    `;
var CreateLogicRuleForSurveyDocument = import_client.gql`
    mutation createLogicRuleForSurvey($formElementId: Int!, $operator: FieldRuleOperator!, $jumpToId: Int!) {
  createSurveyJumpRule(
    input: {formElementId: $formElementId, booleanOperator: OR, jumpToId: $jumpToId, operator: $operator}
  ) {
    formLogicRule {
      id
      position
      booleanOperator
      command
      formElementId
      jumpToId
      conditions {
        id
        operator
        ruleId
        subjectId
        value
      }
    }
  }
}
    `;
var UpdateFormLogicRuleDocument = import_client.gql`
    mutation UpdateFormLogicRule($id: Int!, $jumpToId: Int, $booleanOperator: FormLogicOperator, $formElementId: Int) {
  updateFormLogicRule(
    input: {id: $id, patch: {jumpToId: $jumpToId, booleanOperator: $booleanOperator, formElementId: $formElementId}}
  ) {
    formLogicRule {
      id
      booleanOperator
      command
      jumpToId
      position
      formElementId
    }
  }
}
    `;
var UpdateLogicConditionDocument = import_client.gql`
    mutation UpdateLogicCondition($id: Int!, $operator: FieldRuleOperator, $value: JSON, $subjectId: Int) {
  updateFormLogicCondition(
    input: {id: $id, patch: {operator: $operator, value: $value, subjectId: $subjectId}}
  ) {
    formLogicCondition {
      id
      ruleId
      operator
      subjectId
      value
    }
  }
}
    `;
var DeleteLogicConditionDocument = import_client.gql`
    mutation DeleteLogicCondition($id: Int!) {
  deleteFormLogicCondition(input: {id: $id}) {
    formLogicCondition {
      id
      ruleId
    }
  }
}
    `;
var DeleteLogicRuleDocument = import_client.gql`
    mutation DeleteLogicRule($id: Int!) {
  deleteFormLogicRule(input: {id: $id}) {
    formLogicRule {
      id
      formElementId
    }
  }
}
    `;
var AddConditionDocument = import_client.gql`
    mutation AddCondition($operator: FieldRuleOperator!, $ruleId: Int!, $subjectId: Int!, $value: JSON) {
  createFormLogicCondition(
    input: {formLogicCondition: {operator: $operator, ruleId: $ruleId, subjectId: $subjectId, value: $value}}
  ) {
    formLogicCondition {
      id
      operator
      ruleId
      subjectId
      value
    }
  }
}
    `;
var UpdateSurveyDraftStatusDocument = import_client.gql`
    mutation UpdateSurveyDraftStatus($id: Int!, $isDisabled: Boolean!) {
  updateSurvey(input: {id: $id, patch: {isDisabled: $isDisabled}}) {
    survey {
      id
      isDisabled
    }
  }
}
    `;
var UploadConsentDocDocument = import_client.gql`
    mutation UploadConsentDoc($document: Upload!, $formElementId: Int!, $version: Int!) {
  uploadConsentDocument(
    document: $document
    formElementId: $formElementId
    version: $version
  ) {
    id
    componentSettings
  }
}
    `;
var SurveyResponsesDocument = import_client.gql`
    query SurveyResponses($surveyId: Int!) {
  survey(id: $surveyId) {
    form {
      formElements {
        ...FormElementDetails
      }
    }
    id
    practiceResponseCount
    submittedResponseCount
    surveyResponsesConnection {
      nodes {
        id
        surveyId
        bypassedDuplicateSubmissionControl
        updatedAt
        accountEmail
        userId
        createdAt
        data
        isDuplicateEntry
        isDuplicateIp
        isPractice
        isUnrecognizedUserAgent
      }
    }
  }
}
    ${FormElementDetailsFragmentDoc}`;
var SurveyMapDetailsDocument = import_client.gql`
    query SurveyMapDetails($surveyId: Int!) {
  survey(id: $surveyId) {
    form {
      formElements {
        ...FormElementDetails
      }
      id
    }
  }
}
    ${FormElementDetailsFragmentDoc}`;
var SurveyDocument = import_client.gql`
    query Survey($id: Int!) {
  me {
    isAdmin
    profile {
      email
      fullname
    }
  }
  currentProject {
    name
    url
    region {
      geojson
    }
  }
  survey(id: $id) {
    ...SurveyAppSurvey
  }
}
    ${SurveyAppSurveyFragmentDoc}`;
var CreateResponseDocument = import_client.gql`
    mutation CreateResponse($surveyId: Int!, $isDraft: Boolean!, $bypassedDuplicateSubmissionControl: Boolean!, $responseData: JSON!, $facilitated: Boolean!, $practice: Boolean!) {
  createSurveyResponse(
    input: {surveyId: $surveyId, draft: $isDraft, responseData: $responseData, bypassedSubmissionControl: $bypassedDuplicateSubmissionControl, facilitated: $facilitated, practice: $practice}
  ) {
    clientMutationId
    surveyResponse {
      id
    }
  }
}
    `;
var GetBasemapsAndRegionDocument = import_client.gql`
    query GetBasemapsAndRegion {
  currentProject {
    id
    basemaps {
      ...BasemapDetails
    }
    region {
      geojson
    }
  }
}
    ${BasemapDetailsFragmentDoc}`;
var UpdateProjectNameDocument = import_client.gql`
    mutation UpdateProjectName($name: String!, $slug: String!, $clientMutationId: String) {
  updateProjectBySlug(
    input: {slug: $slug, clientMutationId: $clientMutationId, patch: {name: $name}}
  ) {
    clientMutationId
    project {
      id
      name
    }
  }
}
    `;
var UpdateProjectSettingsDocument = import_client.gql`
    mutation UpdateProjectSettings($slug: String!, $clientMutationId: String, $name: String, $description: String, $logoUrl: Upload, $logoLink: String, $isFeatured: Boolean) {
  updateProjectBySlug(
    input: {slug: $slug, clientMutationId: $clientMutationId, patch: {name: $name, description: $description, logoUrl: $logoUrl, logoLink: $logoLink, isFeatured: $isFeatured}}
  ) {
    clientMutationId
    project {
      id
      name
      description
      logoUrl
      logoLink
    }
  }
}
    `;
var UserAdminCountsDocument = import_client.gql`
    query UserAdminCounts($slug: String!) {
  projectBySlug(slug: $slug) {
    id
    accessControl
    participantCount
    adminCount
    inviteCounts {
      count
      status
    }
    groups {
      id
      name
      memberCount
    }
    unapprovedParticipantCount
  }
}
    `;
var CreateGroupDocument = import_client.gql`
    mutation CreateGroup($projectId: Int!, $name: String!) {
  createGroup(input: {group: {name: $name, projectId: $projectId}}) {
    group {
      id
      name
      projectId
    }
  }
}
    `;
var ParticipantsDocument = import_client.gql`
    query Participants($slug: String!, $offset: Int, $first: Int) {
  root: projectBySlug(slug: $slug) {
    id
    participants(offset: $offset, first: $first) {
      ...ParticipantListDetails
    }
  }
}
    ${ParticipantListDetailsFragmentDoc}`;
var AdminsDocument = import_client.gql`
    query Admins($slug: String!, $offset: Int, $first: Int) {
  root: projectBySlug(slug: $slug) {
    id
    participants: admins(offset: $offset, first: $first) {
      ...ParticipantListDetails
    }
  }
}
    ${ParticipantListDetailsFragmentDoc}`;
var GroupMembersDocument = import_client.gql`
    query GroupMembers($groupId: Int!, $offset: Int, $first: Int) {
  root: group(id: $groupId) {
    participants: members(offset: $offset, first: $first) {
      ...ParticipantListDetails
    }
  }
}
    ${ParticipantListDetailsFragmentDoc}`;
var UserSettingsListsDocument = import_client.gql`
    query UserSettingsLists {
  currentProject {
    id
    groups {
      name
      id
    }
    invitesConnection {
      nodes {
        ...InviteDetails
      }
    }
    participants {
      ...UserListDetails
    }
    accessControl
  }
}
    ${InviteDetailsFragmentDoc}
${UserListDetailsFragmentDoc}`;
var UserInfoDocument = import_client.gql`
    query UserInfo($userId: Int!) {
  user(id: $userId) {
    id
    isAdmin
    canonicalEmail
    bannedFromForums
    emailNotificationPreference {
      unsubscribeAll
    }
    groups {
      name
      id
    }
    onboarded
    participationStatus
    profile {
      affiliations
      bio
      email
      fullname
      nickname
      picture
    }
  }
  currentProject {
    id
    groups {
      name
      id
    }
  }
}
    `;
var ToggleAdminAccessDocument = import_client.gql`
    mutation toggleAdminAccess($userId: Int!, $projectId: Int!) {
  toggleAdminAccess(input: {projectId: $projectId, userId: $userId}) {
    clientMutationId
    isAdmin: boolean
  }
}
    `;
var SetUserGroupsDocument = import_client.gql`
    mutation setUserGroups($userId: Int!, $projectId: Int!, $groupIds: [Int]!) {
  setUserGroups(
    input: {userId: $userId, projectId: $projectId, groups: $groupIds}
  ) {
    groupIds: integers
  }
}
    `;
var ToggleForumPostingBanDocument = import_client.gql`
    mutation toggleForumPostingBan($userId: Int!, $projectId: Int!) {
  toggleForumPostingBan(input: {userId: $userId, projectId: $projectId}) {
    isBanned: boolean
  }
}
    `;
var DeleteGroupDocument = import_client.gql`
    mutation deleteGroup($groupId: Int!) {
  deleteGroup(input: {id: $groupId}) {
    group {
      id
    }
  }
}
    `;
var CreateProjectInvitesDocument = import_client.gql`
    mutation createProjectInvites($projectId: Int!, $makeAdmin: Boolean!, $groupNames: [String]!, $userDetails: [ProjectInviteOptionInput]!, $sendEmailNow: Boolean!) {
  createProjectInvites(
    input: {projectId: $projectId, makeAdmin: $makeAdmin, groupNames: $groupNames, projectInviteOptions: $userDetails, sendEmailNow: $sendEmailNow}
  ) {
    projectInvites {
      ...InviteDetails
    }
  }
}
    ${InviteDetailsFragmentDoc}`;
var ProjectInvitesDocument = import_client.gql`
    query ProjectInvites($projectId: Int!, $status: [InviteStatus], $orderBy: InviteOrderBy, $cursor: Cursor, $limit: Int) {
  project(id: $projectId) {
    id
    invitesConnection(
      statuses: $status
      orderBy: $orderBy
      after: $cursor
      first: $limit
    ) {
      edges {
        node {
          ...InviteDetails
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
}
    ${InviteDetailsFragmentDoc}`;
var InviteEditorModalQueryDocument = import_client.gql`
    query InviteEditorModalQuery($inviteId: Int!) {
  currentProject {
    id
    groups {
      id
      name
    }
  }
  projectInvite(id: $inviteId) {
    id
    makeAdmin
    email
    fullname
    status
    groups {
      id
      name
    }
    wasUsed
    inviteEmails {
      ...InviteEmailDetails
    }
  }
}
    ${InviteEmailDetailsFragmentDoc}`;
var UpdateProjectInviteDocument = import_client.gql`
    mutation UpdateProjectInvite($id: Int!, $makeAdmin: Boolean!, $email: String!, $fullname: String, $groups: [Int]!) {
  updateProjectInvite(
    input: {inviteId: $id, makeAdmin: $makeAdmin, email: $email, groups: $groups, fullname: $fullname}
  ) {
    projectInvite {
      id
      makeAdmin
      groups {
        id
        name
      }
      email
      fullname
      inviteEmails {
        ...InviteEmailDetails
      }
    }
  }
}
    ${InviteEmailDetailsFragmentDoc}`;
var DeleteProjectInviteDocument = import_client.gql`
    mutation DeleteProjectInvite($id: Int!) {
  deleteProjectInvite(input: {id: $id}) {
    projectInvite {
      id
    }
  }
}
    `;
var SendInviteDocument = import_client.gql`
    mutation SendInvite($id: Int!) {
  sendProjectInvites(input: {inviteIds: [$id]}) {
    inviteEmails {
      ...InviteEmailDetails
      projectInvite {
        id
        status
      }
    }
  }
}
    ${InviteEmailDetailsFragmentDoc}`;
var RenameGroupDocument = import_client.gql`
    mutation RenameGroup($id: Int!, $name: String!) {
  updateGroup(input: {id: $id, patch: {name: $name}}) {
    group {
      id
      name
    }
  }
}
    `;
var SendInvitesDocument = import_client.gql`
    mutation SendInvites($ids: [Int]!) {
  sendProjectInvites(input: {inviteIds: $ids}) {
    inviteEmails {
      ...InviteEmailDetails
      projectInviteId
      projectInvite {
        id
        status
      }
    }
  }
}
    ${InviteEmailDetailsFragmentDoc}`;
var ProjectInviteEmailStatusSubscriptionDocument = import_client.gql`
    subscription ProjectInviteEmailStatusSubscription {
  projectInviteStateUpdated {
    invite {
      opaqueId: id
      status
    }
  }
}
    `;
var UpdateProfileDocument = import_client.gql`
    mutation UpdateProfile($userId: Int!, $affiliations: String, $email: Email, $fullname: String, $nickname: String, $picture: Upload) {
  updateProfileByUserId(
    input: {userId: $userId, patch: {affiliations: $affiliations, email: $email, fullname: $fullname, nickname: $nickname, picture: $picture}}
  ) {
    profile {
      user {
        id
        profile {
          picture
        }
      }
    }
  }
}
    `;

// src/surveys/paging.ts
function getSurveyPagingState(currentIndex, sortedFormElements, rules, answers) {
  const current = sortedFormElements[currentIndex];
  if (!current) {
    throw new Error(`No FormElement at index ${currentIndex}`);
  }
  const path = calculatePathToElement(current.id, sortedFormElements, rules, answers);
  const next = getNextFormElement(current, sortedFormElements, rules, answers);
  return {
    isLastQuestion: (next == null ? void 0 : next.typeId) === "SaveScreen",
    isFirstQuestion: currentIndex === 1,
    previousFormElement: path[path.length - 2],
    nextFormElement: next,
    sortedFormElements
  };
}
function calculatePathToElement(currentId, sortedFormElements, rules, answers) {
  const currentIndex = sortedFormElements.findIndex((el) => el.id === currentId);
  if (currentIndex === 0) {
    return [sortedFormElements[0]];
  }
  const path = [];
  let recursionLimit = 2e4;
  let step = sortedFormElements[0];
  path.push(sortedFormElements[0]);
  while (step !== null && recursionLimit--) {
    step = getNextFormElement(step, sortedFormElements, rules, answers);
    if (step) {
      path.push(step);
      if (step.id === currentId) {
        return path;
      }
      if (sortedFormElements.indexOf(step) > currentIndex && !step.subordinateTo) {
        throw new Error("Stepped past current formElement!");
      }
    }
  }
  if (recursionLimit < 1) {
    throw new Error(`Reached recursion limit while calculating survey path`);
  } else {
    throw new Error(`Never reached currentIndex while calculating survey path`);
  }
}
function getNextFormElement(current, sortedFormElements, rules, answers) {
  const subordinateElements = sortedFormElements.filter((el) => !!el.subordinateTo);
  sortedFormElements = sortedFormElements.filter((el) => !el.subordinateTo);
  const originalAnswers = answers;
  answers = __spreadValues({}, answers);
  for (const el of sortedFormElements) {
    if (answers[el.id] !== void 0) {
      const C = componentExportHelpers[el.typeId];
      if (!C) {
        throw new Error(`Could not find component ${el.typeId}`);
      }
      answers[el.id] = C.getValueForRuleEvaluation(answers[el.id], el.componentSettings);
    }
  }
  const matchingSubordinateElements = subordinateElements.filter((el) => el.subordinateTo === current.id).filter((el) => componentExportHelpers[current.typeId].shouldDisplaySubordinateElement(el.id, current.componentSettings, originalAnswers[current.id]));
  if (matchingSubordinateElements.length) {
    return matchingSubordinateElements[0];
  } else if (current.subordinateTo) {
    const parent = sortedFormElements.find((el) => el.id === current.subordinateTo);
    if (!parent) {
      throw new Error("Parent of subordinate not found");
    }
    const siblings = subordinateElements.filter((el) => el.subordinateTo === current.subordinateTo).filter((el) => componentExportHelpers[parent.typeId].shouldDisplaySubordinateElement(el.id, parent.componentSettings, originalAnswers[parent.id]));
    const idx = siblings.indexOf(current);
    if (idx === siblings.length - 1) {
      const currentIndex2 = sortedFormElements.indexOf(parent);
      return sortedFormElements[currentIndex2 + 1];
    } else {
      return siblings[idx + 1];
    }
  }
  const currentIndex = sortedFormElements.indexOf(current);
  let nextByPosition = sortedFormElements[currentIndex + 1];
  let nextByJumpToId = current.jumpToId ? sortedFormElements.find((el) => el.id === current.jumpToId) : void 0;
  if (nextByJumpToId && sortedFormElements.indexOf(nextByJumpToId) < currentIndex) {
    console.warn(`Ignoring invalid skip logic rule that would jump backward in survey`);
    nextByJumpToId = void 0;
  }
  if (currentIndex === 0) {
    return nextByPosition;
  } else if (currentIndex === sortedFormElements.length - 1) {
    return null;
  } else if (currentIndex === sortedFormElements.length - 3) {
    return nextByPosition;
  } else if (currentIndex === sortedFormElements.length - 2) {
    return nextByPosition;
  } else {
    const currentRules = rules.filter((rule) => rule.formElementId === current.id).sort((a, b) => a.position - b.position);
    for (const rule of currentRules) {
      if (evaluateRule(rule, answers)) {
        const next = sortedFormElements.find((el) => el.id === rule.jumpToId);
        if (!next) {
          console.warn(`Could not find FormElement refered to by jumpToId=${rule.jumpToId}`);
        } else if (sortedFormElements.indexOf(next) < currentIndex) {
          console.warn(`Skipping logic rule that would mean jumping backwards`);
        } else {
          return next;
        }
      }
    }
    return nextByJumpToId || nextByPosition;
  }
}
function evaluateRule(rule, answers) {
  for (const condition of rule.conditions || []) {
    const answer = answers[condition.subjectId];
    if (evaluateCondition(condition.operator, condition.value, answer)) {
      if (rule.booleanOperator === "OR" /* Or */) {
        return true;
      }
    } else {
      if (rule.booleanOperator === "AND" /* And */) {
        return false;
      }
    }
  }
  return rule.booleanOperator === "AND" /* And */;
}
function evaluateCondition(operator, value, answer) {
  switch (operator) {
    case "CONTAINS" /* Contains */:
      if (Array.isArray(answer)) {
        return answer.indexOf(value) !== -1;
      } else {
        return answer == value;
      }
    case "EQUAL" /* Equal */:
      if (Array.isArray(answer)) {
        return answer.indexOf(value) !== -1;
      } else {
        return answer == value;
      }
    case "GREATER_THAN" /* GreaterThan */:
      return answer > value;
    case "IS_BLANK" /* IsBlank */:
      return answer == null || answer == void 0 || answer == "" || answer == " ";
    case "LESS_THAN" /* LessThan */:
      return answer < value;
    case "NOT_EQUAL" /* NotEqual */:
      if (Array.isArray(answer)) {
        return answer.indexOf(value) === -1;
      } else {
        return answer != value;
      }
    default:
      throw new Error(`Unsupported operator ${operator}`);
  }
}

// src/formElements/ExportUtils.ts
function getPath() {
  getSurveyPagingState(1, [], [], {});
}
function getAnswers(componentName, exportId, componentSettings, answer) {
  return componentExportHelpers[componentName].getAnswers(componentSettings, exportId, answer);
}
function getDataForExport(responses, formElements) {
  const sortedElements = sortFormElements(formElements);
  const rows = [];
  const columns = [
    "id",
    "survey_id",
    "created_at_utc",
    "updated_at_utc",
    "is_practice",
    "is_duplicate_ip",
    "is_logged_in",
    "account_email"
  ];
  for (const element of sortedElements) {
    if (element.isInput) {
      columns.push(...componentExportHelpers[element.typeId].getColumns(element.componentSettings, element.exportId));
    }
  }
  for (const response of responses) {
    const row = {
      id: response.id,
      survey_id: response.surveyId,
      created_at_utc: new Date(response.createdAt).toISOString(),
      is_practice: response.isPractice,
      updated_at_utc: response.updatedAt ? new Date(response.updatedAt).toISOString() : null,
      is_duplicate_ip: response.isDuplicateIp,
      is_logged_in: !!response.userId,
      account_email: response.accountEmail || null
    };
    const answers = getAnswersAsProperties(sortedElements, response.data);
    rows.push(__spreadValues(__spreadValues({}, row), answers));
  }
  return { rows, columns };
}
function getAnswersAsProperties(sortedElements, data) {
  const answers = {};
  for (const element of sortedElements) {
    const answer = data[element.id];
    if (answer !== void 0) {
      const columnData = getAnswers(element.typeId, element.exportId, element.componentSettings, answer);
      for (const col in columnData) {
        answers[col] = columnData[col];
      }
    }
  }
  return answers;
}
function normalizeSpatialProperties(surveyId, collection, formElements) {
  const sortedElements = sortFormElements(formElements);
  for (const feature of collection.features) {
    feature.properties = __spreadValues(__spreadValues({
      survey_id: surveyId,
      response_id: feature.properties.response_id
    }, getAnswersAsProperties(sortedElements, feature.properties)), feature.properties.area_sq_meters ? { area_sq_meters: feature.properties.area_sq_meters } : {});
  }
  return collection;
}
module.exports = __toCommonJS(ExportUtils_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getAnswers,
  getDataForExport,
  getPath,
  normalizeSpatialProperties
});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
