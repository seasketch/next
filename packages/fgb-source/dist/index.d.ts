import { GeometryType } from 'flatgeobuf/lib/mjs/generic.js';
import { Feature, GeoJsonProperties, Geometry } from 'geojson';
import { HeaderMeta } from 'flatgeobuf';

type FetchRangeFn = (range: [number, number | null]) => Promise<ArrayBuffer>;
/**
 * Statistics about the LRU cache and in-flight requests.
 * Used to monitor cache performance and memory usage.
 */
type CacheStats = {
    /** Current number of items in the cache */
    count: number;
    /** Total size of cached items in bytes */
    calculatedSize: number;
    /** Maximum size of the cache which stores feature data in bytes */
    maxSize: number;
    /** Number of requests currently in flight */
    inFlightRequests: number;
};

/**
 * Byte offsets to fetch feature data from the fgb file, as [offset, length].
 * The length is null if the feature is the last in the file.
 */
type OffsetAndLength = [number, number | null];
/**
 * RTreeIndex provides spatial indexing for FlatGeobuf files.
 *
 * This implementation is inspired by flatbush but differs in that it does not
 * stream results. Instead, it fetches and reads the entire index at once. This approach
 * is simpler to implement and should have better performance for moderate
 * index sizes, but may need to be revised for very large indexes.
 *
 * The index is stored in a packed format, with each node containing:
 * - maxX, maxY, minX, minY (float64)
 * - offset (uint64)
 *
 * @example
 * ```typescript
 * const index = new RTreeIndex(data, details);
 * const results = await index.search(-180, -90, 180, 90);
 * ```
 */
declare class RTreeIndex {
    /** Minimum X coordinate of the entire index */
    minX: number;
    /** Minimum Y coordinate of the entire index */
    minY: number;
    /** Maximum X coordinate of the entire index */
    maxX: number;
    /** Maximum Y coordinate of the entire index */
    maxY: number;
    /** Total size of the index in bytes */
    byteLength: number;
    private view;
    private details;
    /**
     * Creates a new RTreeIndex instance.
     *
     * @param data - The packed R-tree index data
     * @param details - Details about the R-tree structure. Generated by
     *   `calculatePackedRTreeDetails`.
     * @throws Error if data is empty or details are invalid
     */
    constructor(data: ArrayBuffer, details: PackedRTreeDetails);
    /**
     * Search for features within a bounding box.
     *
     * The search is performed using a top-down traversal of the R-tree.
     * Results are returned as an array of [offset, length] tuples, where
     * length is null for the last feature in the file.
     *
     * @param minX - Minimum X coordinate of the search box
     * @param minY - Minimum Y coordinate of the search box
     * @param maxX - Maximum X coordinate of the search box
     * @param maxY - Maximum Y coordinate of the search box
     * @returns Promise resolving to array of [offset, length] tuples
     */
    search(minX: number, minY: number, maxX: number, maxY: number): Promise<OffsetAndLength[]>;
    /**
     * Get the data for a node at the specified index.
     *
     * @param index - Index of the node
     * @returns Object containing node bounds, offset, and whether it's a leaf node
     * @private
     */
    private getNodeData;
}
/**
 * Details about the structure of a packed R-tree index.
 */
interface PackedRTreeDetails {
    /** Number of features in the index */
    featureCount: number;
    /** Number of children per node */
    nodeSize: number;
    /** Total number of nodes in the tree */
    numNodes: number;
    /** Total size of the index in bytes */
    nodesByteSize: number;
    /** Height of the tree */
    treeHeight: number;
    /**
     * Array of level bounds in the index.
     *
     * The first element is the byte offset of the last node in the root level,
     * the last element is the byte offset of the last level before the leaves.
     *
     * Example:
     * ```
     * [ 40, 160, 1960, 30320, 484000 ]
     * ```
     *
     * In this example:
     * - Root level starts at 0
     * - First level starts at 40
     * - Leaf nodes start at 484000
     *
     * Unlike flatbush, the root node is included first, followed by subsequent
     * levels in the index, and finally the leaf nodes.
     */
    levels: number[];
}

/**
 * Options for query planning and execution.
 */
type QueryPlanOptions = {
    /** Maximum number of bytes to overfetch when merging ranges */
    overfetchBytes?: number;
    /** Skip validation of feature data size prefixes */
    skipValidation?: boolean;
};

/**
 * Feature with additional metadata from the FlatGeobuf file.
 */
type FeatureWithMetadata<T = Feature> = T & {
    properties: GeoJsonProperties & {
        /** Length of the feature data in bytes */
        __byteLength: number;
        /** Offset of the feature in the FlatGeobuf file */
        __offset: number;
    };
};

/**
 * Represents a byte size that can be specified as either a number of bytes
 * or a string that will be parsed using the bytes module (e.g. "5MB", "1GB").
 */
type ByteSize = number | string;
/**
 * Represents a bounding box with minimum and maximum coordinates.
 * Used for spatial queries to specify the area to search for features.
 *
 * @example
 * ```typescript
 * const bbox: Envelope = {
 *   minX: -180, // westernmost coordinate
 *   minY: -90,  // southernmost coordinate
 *   maxX: 180,  // easternmost coordinate
 *   maxY: 90    // northernmost coordinate
 * };
 * ```
 */
type Envelope = {
    /** Westernmost coordinate (minimum X) */
    minX: number;
    /** Southernmost coordinate (minimum Y) */
    minY: number;
    /** Easternmost coordinate (maximum X) */
    maxX: number;
    /** Northernmost coordinate (maximum Y) */
    maxY: number;
};
/**
 * Use to implement custom fetching logic, such as from an R2 bucket. Accepts
 * a byte range and returns a promise that resolves to an ArrayBuffer.
 */
type FetchRangeByKeyFn = (key: string, range: [number, number | null]) => Promise<ArrayBuffer>;
/**
 * Configuration options for creating a new FlatGeobufSource instance.
 */
type CreateSourceOptions = {
    /**
     * Custom function for fetching byte ranges from the source.
     * If not provided, the source will use the default fetch implementation.
     */
    fetchRangeFn?: FetchRangeByKeyFn;
    /**
     * Maximum size of the feature data cache in bytes.
     * Can be specified as a number of bytes or a string (e.g. "5MB", "1GB").
     * Defaults to 5MB.
     */
    maxCacheSize?: ByteSize;
    /**
     * Initial size of the header request in bytes.
     * Can be specified as a number of bytes or a string (e.g. "5MB", "1GB").
     * If not provided, defaults to HEADER_FETCH_SIZE.
     * Use this when you know your dataset has a large spatial index.
     */
    initialHeaderRequestLength?: ByteSize;
    /**
     * Amount of space allowed between features before splitting requests.
     * Can be specified as a number of bytes or a string (e.g. "5MB", "1GB").
     * If not provided, defaults to QUERY_PLAN_DEFAULTS.overfetchBytes.
     * Use this to control how aggressively ranges are merged.
     */
    overfetchBytes?: ByteSize;
};
/**
 * FlatGeobuf data source class. Provides methods to query features from a
 * flatgeobuf file. Features are streamed to minimize memory usage, and an
 * LRU cache is used to minimize network requests.
 *
 * You probably do not want to use this class directly. Instead, use the
 * `createSource` function to create a source instance.
 *
 * @example
 * ```typescript
 * const source = await createSource('https://example.com/data.fgb');
 * for await (const feature of source.getFeaturesAsync(bbox)) {
 *   console.log(feature);
 * }
 * ```
 */
declare class FlatGeobufSource<T = Feature> {
    /** Url for fgb, unless fetchRangeFn is specified  */
    private url?;
    /** Custom method provided to createSource used to fetch fgb byte ranges */
    private fetchRangeFn?;
    /** fgb header metadata */
    header: HeaderMeta;
    /** Spatial index for bounding box queries */
    private index;
    /** offset from the start of the fgb to the first feature data byte */
    private featureDataOffset;
    /** Manages fetching and caching of byte ranges */
    private fetchManager;
    /** Amount of space allowed between features before splitting requests */
    private overfetchBytes?;
    /**
     * Should not be called directly. Instead initialize using createSource(),
     * which will generate the necessary metadata and spatial index.
     */
    constructor(urlOrFetchRangeFn: string | FetchRangeFn, header: HeaderMeta, index: RTreeIndex, featureDataOffset: number, maxCacheSize?: ByteSize, overfetchBytes?: ByteSize);
    /**
     * Get cache statistics
     */
    get cacheStats(): CacheStats;
    /**
     * Clear the feature data cache
     */
    clearCache(): void;
    /**
     * Bounds of the source, as determined from the spatial index.
     */
    get bounds(): {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    /**
     * Size of the index in bytes, which approximates the size this data source
     * occupies in memory.
     */
    get indexSizeBytes(): number;
    /**
     * Geometry type of the source.
     */
    get geometryType(): keyof typeof GeometryType;
    /**
     * Get features within a bounding box. Features are streamed to minimize
     * memory usage. Each feature is deserialized to GeoJSON before being yielded.
     *
     * Memory usage is minimized by deserializing features to GeoJSON individually
     * before yielding them. If you need to minimize memory usage in an
     * environment like cloudflare workers, you need only concern yourself with
     * the memory usage of the binary bytes fetched + the GeoJSON size of only
     * the single largest feature being processed at any given time.
     *
     * @param bbox - Single bounding box or array of bounding boxes to query
     * @param options - Query options
     * @returns AsyncGenerator yielding GeoJSON features with metadata
     *
     * @example
     * ```typescript
     * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
     * for await (const feature of source.getFeaturesAsync(bbox)) {
     *   console.log(feature);
     * }
     * ```
     */
    getFeaturesAsync(bbox: Envelope | Envelope[], options?: QueryPlanOptions & {
        /**
         * If set true, the cache will be warmed by fetching all features in the
         * bounding box. These features are not parsed or yielded.
         */
        warmCache?: boolean;
    }): AsyncGenerator<FeatureWithMetadata<T>>;
    /**
     * Scan all features in the source. Does not use the spatial index, but
     * rather fetches the entire feature data section and iterates through it.
     *
     * Features are not deserialized to GeoJSON until they are yielded, reducing
     * memory usage.
     *
     * @returns AsyncGenerator yielding GeoJSON features with metadata
     *
     * @example
     * ```typescript
     * for await (const feature of source.scanAllFeatures()) {
     *   console.log(feature);
     * }
     * ```
     */
    scanAllFeatures(): AsyncGenerator<T & {
        properties: GeoJsonProperties & {
            __byteLength: number;
            __offset: number;
        };
    }>;
    getFeatureProperties(): AsyncGenerator<{
        properties: GeoJsonProperties & {
            __byteLength: number;
            __offset: number;
        };
        getFeature: () => T & {
            properties: GeoJsonProperties & {
                __byteLength: number;
                __offset: number;
            };
        };
    }>;
}
/**
 * Create a FlatGeobufSource from a URL or a custom fetchRange function. The
 * Promise will not be resolved until the source is fully initialized, loading
 * the header and spatial index data.
 *
 * @param urlOrKey - URL or key to fetch the source from. If a key is provided,
 * the fetchRangeFn will be used to fetch the source.
 * @param options - Options for creating the source.
 * @returns Promise<FlatGeobufSource<T>>
 */
declare function createSource<T = Feature<Geometry, GeoJsonProperties>>(urlOrKey: string, options?: CreateSourceOptions): Promise<FlatGeobufSource<T>>;

/**
 * Configuration options for creating a new SourceCache instance.
 */
type SourceCacheOptions = {
    /**
     * Callback called when a source is evicted from the cache. Receives (key, source, reason).
     */
    onEvict?: (key: string, source: FlatGeobufSource<any>, reason: string) => void;
    /**
     * Default fetch function to use when creating sources. Will be merged with options passed to get().
     */
    fetchRangeFn?: CreateSourceOptions["fetchRangeFn"];
    /**
     * Default maximum cache size for sources. Will be merged with options passed to get().
     */
    maxCacheSize?: CreateSourceOptions["maxCacheSize"];
    /**
     * Default initial header request length. Will be merged with options passed to get().
     */
    initialHeaderRequestLength?: CreateSourceOptions["initialHeaderRequestLength"];
    /**
     * Default overfetch bytes. Will be merged with options passed to get().
     */
    overfetchBytes?: CreateSourceOptions["overfetchBytes"];
};
/**
 * Caches FlatGeobufSource instances to avoid re-initializing sources for the same URL.
 * Uses an LRU (Least Recently Used) cache strategy to manage memory usage.
 *
 * The cache size is calculated based on the total memory used by each source:
 * - Size of the spatial index (indexSizeBytes)
 * - Size of the feature data cache (cacheStats.maxSize)
 *
 * @example
 * ```typescript
 * const sourceCache = new SourceCache('64mb', {
 *   onEvict: (key, source, reason) => {
 *     console.log(`Evicted ${key} for reason: ${reason}`);
 *   }
 * });
 * const source = await sourceCache.get('https://example.com/data.fgb');
 * ```
 */
declare class SourceCache {
    private sizeLimitBytes;
    private cache;
    /**
     * Map of keys to in-flight requests. Used to avoid creating the same source
     * multiple times when there are concurrent requests for the same source.
     */
    private inFlightRequests;
    private onEvict?;
    private defaultOptions?;
    /**
     * Create a new SourceCache instance.
     *
     * @param sizeLimit - Maximum size of the cache, parseable by the bytes library.
     *                   Examples: '100MB', '1GB', '500KB'
     * @param options - Optional configuration object
     *   - onEvict: Callback called when a source is evicted from the cache. Receives (key, source, reason).
     *   - fetchRangeFn: Default fetch function to use when creating sources. Will be merged with options passed to get().
     *   - maxCacheSize: Default maximum cache size for sources. Will be merged with options passed to get().
     *   - initialHeaderRequestLength: Default initial header request length. Will be merged with options passed to get().
     *   - overfetchBytes: Default overfetch bytes. Will be merged with options passed to get().
     * @throws Error if sizeLimit is invalid
     */
    constructor(sizeLimit: string, options?: SourceCacheOptions);
    /**
     * Get a FlatGeobufSource instance for the given key. If the source is already
     * cached, returns the cached instance. Otherwise, creates a new source and
     * caches it.
     *
     * @param key - URL or key to fetch the source from
     * @param options - Options for creating the source if it needs to be created. These will be merged with default options from the constructor.
     * @returns Promise resolving to a FlatGeobufSource instance
     *
     * @example
     * ```typescript
     * const sourceCache = new SourceCache('64mb');
     * // Basic usage with default options
     * const source = await sourceCache.get('https://example.com/data.fgb');
     *
     * // Customize feature data cache size
     * const source = await sourceCache.get('https://example.com/data.fgb', {
     *   maxCacheSize: 1024 * 1024 // 1MB feature cache
     * });
     *
     * // Use custom fetch implementation (e.g. for R2 bucket)
     * const source = await sourceCache.get('fgb-object-key', {
     *   fetchRangeFn: async (key, range) => {
     *     const response = await fetch(`https://my-bucket.r2.dev/${key}`, {
     *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
     *     });
     *     return response.arrayBuffer();
     *   }
     * });
     *
     * // With default fetch function set in constructor
     * const sourceCache = new SourceCache('64mb', {
     *   fetchRangeFn: async (key, range) => {
     *     const response = await fetch(`https://uploads.seasketch.org/${key}`, {
     *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
     *     });
     *     return response.arrayBuffer();
     *   }
     * });
     * // Now you can use get() without specifying fetchRangeFn each time
     * const source = await sourceCache.get('my-data.fgb');
     *
     * // Query features within a bounding box
     * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
     * for await (const feature of source.getFeaturesAsync(bbox)) {
     *   console.log(feature);
     * }
     * ```
     */
    get<T = Feature<Geometry, GeoJsonProperties>>(key: string, options?: CreateSourceOptions): Promise<FlatGeobufSource<T>>;
}

export { type CreateSourceOptions, type FetchRangeByKeyFn, type FetchRangeFn, FlatGeobufSource, type PackedRTreeDetails, SourceCache, type SourceCacheOptions, createSource };
