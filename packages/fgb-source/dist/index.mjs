import * as t from 'flatbuffers';
import { ByteBuffer } from 'flatbuffers';
import { LRUCache } from 'lru-cache';
import bytes from 'bytes';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/rtree.ts
var NODE_ITEM_BYTE_LENGTH = 8 * 4 + 8;
var RTreeIndex = class {
  /**
   * Creates a new RTreeIndex instance.
   *
   * @param data - The packed R-tree index data
   * @param details - Details about the R-tree structure. Generated by
   *   `calculatePackedRTreeDetails`.
   * @throws Error if data is empty or details are invalid
   */
  constructor(data, details) {
    this.details = details;
    if (!data.byteLength) {
      throw new Error("data is empty");
    }
    this.view = new DataView(data);
    this.byteLength = data.byteLength;
    if (details.featureCount === void 0) {
      throw new Error("numItems is undefined");
    } else if (isNaN(details.featureCount) || details.featureCount < 0) {
      throw new Error("numItems is invalid");
    }
    const rootBounds = this.getNodeData(0);
    this.minX = rootBounds.minX;
    this.minY = rootBounds.minY;
    this.maxX = rootBounds.maxX;
    this.maxY = rootBounds.maxY;
  }
  /**
   * Search for features within a bounding box.
   *
   * The search is performed using a top-down traversal of the R-tree.
   * Results are returned as an array of [offset, length] tuples, where
   * length is null for the last feature in the file.
   *
   * @param minX - Minimum X coordinate of the search box
   * @param minY - Minimum Y coordinate of the search box
   * @param maxX - Maximum X coordinate of the search box
   * @param maxY - Maximum Y coordinate of the search box
   * @returns Promise resolving to array of [offset, length] tuples
   */
  async search(minX, minY, maxX, maxY) {
    let nodeIndex = 0;
    const queue = [];
    const results = [];
    while (nodeIndex !== void 0) {
      const end = Math.min(
        nodeIndex + this.details.nodeSize,
        // upperBound calculates the last position of the current level
        upperBound(nodeIndex, this.details.levels)
      );
      for (let pos = nodeIndex; pos < end; pos++) {
        const node = this.getNodeData(pos);
        if (maxX < node.minX || maxY < node.minY || minX > node.maxX || minY > node.maxY) {
          continue;
        }
        if (node.isLeaf) {
          const nextLeafPosition = pos + 1;
          let length = null;
          if (nextLeafPosition < this.details.numNodes) {
            const nextLeaf = this.getNodeData(nextLeafPosition);
            length = nextLeaf.offset - node.offset;
          }
          results.push([node.offset, length]);
        } else {
          queue.push(Number(node.offset));
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
  /**
   * Get the data for a node at the specified index.
   *
   * @param index - Index of the node
   * @returns Object containing node bounds, offset, and whether it's a leaf node
   * @private
   */
  getNodeData(index) {
    const byteIndex = index * NODE_ITEM_BYTE_LENGTH;
    return {
      minX: this.view.getFloat64(byteIndex, true),
      minY: this.view.getFloat64(byteIndex + 8, true),
      maxX: this.view.getFloat64(byteIndex + 16, true),
      maxY: this.view.getFloat64(byteIndex + 24, true),
      // The offset is a uint64, so we need to use getBigUint64. Theres no
      // sense in supporting files up to 9k terabytes, so we can safely use
      // Number() for ergonomics.
      offset: Number(this.view.getBigUint64(byteIndex + 32, true)),
      isLeaf: index >= this.details.levels[this.details.levels.length - 2]
    };
  }
};
function calculatePackedRTreeDetails(featureCount, indexNodeSize) {
  const nodeSize = Math.min(Math.max(+indexNodeSize, 2), 65535);
  const numItems = featureCount;
  let n2 = numItems;
  let numNodes = 0;
  let treeHeight = 0;
  const nodesPerLevel = [n2];
  do {
    treeHeight++;
    numNodes += n2;
    n2 = Math.ceil(n2 / nodeSize);
    nodesPerLevel.push(n2);
  } while (n2 > 1);
  numNodes++;
  const levels = [];
  let position = 0;
  while (nodesPerLevel.length) {
    n2 = nodesPerLevel.pop();
    position += n2;
    levels.push(position);
  }
  return {
    nodeSize,
    numNodes,
    nodesByteSize: numNodes * NODE_ITEM_BYTE_LENGTH,
    treeHeight,
    levels,
    featureCount
  };
}
function upperBound(value, arr) {
  let i = 0;
  let j = arr.length - 1;
  while (i < j) {
    const m = i + j >> 1;
    if (arr[m] > value) {
      j = m;
    } else {
      i = m + 1;
    }
  }
  return arr[i];
}

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/column-type.js
var o;
var ColumnType = ((o = {})[o.Byte = 0] = "Byte", o[o.UByte = 1] = "UByte", o[o.Bool = 2] = "Bool", o[o.Short = 3] = "Short", o[o.UShort = 4] = "UShort", o[o.Int = 5] = "Int", o[o.UInt = 6] = "UInt", o[o.Long = 7] = "Long", o[o.ULong = 8] = "ULong", o[o.Float = 9] = "Float", o[o.Double = 10] = "Double", o[o.String = 11] = "String", o[o.Json = 12] = "Json", o[o.DateTime = 13] = "DateTime", o[o.Binary = 14] = "Binary", o);

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/column.js
var Column = class _Column {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(t7, s2) {
    return this.bb_pos = t7, this.bb = s2, this;
  }
  static getRootAsColumn(t7, s2) {
    return (s2 || new _Column()).__init(t7.readInt32(t7.position()) + t7.position(), t7);
  }
  static getSizePrefixedRootAsColumn(s2, i) {
    return s2.setPosition(s2.position() + t.SIZE_PREFIX_LENGTH), (i || new _Column()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  name(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  type() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? this.bb.readUint8(this.bb_pos + t7) : ColumnType.Byte;
  }
  title(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 8);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  description(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 10);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  width() {
    let t7 = this.bb.__offset(this.bb_pos, 12);
    return t7 ? this.bb.readInt32(this.bb_pos + t7) : -1;
  }
  precision() {
    let t7 = this.bb.__offset(this.bb_pos, 14);
    return t7 ? this.bb.readInt32(this.bb_pos + t7) : -1;
  }
  scale() {
    let t7 = this.bb.__offset(this.bb_pos, 16);
    return t7 ? this.bb.readInt32(this.bb_pos + t7) : -1;
  }
  nullable() {
    let t7 = this.bb.__offset(this.bb_pos, 18);
    return !t7 || !!this.bb.readInt8(this.bb_pos + t7);
  }
  unique() {
    let t7 = this.bb.__offset(this.bb_pos, 20);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  primaryKey() {
    let t7 = this.bb.__offset(this.bb_pos, 22);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  metadata(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 24);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  static startColumn(t7) {
    t7.startObject(11);
  }
  static addName(t7, s2) {
    t7.addFieldOffset(0, s2, 0);
  }
  static addType(t7, i) {
    t7.addFieldInt8(1, i, ColumnType.Byte);
  }
  static addTitle(t7, s2) {
    t7.addFieldOffset(2, s2, 0);
  }
  static addDescription(t7, s2) {
    t7.addFieldOffset(3, s2, 0);
  }
  static addWidth(t7, s2) {
    t7.addFieldInt32(4, s2, -1);
  }
  static addPrecision(t7, s2) {
    t7.addFieldInt32(5, s2, -1);
  }
  static addScale(t7, s2) {
    t7.addFieldInt32(6, s2, -1);
  }
  static addNullable(t7, s2) {
    t7.addFieldInt8(7, +s2, 1);
  }
  static addUnique(t7, s2) {
    t7.addFieldInt8(8, +s2, 0);
  }
  static addPrimaryKey(t7, s2) {
    t7.addFieldInt8(9, +s2, 0);
  }
  static addMetadata(t7, s2) {
    t7.addFieldOffset(10, s2, 0);
  }
  static endColumn(t7) {
    let s2 = t7.endObject();
    return t7.requiredField(s2, 4), s2;
  }
  static createColumn(t7, s2, i, e4, b, d, n2, a, o2, l, r2, _) {
    return _Column.startColumn(t7), _Column.addName(t7, s2), _Column.addType(t7, i), _Column.addTitle(t7, e4), _Column.addDescription(t7, b), _Column.addWidth(t7, d), _Column.addPrecision(t7, n2), _Column.addScale(t7, a), _Column.addNullable(t7, o2), _Column.addUnique(t7, l), _Column.addPrimaryKey(t7, r2), _Column.addMetadata(t7, _), _Column.endColumn(t7);
  }
};
var Crs = class _Crs {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(t7, s2) {
    return this.bb_pos = t7, this.bb = s2, this;
  }
  static getRootAsCrs(t7, s2) {
    return (s2 || new _Crs()).__init(t7.readInt32(t7.position()) + t7.position(), t7);
  }
  static getSizePrefixedRootAsCrs(s2, i) {
    return s2.setPosition(s2.position() + t.SIZE_PREFIX_LENGTH), (i || new _Crs()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  org(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  code() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? this.bb.readInt32(this.bb_pos + t7) : 0;
  }
  name(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 8);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  description(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 10);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  wkt(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 12);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  codeString(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 14);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  static startCrs(t7) {
    t7.startObject(6);
  }
  static addOrg(t7, s2) {
    t7.addFieldOffset(0, s2, 0);
  }
  static addCode(t7, s2) {
    t7.addFieldInt32(1, s2, 0);
  }
  static addName(t7, s2) {
    t7.addFieldOffset(2, s2, 0);
  }
  static addDescription(t7, s2) {
    t7.addFieldOffset(3, s2, 0);
  }
  static addWkt(t7, s2) {
    t7.addFieldOffset(4, s2, 0);
  }
  static addCodeString(t7, s2) {
    t7.addFieldOffset(5, s2, 0);
  }
  static endCrs(t7) {
    return t7.endObject();
  }
  static createCrs(t7, s2, i, e4, r2, b, d) {
    return _Crs.startCrs(t7), _Crs.addOrg(t7, s2), _Crs.addCode(t7, i), _Crs.addName(t7, e4), _Crs.addDescription(t7, r2), _Crs.addWkt(t7, b), _Crs.addCodeString(t7, d), _Crs.endCrs(t7);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/geometry-type.js
var r;
var GeometryType = ((r = {})[r.Unknown = 0] = "Unknown", r[r.Point = 1] = "Point", r[r.LineString = 2] = "LineString", r[r.Polygon = 3] = "Polygon", r[r.MultiPoint = 4] = "MultiPoint", r[r.MultiLineString = 5] = "MultiLineString", r[r.MultiPolygon = 6] = "MultiPolygon", r[r.GeometryCollection = 7] = "GeometryCollection", r[r.CircularString = 8] = "CircularString", r[r.CompoundCurve = 9] = "CompoundCurve", r[r.CurvePolygon = 10] = "CurvePolygon", r[r.MultiCurve = 11] = "MultiCurve", r[r.MultiSurface = 12] = "MultiSurface", r[r.Curve = 13] = "Curve", r[r.Surface = 14] = "Surface", r[r.PolyhedralSurface = 15] = "PolyhedralSurface", r[r.TIN = 16] = "TIN", r[r.Triangle = 17] = "Triangle", r);

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/header.js
var Header = class _Header {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(t7, s2) {
    return this.bb_pos = t7, this.bb = s2, this;
  }
  static getRootAsHeader(t7, s2) {
    return (s2 || new _Header()).__init(t7.readInt32(t7.position()) + t7.position(), t7);
  }
  static getSizePrefixedRootAsHeader(s2, e4) {
    return s2.setPosition(s2.position() + t.SIZE_PREFIX_LENGTH), (e4 || new _Header()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  name(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  envelope(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 6);
    return s2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + s2) + 8 * t7) : 0;
  }
  envelopeLength() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  envelopeArray() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  geometryType() {
    let t7 = this.bb.__offset(this.bb_pos, 8);
    return t7 ? this.bb.readUint8(this.bb_pos + t7) : GeometryType.Unknown;
  }
  hasZ() {
    let t7 = this.bb.__offset(this.bb_pos, 10);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  hasM() {
    let t7 = this.bb.__offset(this.bb_pos, 12);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  hasT() {
    let t7 = this.bb.__offset(this.bb_pos, 14);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  hasTm() {
    let t7 = this.bb.__offset(this.bb_pos, 16);
    return !!t7 && !!this.bb.readInt8(this.bb_pos + t7);
  }
  columns(t7, e4) {
    let i = this.bb.__offset(this.bb_pos, 18);
    return i ? (e4 || new Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * t7), this.bb) : null;
  }
  columnsLength() {
    let t7 = this.bb.__offset(this.bb_pos, 18);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  featuresCount() {
    let t7 = this.bb.__offset(this.bb_pos, 20);
    return t7 ? this.bb.readUint64(this.bb_pos + t7) : BigInt("0");
  }
  indexNodeSize() {
    let t7 = this.bb.__offset(this.bb_pos, 22);
    return t7 ? this.bb.readUint16(this.bb_pos + t7) : 16;
  }
  crs(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 24);
    return s2 ? (t7 || new Crs()).__init(this.bb.__indirect(this.bb_pos + s2), this.bb) : null;
  }
  title(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 26);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  description(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 28);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  metadata(t7) {
    let s2 = this.bb.__offset(this.bb_pos, 30);
    return s2 ? this.bb.__string(this.bb_pos + s2, t7) : null;
  }
  static startHeader(t7) {
    t7.startObject(14);
  }
  static addName(t7, s2) {
    t7.addFieldOffset(0, s2, 0);
  }
  static addEnvelope(t7, s2) {
    t7.addFieldOffset(1, s2, 0);
  }
  static createEnvelopeVector(t7, s2) {
    t7.startVector(8, s2.length, 8);
    for (let e4 = s2.length - 1; e4 >= 0; e4--) t7.addFloat64(s2[e4]);
    return t7.endVector();
  }
  static startEnvelopeVector(t7, s2) {
    t7.startVector(8, s2, 8);
  }
  static addGeometryType(t7, s2) {
    t7.addFieldInt8(2, s2, GeometryType.Unknown);
  }
  static addHasZ(t7, s2) {
    t7.addFieldInt8(3, +s2, 0);
  }
  static addHasM(t7, s2) {
    t7.addFieldInt8(4, +s2, 0);
  }
  static addHasT(t7, s2) {
    t7.addFieldInt8(5, +s2, 0);
  }
  static addHasTm(t7, s2) {
    t7.addFieldInt8(6, +s2, 0);
  }
  static addColumns(t7, s2) {
    t7.addFieldOffset(7, s2, 0);
  }
  static createColumnsVector(t7, s2) {
    t7.startVector(4, s2.length, 4);
    for (let e4 = s2.length - 1; e4 >= 0; e4--) t7.addOffset(s2[e4]);
    return t7.endVector();
  }
  static startColumnsVector(t7, s2) {
    t7.startVector(4, s2, 4);
  }
  static addFeaturesCount(t7, s2) {
    t7.addFieldInt64(8, s2, BigInt("0"));
  }
  static addIndexNodeSize(t7, s2) {
    t7.addFieldInt16(9, s2, 16);
  }
  static addCrs(t7, s2) {
    t7.addFieldOffset(10, s2, 0);
  }
  static addTitle(t7, s2) {
    t7.addFieldOffset(11, s2, 0);
  }
  static addDescription(t7, s2) {
    t7.addFieldOffset(12, s2, 0);
  }
  static addMetadata(t7, s2) {
    t7.addFieldOffset(13, s2, 0);
  }
  static endHeader(t7) {
    return t7.endObject();
  }
  static finishHeaderBuffer(t7, s2) {
    t7.finish(s2);
  }
  static finishSizePrefixedHeaderBuffer(t7, s2) {
    t7.finish(s2, void 0, true);
  }
};
var Geometry = class _Geometry {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(t7, e4) {
    return this.bb_pos = t7, this.bb = e4, this;
  }
  static getRootAsGeometry(t7, e4) {
    return (e4 || new _Geometry()).__init(t7.readInt32(t7.position()) + t7.position(), t7);
  }
  static getSizePrefixedRootAsGeometry(e4, s2) {
    return e4.setPosition(e4.position() + t.SIZE_PREFIX_LENGTH), (s2 || new _Geometry()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
  }
  ends(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 4);
    return e4 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e4) + 4 * t7) : 0;
  }
  endsLength() {
    let t7 = this.bb.__offset(this.bb_pos, 4);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  endsArray() {
    let t7 = this.bb.__offset(this.bb_pos, 4);
    return t7 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  xy(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 6);
    return e4 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e4) + 8 * t7) : 0;
  }
  xyLength() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  xyArray() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  z(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 8);
    return e4 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e4) + 8 * t7) : 0;
  }
  zLength() {
    let t7 = this.bb.__offset(this.bb_pos, 8);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  zArray() {
    let t7 = this.bb.__offset(this.bb_pos, 8);
    return t7 ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  m(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 10);
    return e4 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e4) + 8 * t7) : 0;
  }
  mLength() {
    let t7 = this.bb.__offset(this.bb_pos, 10);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  mArray() {
    let t7 = this.bb.__offset(this.bb_pos, 10);
    return t7 ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  t(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 12);
    return e4 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e4) + 8 * t7) : 0;
  }
  tLength() {
    let t7 = this.bb.__offset(this.bb_pos, 12);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  tArray() {
    let t7 = this.bb.__offset(this.bb_pos, 12);
    return t7 ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  tm(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 14);
    return e4 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e4) + 8 * t7) : BigInt(0);
  }
  tmLength() {
    let t7 = this.bb.__offset(this.bb_pos, 14);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  type() {
    let t7 = this.bb.__offset(this.bb_pos, 16);
    return t7 ? this.bb.readUint8(this.bb_pos + t7) : GeometryType.Unknown;
  }
  parts(t7, e4) {
    let s2 = this.bb.__offset(this.bb_pos, 18);
    return s2 ? (e4 || new _Geometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s2) + 4 * t7), this.bb) : null;
  }
  partsLength() {
    let t7 = this.bb.__offset(this.bb_pos, 18);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  static startGeometry(t7) {
    t7.startObject(8);
  }
  static addEnds(t7, e4) {
    t7.addFieldOffset(0, e4, 0);
  }
  static createEndsVector(t7, e4) {
    t7.startVector(4, e4.length, 4);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addInt32(e4[s2]);
    return t7.endVector();
  }
  static startEndsVector(t7, e4) {
    t7.startVector(4, e4, 4);
  }
  static addXy(t7, e4) {
    t7.addFieldOffset(1, e4, 0);
  }
  static createXyVector(t7, e4) {
    t7.startVector(8, e4.length, 8);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addFloat64(e4[s2]);
    return t7.endVector();
  }
  static startXyVector(t7, e4) {
    t7.startVector(8, e4, 8);
  }
  static addZ(t7, e4) {
    t7.addFieldOffset(2, e4, 0);
  }
  static createZVector(t7, e4) {
    t7.startVector(8, e4.length, 8);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addFloat64(e4[s2]);
    return t7.endVector();
  }
  static startZVector(t7, e4) {
    t7.startVector(8, e4, 8);
  }
  static addM(t7, e4) {
    t7.addFieldOffset(3, e4, 0);
  }
  static createMVector(t7, e4) {
    t7.startVector(8, e4.length, 8);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addFloat64(e4[s2]);
    return t7.endVector();
  }
  static startMVector(t7, e4) {
    t7.startVector(8, e4, 8);
  }
  static addT(t7, e4) {
    t7.addFieldOffset(4, e4, 0);
  }
  static createTVector(t7, e4) {
    t7.startVector(8, e4.length, 8);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addFloat64(e4[s2]);
    return t7.endVector();
  }
  static startTVector(t7, e4) {
    t7.startVector(8, e4, 8);
  }
  static addTm(t7, e4) {
    t7.addFieldOffset(5, e4, 0);
  }
  static createTmVector(t7, e4) {
    t7.startVector(8, e4.length, 8);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addInt64(e4[s2]);
    return t7.endVector();
  }
  static startTmVector(t7, e4) {
    t7.startVector(8, e4, 8);
  }
  static addType(t7, s2) {
    t7.addFieldInt8(6, s2, GeometryType.Unknown);
  }
  static addParts(t7, e4) {
    t7.addFieldOffset(7, e4, 0);
  }
  static createPartsVector(t7, e4) {
    t7.startVector(4, e4.length, 4);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addOffset(e4[s2]);
    return t7.endVector();
  }
  static startPartsVector(t7, e4) {
    t7.startVector(4, e4, 4);
  }
  static endGeometry(t7) {
    return t7.endObject();
  }
  static createGeometry(t7, e4, s2, b, r2, o2, i, _, h) {
    return _Geometry.startGeometry(t7), _Geometry.addEnds(t7, e4), _Geometry.addXy(t7, s2), _Geometry.addZ(t7, b), _Geometry.addM(t7, r2), _Geometry.addT(t7, o2), _Geometry.addTm(t7, i), _Geometry.addType(t7, _), _Geometry.addParts(t7, h), _Geometry.endGeometry(t7);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/feature.js
var Feature = class _Feature {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(t7, e4) {
    return this.bb_pos = t7, this.bb = e4, this;
  }
  static getRootAsFeature(t7, e4) {
    return (e4 || new _Feature()).__init(t7.readInt32(t7.position()) + t7.position(), t7);
  }
  static getSizePrefixedRootAsFeature(e4, s2) {
    return e4.setPosition(e4.position() + t.SIZE_PREFIX_LENGTH), (s2 || new _Feature()).__init(e4.readInt32(e4.position()) + e4.position(), e4);
  }
  geometry(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 4);
    return e4 ? (t7 || new Geometry()).__init(this.bb.__indirect(this.bb_pos + e4), this.bb) : null;
  }
  properties(t7) {
    let e4 = this.bb.__offset(this.bb_pos, 6);
    return e4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e4) + t7) : 0;
  }
  propertiesLength() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  propertiesArray() {
    let t7 = this.bb.__offset(this.bb_pos, 6);
    return t7 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t7), this.bb.__vector_len(this.bb_pos + t7)) : null;
  }
  columns(t7, s2) {
    let r2 = this.bb.__offset(this.bb_pos, 8);
    return r2 ? (s2 || new Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t7), this.bb) : null;
  }
  columnsLength() {
    let t7 = this.bb.__offset(this.bb_pos, 8);
    return t7 ? this.bb.__vector_len(this.bb_pos + t7) : 0;
  }
  static startFeature(t7) {
    t7.startObject(3);
  }
  static addGeometry(t7, e4) {
    t7.addFieldOffset(0, e4, 0);
  }
  static addProperties(t7, e4) {
    t7.addFieldOffset(1, e4, 0);
  }
  static createPropertiesVector(t7, e4) {
    t7.startVector(1, e4.length, 1);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addInt8(e4[s2]);
    return t7.endVector();
  }
  static startPropertiesVector(t7, e4) {
    t7.startVector(1, e4, 1);
  }
  static addColumns(t7, e4) {
    t7.addFieldOffset(2, e4, 0);
  }
  static createColumnsVector(t7, e4) {
    t7.startVector(4, e4.length, 4);
    for (let s2 = e4.length - 1; s2 >= 0; s2--) t7.addOffset(e4[s2]);
    return t7.endVector();
  }
  static startColumnsVector(t7, e4) {
    t7.startVector(4, e4, 4);
  }
  static endFeature(t7) {
    return t7.endObject();
  }
  static finishFeatureBuffer(t7, e4) {
    t7.finish(e4);
  }
  static finishSizePrefixedFeatureBuffer(t7, e4) {
    t7.finish(e4, void 0, true);
  }
  static createFeature(t7, e4, s2, r2) {
    return _Feature.startFeature(t7), _Feature.addGeometry(t7, e4), _Feature.addProperties(t7, s2), _Feature.addColumns(t7, r2), _Feature.endFeature(t7);
  }
};

// node_modules/flatgeobuf/lib/mjs/header-meta.js
function fromByteBuffer(t7) {
  let r2 = Header.getRootAsHeader(t7), i = r2.featuresCount(), n2 = r2.indexNodeSize(), o2 = [];
  for (let e4 = 0; e4 < r2.columnsLength(); e4++) {
    let t8 = r2.columns(e4);
    if (!t8) throw Error("Column unexpectedly missing");
    if (!t8.name()) throw Error("Column name unexpectedly missing");
    o2.push({ name: t8.name(), type: t8.type(), title: t8.title(), description: t8.description(), width: t8.width(), precision: t8.precision(), scale: t8.scale(), nullable: t8.nullable(), unique: t8.unique(), primary_key: t8.primaryKey() });
  }
  let l = r2.crs(), s2 = l ? { org: l.org(), code: l.code(), name: l.name(), description: l.description(), wkt: l.wkt(), code_string: l.codeString() } : null;
  return { geometryType: r2.geometryType(), columns: o2, envelope: null, featuresCount: Number(i), indexNodeSize: n2, crs: s2, title: r2.title(), description: r2.description(), metadata: r2.metadata() };
}

// node_modules/@repeaterjs/repeater/repeater.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject2(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject2(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t7[0] & 1) throw t7[1];
    return t7[1];
  }, trys: [], ops: [] }, f, y, t7, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t7 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t7 = y["return"]) && t7.call(y), 0) : y.next) && !(t7 = t7.call(y, op[1])).done) return t7;
      if (y = 0, t7) op = [op[0] & 2, t7.value];
      switch (op[0]) {
        case 0:
        case 1:
          t7 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t7 = _.trys, t7 = t7.length > 0 && t7[t7.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t7 || op[1] > t7[0] && op[1] < t7[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t7[1]) {
            _.label = t7[1];
            t7 = op;
            break;
          }
          if (t7 && _.label < t7[2]) {
            _.label = t7[2];
            _.ops.push(op);
            break;
          }
          if (t7[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e4) {
      op = [6, e4];
      y = 0;
    } finally {
      f = t7 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i >= o2.length) o2 = void 0;
      return { value: o2 && o2[i++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2]) i[n2] = function(v) {
      return new Promise(function(a, b) {
        q.push([n2, v, a, b]) > 1 || resume(n2, v);
      });
    };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e4) {
      settle(q[0][3], e4);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
var RepeaterOverflowError = (
  /** @class */
  function(_super) {
    __extends(RepeaterOverflowError2, _super);
    function RepeaterOverflowError2(message) {
      var _this = _super.call(this, message) || this;
      Object.defineProperty(_this, "name", {
        value: "RepeaterOverflowError",
        enumerable: false
      });
      if (typeof Object.setPrototypeOf === "function") {
        Object.setPrototypeOf(_this, _this.constructor.prototype);
      } else {
        _this.__proto__ = _this.constructor.prototype;
      }
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, _this.constructor);
      }
      return _this;
    }
    return RepeaterOverflowError2;
  }(Error)
);
(
  /** @class */
  (function() {
    function FixedBuffer2(capacity) {
      if (capacity < 0) {
        throw new RangeError("Capacity may not be less than 0");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(FixedBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FixedBuffer2.prototype, "full", {
      get: function() {
        return this._q.length >= this._c;
      },
      enumerable: false,
      configurable: true
    });
    FixedBuffer2.prototype.add = function(value) {
      if (this.full) {
        throw new Error("Buffer full");
      } else {
        this._q.push(value);
      }
    };
    FixedBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return FixedBuffer2;
  })()
);
(
  /** @class */
  (function() {
    function SlidingBuffer2(capacity) {
      if (capacity < 1) {
        throw new RangeError("Capacity may not be less than 1");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(SlidingBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SlidingBuffer2.prototype, "full", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    SlidingBuffer2.prototype.add = function(value) {
      while (this._q.length >= this._c) {
        this._q.shift();
      }
      this._q.push(value);
    };
    SlidingBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return SlidingBuffer2;
  })()
);
(
  /** @class */
  (function() {
    function DroppingBuffer2(capacity) {
      if (capacity < 1) {
        throw new RangeError("Capacity may not be less than 1");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(DroppingBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DroppingBuffer2.prototype, "full", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    DroppingBuffer2.prototype.add = function(value) {
      if (this._q.length < this._c) {
        this._q.push(value);
      }
    };
    DroppingBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return DroppingBuffer2;
  })()
);
function swallow(value) {
  if (value != null && typeof value.then === "function") {
    value.then(NOOP, NOOP);
  }
}
var Initial = 0;
var Started = 1;
var Stopped = 2;
var Done = 3;
var Rejected = 4;
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {
};
function consumeExecution(r2) {
  var err = r2.err;
  var execution = Promise.resolve(r2.execution).then(function(value) {
    if (err != null) {
      throw err;
    }
    return value;
  });
  r2.err = void 0;
  r2.execution = execution.then(function() {
    return void 0;
  }, function() {
    return void 0;
  });
  return r2.pending === void 0 ? execution : r2.pending.then(function() {
    return execution;
  });
}
function createIteration(r2, value) {
  var done = r2.state >= Done;
  return Promise.resolve(value).then(function(value2) {
    if (!done && r2.state >= Rejected) {
      return consumeExecution(r2).then(function(value3) {
        return {
          value: value3,
          done: true
        };
      });
    }
    return { value: value2, done };
  });
}
function stop(r2, err) {
  var e_1, _a;
  if (r2.state >= Stopped) {
    return;
  }
  r2.state = Stopped;
  r2.onnext();
  r2.onstop();
  if (r2.err == null) {
    r2.err = err;
  }
  if (r2.pushes.length === 0 && (typeof r2.buffer === "undefined" || r2.buffer.empty)) {
    finish(r2);
  } else {
    try {
      for (var _b = __values(r2.pushes), _d = _b.next(); !_d.done; _d = _b.next()) {
        var push_1 = _d.value;
        push_1.resolve();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }
}
function finish(r2) {
  var e_2, _a;
  if (r2.state >= Done) {
    return;
  }
  if (r2.state < Stopped) {
    stop(r2);
  }
  r2.state = Done;
  r2.buffer = void 0;
  try {
    for (var _b = __values(r2.nexts), _d = _b.next(); !_d.done; _d = _b.next()) {
      var next = _d.value;
      var execution = r2.pending === void 0 ? consumeExecution(r2) : r2.pending.then(function() {
        return consumeExecution(r2);
      });
      next.resolve(createIteration(r2, execution));
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  r2.pushes = [];
  r2.nexts = [];
}
function reject(r2) {
  if (r2.state >= Rejected) {
    return;
  }
  if (r2.state < Done) {
    finish(r2);
  }
  r2.state = Rejected;
}
function push(r2, value) {
  swallow(value);
  if (r2.pushes.length >= MAX_QUEUE_LENGTH) {
    throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
  } else if (r2.state >= Stopped) {
    return Promise.resolve(void 0);
  }
  var valueP = r2.pending === void 0 ? Promise.resolve(value) : r2.pending.then(function() {
    return value;
  });
  valueP = valueP.catch(function(err) {
    if (r2.state < Stopped) {
      r2.err = err;
    }
    reject(r2);
    return void 0;
  });
  var nextP;
  if (r2.nexts.length) {
    var next_1 = r2.nexts.shift();
    next_1.resolve(createIteration(r2, valueP));
    if (r2.nexts.length) {
      nextP = Promise.resolve(r2.nexts[0].value);
    } else if (typeof r2.buffer !== "undefined" && !r2.buffer.full) {
      nextP = Promise.resolve(void 0);
    } else {
      nextP = new Promise(function(resolve) {
        return r2.onnext = resolve;
      });
    }
  } else if (typeof r2.buffer !== "undefined" && !r2.buffer.full) {
    r2.buffer.add(valueP);
    nextP = Promise.resolve(void 0);
  } else {
    nextP = new Promise(function(resolve) {
      return r2.pushes.push({ resolve, value: valueP });
    });
  }
  var floating = true;
  var next = {};
  var unhandled = nextP.catch(function(err) {
    if (floating) {
      throw err;
    }
    return void 0;
  });
  next.then = function(onfulfilled, onrejected) {
    floating = false;
    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
  };
  next.catch = function(onrejected) {
    floating = false;
    return Promise.prototype.catch.call(nextP, onrejected);
  };
  next.finally = nextP.finally.bind(nextP);
  r2.pending = valueP.then(function() {
    return unhandled;
  }).catch(function(err) {
    r2.err = err;
    reject(r2);
  });
  return next;
}
function createStop(r2) {
  var stop1 = stop.bind(null, r2);
  var stopP = new Promise(function(resolve) {
    return r2.onstop = resolve;
  });
  stop1.then = stopP.then.bind(stopP);
  stop1.catch = stopP.catch.bind(stopP);
  stop1.finally = stopP.finally.bind(stopP);
  return stop1;
}
function execute(r2) {
  if (r2.state >= Started) {
    return;
  }
  r2.state = Started;
  var push1 = push.bind(null, r2);
  var stop1 = createStop(r2);
  r2.execution = new Promise(function(resolve) {
    return resolve(r2.executor(push1, stop1));
  });
  r2.execution.catch(function() {
    return stop(r2);
  });
}
var records = /* @__PURE__ */ new WeakMap();
var Repeater = (
  /** @class */
  function() {
    function Repeater2(executor, buffer) {
      records.set(this, {
        executor,
        buffer,
        err: void 0,
        state: Initial,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: NOOP,
        onstop: NOOP
      });
    }
    Repeater2.prototype.next = function(value) {
      swallow(value);
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      if (r2.nexts.length >= MAX_QUEUE_LENGTH) {
        throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
      }
      if (r2.state <= Initial) {
        execute(r2);
      }
      r2.onnext(value);
      if (typeof r2.buffer !== "undefined" && !r2.buffer.empty) {
        var result = createIteration(r2, r2.buffer.remove());
        if (r2.pushes.length) {
          var push_2 = r2.pushes.shift();
          r2.buffer.add(push_2.value);
          r2.onnext = push_2.resolve;
        }
        return result;
      } else if (r2.pushes.length) {
        var push_3 = r2.pushes.shift();
        r2.onnext = push_3.resolve;
        return createIteration(r2, push_3.value);
      } else if (r2.state >= Stopped) {
        finish(r2);
        return createIteration(r2, consumeExecution(r2));
      }
      return new Promise(function(resolve) {
        return r2.nexts.push({ resolve, value });
      });
    };
    Repeater2.prototype.return = function(value) {
      swallow(value);
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      finish(r2);
      r2.execution = Promise.resolve(r2.execution).then(function() {
        return value;
      });
      return createIteration(r2, consumeExecution(r2));
    };
    Repeater2.prototype.throw = function(err) {
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      if (r2.state <= Initial || r2.state >= Stopped || typeof r2.buffer !== "undefined" && !r2.buffer.empty) {
        finish(r2);
        if (r2.err == null) {
          r2.err = err;
        }
        return createIteration(r2, consumeExecution(r2));
      }
      return this.next(Promise.reject(err));
    };
    Repeater2.prototype[Symbol.asyncIterator] = function() {
      return this;
    };
    Repeater2.race = race;
    Repeater2.merge = merge;
    Repeater2.zip = zip;
    Repeater2.latest = latest;
    return Repeater2;
  }()
);
function getIterators(values, options) {
  var e_3, _a;
  var iters = [];
  var _loop_1 = function(value2) {
    if (value2 != null && typeof value2[Symbol.asyncIterator] === "function") {
      iters.push(value2[Symbol.asyncIterator]());
    } else if (value2 != null && typeof value2[Symbol.iterator] === "function") {
      iters.push(value2[Symbol.iterator]());
    } else {
      iters.push(function valueToAsyncIterator() {
        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!options.yieldValues) return [3, 3];
                return [4, __await(value2)];
              case 1:
                return [4, _a2.sent()];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (!options.returnValues) return [3, 5];
                return [4, __await(value2)];
              case 4:
                return [2, _a2.sent()];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }());
    }
  };
  try {
    for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
      var value = values_1_1.value;
      _loop_1(value);
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
  return iters;
}
function race(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, stopped, finalIteration, iteration, i_1, _loop_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [
                2
                /*return*/
              ];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            iteration = void 0;
            i_1 = 0;
            _loop_2 = function() {
              var j, iters_1, iters_1_1, iter;
              var e_4, _a2;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    j = i_1;
                    try {
                      for (iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()) {
                        iter = iters_1_1.value;
                        Promise.resolve(iter.next()).then(function(iteration2) {
                          if (iteration2.done) {
                            stop2();
                            if (finalIteration === void 0) {
                              finalIteration = iteration2;
                            }
                          } else if (i_1 === j) {
                            i_1++;
                            advance(iteration2);
                          }
                        }, function(err) {
                          return stop2(err);
                        });
                      }
                    } catch (e_4_1) {
                      e_4 = { error: e_4_1 };
                    } finally {
                      try {
                        if (iters_1_1 && !iters_1_1.done && (_a2 = iters_1.return)) _a2.call(iters_1);
                      } finally {
                        if (e_4) throw e_4.error;
                      }
                    }
                    return [4, new Promise(function(resolve) {
                      return advance = resolve;
                    })];
                  case 1:
                    iteration = _b.sent();
                    if (!(iteration !== void 0)) return [3, 3];
                    return [4, push2(iteration.value)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            _a.label = 2;
          case 2:
            if (!!stopped) return [3, 4];
            return [5, _loop_2()];
          case 3:
            _a.sent();
            return [3, 2];
          case 4:
            return [2, finalIteration && finalIteration.value];
          case 5:
            stop2();
            return [4, Promise.race(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function merge(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { yieldValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advances, stopped, finalIteration;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [
                2
                /*return*/
              ];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_5, _a2;
              stopped = true;
              try {
                for (var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()) {
                  var advance = advances_1_1.value;
                  advance();
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (advances_1_1 && !advances_1_1.done && (_a2 = advances_1.return)) _a2.call(advances_1);
                } finally {
                  if (e_5) throw e_5.error;
                }
              }
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, void 0, void 0, function() {
                var iteration, _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, , 6, 9]);
                      _b.label = 1;
                    case 1:
                      if (!!stopped) return [3, 5];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _b.sent();
                      if (!(iteration !== void 0)) return [3, 4];
                      if (iteration.done) {
                        finalIteration = iteration;
                        return [
                          2
                          /*return*/
                        ];
                      }
                      return [4, push2(iteration.value)];
                    case 3:
                      _b.sent();
                      _b.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      _a2 = iter.return;
                      if (!_a2) return [3, 8];
                      return [4, iter.return()];
                    case 7:
                      _a2 = _b.sent();
                      _b.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            _a.sent();
            return [2, finalIteration && finalIteration.value];
          case 3:
            stop2();
            return [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function zip(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, stopped, iterations, values;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 6, 8]);
            _a.label = 2;
          case 2:
            if (!!stopped) return [3, 5];
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations2) {
              return advance(iterations2);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 3:
            iterations = _a.sent();
            if (iterations === void 0) {
              return [
                2
                /*return*/
              ];
            }
            values = iterations.map(function(iteration) {
              return iteration.value;
            });
            if (iterations.some(function(iteration) {
              return iteration.done;
            })) {
              return [2, values];
            }
            return [4, push2(values)];
          case 4:
            _a.sent();
            return [3, 2];
          case 5:
            return [3, 8];
          case 6:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 7:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function latest(contenders) {
  var _this = this;
  var iters = getIterators(contenders, {
    yieldValues: true,
    returnValues: true
  });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, advances, stopped, iterations_1, values_2;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_6, _a2;
              advance();
              try {
                for (var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()) {
                  var advance1 = advances_2_1.value;
                  advance1();
                }
              } catch (e_6_1) {
                e_6 = { error: e_6_1 };
              } finally {
                try {
                  if (advances_2_1 && !advances_2_1.done && (_a2 = advances_2.return)) _a2.call(advances_2);
                } finally {
                  if (e_6) throw e_6.error;
                }
              }
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations) {
              return advance(iterations);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 2:
            iterations_1 = _a.sent();
            if (iterations_1 === void 0) {
              return [
                2
                /*return*/
              ];
            }
            values_2 = iterations_1.map(function(iteration) {
              return iteration.value;
            });
            if (iterations_1.every(function(iteration) {
              return iteration.done;
            })) {
              return [2, values_2];
            }
            return [4, push2(values_2.slice())];
          case 3:
            _a.sent();
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, void 0, void 0, function() {
                var iteration;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (iterations_1[i].done) {
                        return [2, iterations_1[i].value];
                      }
                      _a2.label = 1;
                    case 1:
                      if (!!stopped) return [3, 4];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        return advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _a2.sent();
                      if (iteration === void 0) {
                        return [2, iterations_1[i].value];
                      } else if (iteration.done) {
                        return [2, iteration.value];
                      }
                      values_2[i] = iteration.value;
                      return [4, push2(values_2.slice())];
                    case 3:
                      _a2.sent();
                      return [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, _a.sent()];
          case 5:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}

// node_modules/flatgeobuf/lib/mjs/config.js
var _e = class _e {
  constructor() {
    __publicField(this, "_extraRequestThreshold", 262144);
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e4) {
    if (e4 < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e4;
  }
};
__publicField(_e, "global", new _e());

// node_modules/flatgeobuf/lib/mjs/generic/geometry.js
function pairFlatCoordinates(t7, e4) {
  let r2 = [];
  for (let o2 = 0; o2 < t7.length; o2 += 2) {
    let n2 = [t7[o2], t7[o2 + 1]];
    e4 && n2.push(e4[o2 >> 1]), r2.push(n2);
  }
  return r2;
}

// node_modules/flatgeobuf/lib/mjs/generic/feature.js
new TextEncoder();
var s = new TextDecoder();
function parseProperties(e4, r2) {
  let a = {};
  if (!r2 || 0 === r2.length) return a;
  let n2 = e4.propertiesArray();
  if (!n2) return a;
  let o2 = new DataView(n2.buffer, n2.byteOffset), i = e4.propertiesLength(), l = 0;
  for (; l < i; ) {
    let e5 = o2.getUint16(l, true);
    l += 2;
    let i2 = r2[e5], c = i2.name;
    switch (i2.type) {
      case ColumnType.Bool:
        a[c] = !!o2.getUint8(l), l += 1;
        break;
      case ColumnType.Byte:
        a[c] = o2.getInt8(l), l += 1;
        break;
      case ColumnType.UByte:
        a[c] = o2.getUint8(l), l += 1;
        break;
      case ColumnType.Short:
        a[c] = o2.getInt16(l, true), l += 2;
        break;
      case ColumnType.UShort:
        a[c] = o2.getUint16(l, true), l += 2;
        break;
      case ColumnType.Int:
        a[c] = o2.getInt32(l, true), l += 4;
        break;
      case ColumnType.UInt:
        a[c] = o2.getUint32(l, true), l += 4;
        break;
      case ColumnType.Long:
        a[c] = Number(o2.getBigInt64(l, true)), l += 8;
        break;
      case ColumnType.ULong:
        a[c] = Number(o2.getBigUint64(l, true)), l += 8;
        break;
      case ColumnType.Float:
        a[c] = o2.getFloat32(l, true), l += 4;
        break;
      case ColumnType.Double:
        a[c] = o2.getFloat64(l, true), l += 8;
        break;
      case ColumnType.DateTime:
      case ColumnType.String: {
        let e6 = o2.getUint32(l, true);
        l += 4, a[c] = s.decode(n2.subarray(l, l + e6)), l += e6;
        break;
      }
      case ColumnType.Json: {
        let e6 = o2.getUint32(l, true);
        l += 4;
        let t7 = s.decode(n2.subarray(l, l + e6));
        a[c] = JSON.parse(t7), l += e6;
        break;
      }
      case ColumnType.Binary: {
        let e6 = o2.getUint32(l, true);
        l += 4, a[c] = n2.subarray(l, l + e6), l += e6;
        break;
      }
      default:
        throw Error(`Unknown type ${i2.type}`);
    }
  }
  return a;
}

// src/constants.ts
var VERSION = 3;
var MAGIC_BYTES = [102, 103, 98, VERSION, 102, 103, 98, 0];
var SIZE_PREFIX_LEN2 = 4;
var HEADER_FETCH_SIZE = 8192 * 4;
var QUERY_PLAN_DEFAULTS = {
  /**
   * Amount of space allowed between features before splitting requests.
   * If features are closer together than this, they will be fetched in a
   * single request to minimize network overhead.
   */
  overfetchBytes: 500 * 1024
  // 500KB
};
var DEFAULT_CACHE_SIZE = 5 * 1024 * 1024;

// src/fetch-manager.ts
var FetchManager = class {
  constructor(urlOrFetchRangeFn, maxCacheSize = DEFAULT_CACHE_SIZE) {
    this.inFlightRequests = /* @__PURE__ */ new Map();
    if (typeof urlOrFetchRangeFn === "string") {
      this.url = urlOrFetchRangeFn;
      this.fetchRangeFn = this.defaultFetchRange;
    } else {
      this.fetchRangeFn = urlOrFetchRangeFn;
    }
    this.cache = new LRUCache({
      maxSize: maxCacheSize,
      sizeCalculation: (value) => value.byteLength,
      updateAgeOnGet: true
    });
  }
  /**
   * Get cache statistics
   */
  get cacheStats() {
    return {
      count: this.cache.size,
      calculatedSize: this.cache.calculatedSize,
      maxSize: this.cache.maxSize,
      inFlightRequests: this.inFlightRequests.size
    };
  }
  /**
   * Clear the feature data cache
   */
  clearCache() {
    this.cache.clear();
    this.inFlightRequests.clear();
  }
  /**
   * Fetch a byte range from the source.
   *
   * The result is cached using an LRU cache to minimize network requests.
   *
   * @param range - [start (number), end (number | null)] byte range to fetch.
   *                End may be null to indicate the end of the file.
   * @returns Promise resolving to the fetched data as ArrayBuffer
   * @throws Error if source is misconfigured
   */
  async fetchRange(range) {
    const cacheKey = `${range[0]}-${range[1] ?? ""}`;
    const cached = this.cache.get(cacheKey);
    if (cached) {
      return cached;
    }
    const inFlightRequest = this.inFlightRequests.get(cacheKey);
    if (inFlightRequest) {
      return inFlightRequest;
    }
    const request = (async () => {
      try {
        const bytes3 = await this.fetchRangeFn(range);
        this.cache.set(cacheKey, bytes3);
        return bytes3;
      } finally {
        this.inFlightRequests.delete(cacheKey);
      }
    })();
    this.inFlightRequests.set(cacheKey, request);
    return request;
  }
  /**
   * Default fetch implementation using the fetch API.
   */
  async defaultFetchRange(range) {
    if (!this.url) {
      throw new Error("Misconfiguration: fetchRange called without url");
    }
    const response = await fetch(this.url, {
      headers: {
        Range: `bytes=${range[0]}-${range[1] ? range[1] : ""}`
      }
    });
    return response.arrayBuffer();
  }
};

// src/query-plan.ts
function createQueryPlan(results, featureDataOffset, options) {
  results.sort((a, b) => a[0] - b[0]);
  if (results.length === 0) {
    return [];
  } else if (results.length === 1) {
    const result = results[0];
    return [
      {
        range: toRange(result, featureDataOffset),
        offsets: [[0, result[1]]]
      }
    ];
  }
  const ranges = [];
  let offset = 0;
  const [start, length] = results[0];
  let currentRange = {
    range: toRange([start, length], featureDataOffset),
    offsets: [[0, length]]
  };
  offset = length;
  ranges.push(currentRange);
  const maxRangeSize = 1024 * 1024 * 10;
  const overfetchBytes = options.overfetchBytes ?? QUERY_PLAN_DEFAULTS.overfetchBytes;
  for (let i = 1; i < results.length; i++) {
    const [start2, length2] = results[i];
    const range = toRange([start2, length2], featureDataOffset);
    const distance = range[0] - currentRange.range[1] - 1;
    const mergedRangeSize = range[1] - currentRange.range[0];
    if (distance < overfetchBytes && mergedRangeSize < maxRangeSize && currentRange.offsets.length < 100) {
      currentRange.range[1] = range[1];
      offset += distance;
      currentRange.offsets.push([offset, length2]);
      offset += length2;
    } else {
      currentRange = {
        range,
        offsets: [[0, length2]]
      };
      offset = length2;
      ranges.push(currentRange);
    }
  }
  return ranges;
}
function toRange(offsetAndLength, featureDataOffset) {
  if (offsetAndLength[1] === null) {
    return [featureDataOffset + offsetAndLength[0], null];
  } else {
    return [
      featureDataOffset + offsetAndLength[0],
      featureDataOffset + offsetAndLength[0] + offsetAndLength[1] - 1
    ];
  }
}
async function* executeQueryPlan(plan, fetchRange, options = {}) {
  const fetchPromises = plan.map(async ({ range, offsets }, i) => {
    const data = await fetchRange(range);
    return { data, offsets, i };
  });
  const pendingFetches = new Set(plan.map((_, i) => i));
  while (pendingFetches.size > 0) {
    const completedFetch = await Promise.race(
      [...pendingFetches].map((i) => fetchPromises[i])
    );
    pendingFetches.delete(completedFetch.i);
    const { data, offsets } = completedFetch;
    const view = new DataView(data);
    for (let [offset, length] of offsets) {
      if (length === null) {
        length = view.buffer.byteLength - offset;
      }
      const featureView = new DataView(data, offset, length);
      yield [featureView, offset];
    }
  }
}

// node_modules/flatgeobuf/lib/mjs/geojson/geometry.js
function fromGeometry(t7, o2) {
  let n2 = o2;
  if (n2 === GeometryType.Unknown && (n2 = t7.type()), n2 === GeometryType.GeometryCollection) {
    let r2 = [];
    for (let e4 = 0; e4 < t7.partsLength(); e4++) {
      let o3 = t7.parts(e4), n3 = o3.type();
      r2.push(fromGeometry(o3, n3));
    }
    return { type: GeometryType[n2], geometries: r2 };
  }
  if (n2 === GeometryType.MultiPolygon) {
    let r2 = [];
    for (let o3 = 0; o3 < t7.partsLength(); o3++) r2.push(fromGeometry(t7.parts(o3), GeometryType.Polygon));
    return { type: GeometryType[n2], coordinates: r2.map((e4) => e4.coordinates) };
  }
  let i = function(t8, o3) {
    let n3 = t8.xyArray(), i2 = t8.zArray();
    switch (o3) {
      case GeometryType.Point: {
        let e4 = Array.from(n3);
        return i2 && e4.push(i2[0]), e4;
      }
      case GeometryType.MultiPoint:
      case GeometryType.LineString:
        return pairFlatCoordinates(n3, i2);
      case GeometryType.MultiLineString:
      case GeometryType.Polygon:
        return function(e4, t9, o4) {
          let n4;
          if (!o4 || 0 === o4.length) return [pairFlatCoordinates(e4, t9)];
          let i3 = 0, a = Array.from(o4).map((t10) => e4.slice(i3, i3 = t10 << 1));
          return t9 && (i3 = 0, n4 = Array.from(o4).map((e5) => t9.slice(i3, i3 = e5))), a.map((e5, t10) => pairFlatCoordinates(e5, n4 ? n4[t10] : void 0));
        }(n3, i2, t8.endsArray());
    }
  }(t7, n2);
  return { type: GeometryType[n2], coordinates: i };
}

// node_modules/flatgeobuf/lib/mjs/geojson/feature.js
function fromFeature(t7, o2, m) {
  let p = m.columns;
  return { type: "Feature", id: t7, geometry: fromGeometry(o2.geometry(), m.geometryType), properties: parseProperties(o2, p) };
}
function validateFeatureData(view, size) {
  view.getUint32(0, true);
}
function parseFeatureData(offset, bytesAligned, header) {
  const bb = new ByteBuffer(bytesAligned);
  bb.setPosition(SIZE_PREFIX_LEN2);
  const feature = fromFeature(offset, Feature.getRootAsFeature(bb), header);
  return {
    ...feature,
    properties: {
      ...feature.properties,
      __byteLength: bytesAligned.byteLength,
      __offset: offset
    }
  };
}
function parseProperties2(bb, columns, offset) {
  const feature = Feature.getRootAsFeature(bb);
  const props = parseProperties(feature, columns);
  return {
    ...props,
    __byteLength: bb.capacity(),
    __offset: offset
  };
}
function parseByteSize(size) {
  if (size === void 0 || size === null) return void 0;
  if (typeof size === "number") return size;
  return bytes(size) ?? void 0;
}
var FlatGeobufSource = class {
  /**
   * Should not be called directly. Instead initialize using createSource(),
   * which will generate the necessary metadata and spatial index.
   */
  constructor(urlOrFetchRangeFn, header, index, featureDataOffset, maxCacheSize = DEFAULT_CACHE_SIZE, overfetchBytes) {
    if (typeof urlOrFetchRangeFn === "string") {
      this.url = urlOrFetchRangeFn;
    } else {
      this.fetchRangeFn = urlOrFetchRangeFn;
    }
    this.header = header;
    this.index = index;
    this.featureDataOffset = featureDataOffset;
    this.fetchManager = new FetchManager(
      urlOrFetchRangeFn,
      parseByteSize(maxCacheSize)
    );
    this.overfetchBytes = parseByteSize(overfetchBytes);
  }
  /**
   * Get cache statistics
   */
  get cacheStats() {
    return this.fetchManager.cacheStats;
  }
  /**
   * Clear the feature data cache
   */
  clearCache() {
    this.fetchManager.clearCache();
  }
  /**
   * Bounds of the source, as determined from the spatial index.
   */
  get bounds() {
    return {
      minX: this.index.minX,
      minY: this.index.minY,
      maxX: this.index.maxX,
      maxY: this.index.maxY
    };
  }
  /**
   * Size of the index in bytes, which approximates the size this data source
   * occupies in memory.
   */
  get indexSizeBytes() {
    return this.index.byteLength;
  }
  /**
   * Geometry type of the source.
   */
  get geometryType() {
    return GeometryType[this.header.geometryType];
  }
  /**
   * Get features within a bounding box. Features are streamed to minimize
   * memory usage. Each feature is deserialized to GeoJSON before being yielded.
   *
   * Memory usage is minimized by deserializing features to GeoJSON individually
   * before yielding them. If you need to minimize memory usage in an
   * environment like cloudflare workers, you need only concern yourself with
   * the memory usage of the binary bytes fetched + the GeoJSON size of only
   * the single largest feature being processed at any given time.
   *
   * @param bbox - Single bounding box or array of bounding boxes to query
   * @param options - Query options
   * @returns AsyncGenerator yielding GeoJSON features with metadata
   *
   * @example
   * ```typescript
   * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
   * for await (const feature of source.getFeaturesAsync(bbox)) {
   *   console.log(feature);
   * }
   * ```
   */
  async *getFeaturesAsync(bbox, options) {
    options = {
      ...QUERY_PLAN_DEFAULTS,
      ...options,
      overfetchBytes: this.overfetchBytes ?? options?.overfetchBytes
    };
    let queryPlan = [];
    if (!Array.isArray(bbox)) {
      bbox = [bbox];
    }
    for (const b of bbox) {
      if (!this.index) {
        throw new Error("Spatial index not available");
      }
      const results = await this.index.search(b.minX, b.minY, b.maxX, b.maxY);
      const plan = createQueryPlan(results, this.featureDataOffset, options);
      for (const part of plan) {
        const existing = queryPlan.find(
          (p) => p.range[0] === part.range[0] && p.range[1] === part.range[1]
        );
        if (!existing) {
          queryPlan.push(part);
        }
      }
    }
    let bytes3 = 0;
    for (const { range } of queryPlan) {
      bytes3 += range[1] ? range[1] - range[0] : 0;
    }
    for await (const [data, offset] of executeQueryPlan(
      queryPlan,
      this.fetchManager.fetchRange.bind(this.fetchManager),
      options
    )) {
      if (options.warmCache) {
        continue;
      }
      const bytes4 = new Uint8Array(data.buffer);
      const bytesAligned = new Uint8Array(data.byteLength);
      bytesAligned.set(
        bytes4.slice(data.byteOffset, data.byteOffset + data.byteLength),
        0
      );
      const feature = parseFeatureData(offset, bytesAligned, this.header);
      yield feature;
    }
  }
  /**
   * Scan all features in the source. Does not use the spatial index, but
   * rather fetches the entire feature data section and iterates through it.
   *
   * Features are not deserialized to GeoJSON until they are yielded, reducing
   * memory usage.
   *
   * @returns AsyncGenerator yielding GeoJSON features with metadata
   *
   * @example
   * ```typescript
   * for await (const feature of source.scanAllFeatures()) {
   *   console.log(feature);
   * }
   * ```
   */
  async *scanAllFeatures() {
    const data = await this.fetchManager.fetchRange([
      this.featureDataOffset,
      null
    ]);
    const view = new DataView(data);
    let offset = 0;
    while (offset < data.byteLength) {
      const size = view.getUint32(offset, true);
      const bytesAligned = new Uint8Array(data, offset, size + SIZE_PREFIX_LEN2);
      validateFeatureData(view);
      const feature = parseFeatureData(offset, bytesAligned, this.header);
      yield feature;
      offset += size + SIZE_PREFIX_LEN2;
    }
  }
  async *getFeatureProperties() {
    const data = await this.fetchManager.fetchRange([
      this.featureDataOffset,
      null
    ]);
    const view = new DataView(data);
    let offset = 0;
    while (offset < data.byteLength) {
      const size = view.getUint32(offset, true);
      const bytesAligned = new Uint8Array(data, offset, size + SIZE_PREFIX_LEN2);
      const bb = new ByteBuffer(bytesAligned);
      bb.setPosition(SIZE_PREFIX_LEN2);
      yield {
        properties: parseProperties2(bb, this.header.columns, offset)
      };
      offset += size + SIZE_PREFIX_LEN2;
    }
  }
};
async function createSource(urlOrKey, options) {
  const fetchRangeFnOption = options?.fetchRangeFn;
  const maxCacheSize = parseByteSize(options?.maxCacheSize);
  const initialHeaderRequestLength = parseByteSize(options?.initialHeaderRequestLength) ?? HEADER_FETCH_SIZE;
  const overfetchBytes = parseByteSize(options?.overfetchBytes);
  const fetchRange = fetchRangeFnOption && typeof fetchRangeFnOption === "function" ? (range) => {
    return fetchRangeFnOption(urlOrKey, range);
  } : (range) => {
    return fetch(urlOrKey, {
      headers: { Range: `bytes=${range[0]}-${range[1] ? range[1] : ""}` }
    }).then((response) => response.arrayBuffer());
  };
  let headerData = await fetchRange([0, initialHeaderRequestLength]);
  const view = new DataView(headerData);
  for (let i = 0; i < MAGIC_BYTES.length; i++) {
    if (view.getUint8(i) !== MAGIC_BYTES[i] && i < MAGIC_BYTES.length - 1) {
      throw new Error(
        "Invalid FlatGeobuf file (magic bytes mismatch). " + urlOrKey
      );
    }
  }
  const offset = MAGIC_BYTES.length + 4;
  const bb = new ByteBuffer(new Uint8Array(headerData, offset));
  const headerSize = view.getUint32(MAGIC_BYTES.length, true);
  const header = fromByteBuffer(bb);
  const featuresCount = header.featuresCount;
  const indexNodeSize = header.indexNodeSize;
  if (!indexNodeSize) {
    throw new Error("FlatGeobuf file does not contain a spatial index");
  }
  const rtreeDetails = calculatePackedRTreeDetails(
    featuresCount,
    indexNodeSize
  );
  const indexSize = rtreeDetails.nodesByteSize;
  const indexOffset = headerSize + MAGIC_BYTES.length + 4;
  if (headerData.byteLength < indexOffset + indexSize) {
    headerData = await fetchRange([0, indexOffset + indexSize]);
  }
  const indexData = headerData.slice(indexOffset, indexOffset + indexSize);
  const index = new RTreeIndex(indexData, rtreeDetails);
  const source = new FlatGeobufSource(
    fetchRange,
    header,
    index,
    indexOffset + indexSize,
    maxCacheSize,
    overfetchBytes
  );
  return source;
}
var SourceCache = class {
  /**
   * Create a new SourceCache instance.
   *
   * @param sizeLimit - Maximum size of the cache, parseable by the bytes library.
   *                   Examples: '100MB', '1GB', '500KB'
   * @param options - Optional configuration object
   *   - onEvict: Callback called when a source is evicted from the cache. Receives (key, source, reason).
   *   - fetchRangeFn: Default fetch function to use when creating sources. Will be merged with options passed to get().
   *   - maxCacheSize: Default maximum cache size for sources. Will be merged with options passed to get().
   *   - initialHeaderRequestLength: Default initial header request length. Will be merged with options passed to get().
   *   - overfetchBytes: Default overfetch bytes. Will be merged with options passed to get().
   * @throws Error if sizeLimit is invalid
   */
  constructor(sizeLimit, options) {
    const size = bytes(sizeLimit);
    if (size === null) {
      throw new Error(`Invalid size limit: ${sizeLimit}`);
    }
    this.sizeLimitBytes = size;
    this.inFlightRequests = /* @__PURE__ */ new Map();
    this.onEvict = options?.onEvict;
    this.defaultOptions = {
      fetchRangeFn: options?.fetchRangeFn,
      maxCacheSize: options?.maxCacheSize,
      initialHeaderRequestLength: options?.initialHeaderRequestLength,
      overfetchBytes: options?.overfetchBytes
    };
    this.cache = new LRUCache({
      maxSize: this.sizeLimitBytes,
      sizeCalculation: (source, key) => {
        const size2 = source.indexSizeBytes + source.cacheStats.maxSize;
        return size2;
      },
      dispose: (value, key, reason) => {
        if (this.onEvict) {
          this.onEvict(key, value, reason);
        }
      }
    });
  }
  /**
   * Get a FlatGeobufSource instance for the given key. If the source is already
   * cached, returns the cached instance. Otherwise, creates a new source and
   * caches it.
   *
   * @param key - URL or key to fetch the source from
   * @param options - Options for creating the source if it needs to be created. These will be merged with default options from the constructor.
   * @returns Promise resolving to a FlatGeobufSource instance
   *
   * @example
   * ```typescript
   * const sourceCache = new SourceCache('64mb');
   * // Basic usage with default options
   * const source = await sourceCache.get('https://example.com/data.fgb');
   *
   * // Customize feature data cache size
   * const source = await sourceCache.get('https://example.com/data.fgb', {
   *   maxCacheSize: 1024 * 1024 // 1MB feature cache
   * });
   *
   * // Use custom fetch implementation (e.g. for R2 bucket)
   * const source = await sourceCache.get('fgb-object-key', {
   *   fetchRangeFn: async (key, range) => {
   *     const response = await fetch(`https://my-bucket.r2.dev/${key}`, {
   *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
   *     });
   *     return response.arrayBuffer();
   *   }
   * });
   *
   * // With default fetch function set in constructor
   * const sourceCache = new SourceCache('64mb', {
   *   fetchRangeFn: async (key, range) => {
   *     const response = await fetch(`https://uploads.seasketch.org/${key}`, {
   *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
   *     });
   *     return response.arrayBuffer();
   *   }
   * });
   * // Now you can use get() without specifying fetchRangeFn each time
   * const source = await sourceCache.get('my-data.fgb');
   *
   * // Query features within a bounding box
   * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
   * for await (const feature of source.getFeaturesAsync(bbox)) {
   *   console.log(feature);
   * }
   * ```
   */
  async get(key, options) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const inFlightRequest = this.inFlightRequests.get(key);
    if (inFlightRequest) {
      return inFlightRequest;
    }
    const mergedOptions = {
      ...this.defaultOptions,
      ...options
    };
    const request = (async () => {
      try {
        const source = await createSource(key, mergedOptions);
        this.cache.set(key, source);
        return source;
      } finally {
        this.inFlightRequests.delete(key);
      }
    })();
    this.inFlightRequests.set(key, request);
    return request;
  }
};
/*! Bundled license information:

@repeaterjs/repeater/repeater.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/

export { FlatGeobufSource, SourceCache, createSource };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map