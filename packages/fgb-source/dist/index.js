'use strict';

var lruCache = require('lru-cache');
var bytes = require('bytes');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var bytes__default = /*#__PURE__*/_interopDefault(bytes);

// src/rtree.ts
var NODE_ITEM_BYTE_LENGTH = 8 * 4 + 8;
var RTreeIndex = class {
  /**
   * Creates a new RTreeIndex instance.
   *
   * @param data - The packed R-tree index data
   * @param details - Details about the R-tree structure. Generated by
   *   `calculatePackedRTreeDetails`.
   * @throws Error if data is empty or details are invalid
   */
  constructor(data, details) {
    this.details = details;
    if (!data.byteLength) {
      throw new Error("data is empty");
    }
    this.view = new DataView(data);
    this.byteLength = data.byteLength;
    if (details.featureCount === void 0) {
      throw new Error("numItems is undefined");
    } else if (isNaN(details.featureCount) || details.featureCount < 0) {
      throw new Error("numItems is invalid");
    }
    const rootBounds = this.getNodeData(0);
    this.minX = rootBounds.minX;
    this.minY = rootBounds.minY;
    this.maxX = rootBounds.maxX;
    this.maxY = rootBounds.maxY;
  }
  /**
   * Search for features within a bounding box.
   *
   * The search is performed using a top-down traversal of the R-tree.
   * Results are returned as an array of [offset, length] tuples, where
   * length is null for the last feature in the file.
   *
   * @param minX - Minimum X coordinate of the search box
   * @param minY - Minimum Y coordinate of the search box
   * @param maxX - Maximum X coordinate of the search box
   * @param maxY - Maximum Y coordinate of the search box
   * @returns Promise resolving to array of [offset, length] tuples
   */
  async search(minX, minY, maxX, maxY) {
    let nodeIndex = 0;
    const queue = [];
    const results = [];
    while (nodeIndex !== void 0) {
      const end = Math.min(
        nodeIndex + this.details.nodeSize,
        // upperBound calculates the last position of the current level
        upperBound(nodeIndex, this.details.levels)
      );
      for (let pos = nodeIndex; pos < end; pos++) {
        const node = this.getNodeData(pos);
        if (maxX < node.minX || maxY < node.minY || minX > node.maxX || minY > node.maxY) {
          continue;
        }
        if (node.isLeaf) {
          const nextLeafPosition = pos + 1;
          let length = null;
          if (nextLeafPosition < this.details.numNodes) {
            const nextLeaf = this.getNodeData(nextLeafPosition);
            length = nextLeaf.offset - node.offset;
          }
          results.push([node.offset, length]);
        } else {
          queue.push(Number(node.offset));
        }
      }
      nodeIndex = queue.pop();
    }
    return results;
  }
  /**
   * Get the data for a node at the specified index.
   *
   * @param index - Index of the node
   * @returns Object containing node bounds, offset, and whether it's a leaf node
   * @private
   */
  getNodeData(index) {
    const byteIndex = index * NODE_ITEM_BYTE_LENGTH;
    return {
      minX: this.view.getFloat64(byteIndex, true),
      minY: this.view.getFloat64(byteIndex + 8, true),
      maxX: this.view.getFloat64(byteIndex + 16, true),
      maxY: this.view.getFloat64(byteIndex + 24, true),
      // The offset is a uint64, so we need to use getBigUint64. Theres no
      // sense in supporting files up to 9k terabytes, so we can safely use
      // Number() for ergonomics.
      offset: Number(this.view.getBigUint64(byteIndex + 32, true)),
      isLeaf: index >= this.details.levels[this.details.levels.length - 2]
    };
  }
  /**
   * Returns the byte offset (relative to feature data start) of the last feature.
   */
  getLastFeatureOffset() {
    const lastIndex = this.details.numNodes - 1;
    const node = this.getNodeData(lastIndex);
    return Number(node.offset);
  }
};
function calculatePackedRTreeDetails(featureCount, indexNodeSize) {
  const nodeSize = Math.min(Math.max(+indexNodeSize, 2), 65535);
  const numItems = featureCount;
  let n2 = numItems;
  let numNodes = 0;
  let treeHeight = 0;
  const nodesPerLevel = [n2];
  do {
    treeHeight++;
    numNodes += n2;
    n2 = Math.ceil(n2 / nodeSize);
    nodesPerLevel.push(n2);
  } while (n2 > 1);
  numNodes++;
  const levels = [];
  let position = 0;
  while (nodesPerLevel.length) {
    n2 = nodesPerLevel.pop();
    position += n2;
    levels.push(position);
  }
  return {
    nodeSize,
    numNodes,
    nodesByteSize: numNodes * NODE_ITEM_BYTE_LENGTH,
    treeHeight,
    levels,
    featureCount
  };
}
function upperBound(value, arr) {
  let i = 0;
  let j = arr.length - 1;
  while (i < j) {
    const m = i + j >> 1;
    if (arr[m] > value) {
      j = m;
    } else {
      i = m + 1;
    }
  }
  return arr[i];
}

// node_modules/flatbuffers/mjs/constants.js
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;

// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

// node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function(Encoding2) {
  Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

// node_modules/flatbuffers/mjs/byte-buffer.js
var ByteBuffer = class _ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new _ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readUint64(offset) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readFloat32(offset) {
    int32[0] = this.readInt32(offset);
    return float32[0];
  }
  readFloat64(offset) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset, value) {
    float32[0] = value;
    this.writeInt32(offset, int32[0]);
  }
  writeFloat64(offset, value) {
    float64[0] = value;
    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    offset += SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset, offset + length);
    if (opt_encoding === Encoding.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o2, offset) {
    if (typeof o2 === "string") {
      return this.__string(offset);
    }
    return this.__union(o2, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/column-type.js
var o;
var ColumnType = ((o = {})[o.Byte = 0] = "Byte", o[o.UByte = 1] = "UByte", o[o.Bool = 2] = "Bool", o[o.Short = 3] = "Short", o[o.UShort = 4] = "UShort", o[o.Int = 5] = "Int", o[o.UInt = 6] = "UInt", o[o.Long = 7] = "Long", o[o.ULong = 8] = "ULong", o[o.Float = 9] = "Float", o[o.Double = 10] = "Double", o[o.String = 11] = "String", o[o.Json = 12] = "Json", o[o.DateTime = 13] = "DateTime", o[o.Binary = 14] = "Binary", o);

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/column.js
var Column = class _Column {
  bb = null;
  bb_pos = 0;
  __init(t, s2) {
    return this.bb_pos = t, this.bb = s2, this;
  }
  static getRootAsColumn(t, s2) {
    return (s2 || new _Column()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsColumn(s2, i) {
    return s2.setPosition(s2.position() + SIZE_PREFIX_LENGTH), (i || new _Column()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  name(t) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  type() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb_pos + t) : ColumnType.Byte;
  }
  title(t) {
    let s2 = this.bb.__offset(this.bb_pos, 8);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  description(t) {
    let s2 = this.bb.__offset(this.bb_pos, 10);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  width() {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readInt32(this.bb_pos + t) : -1;
  }
  precision() {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readInt32(this.bb_pos + t) : -1;
  }
  scale() {
    let t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.readInt32(this.bb_pos + t) : -1;
  }
  nullable() {
    let t = this.bb.__offset(this.bb_pos, 18);
    return !t || !!this.bb.readInt8(this.bb_pos + t);
  }
  unique() {
    let t = this.bb.__offset(this.bb_pos, 20);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  primaryKey() {
    let t = this.bb.__offset(this.bb_pos, 22);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  metadata(t) {
    let s2 = this.bb.__offset(this.bb_pos, 24);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  static startColumn(t) {
    t.startObject(11);
  }
  static addName(t, s2) {
    t.addFieldOffset(0, s2, 0);
  }
  static addType(t, i) {
    t.addFieldInt8(1, i, ColumnType.Byte);
  }
  static addTitle(t, s2) {
    t.addFieldOffset(2, s2, 0);
  }
  static addDescription(t, s2) {
    t.addFieldOffset(3, s2, 0);
  }
  static addWidth(t, s2) {
    t.addFieldInt32(4, s2, -1);
  }
  static addPrecision(t, s2) {
    t.addFieldInt32(5, s2, -1);
  }
  static addScale(t, s2) {
    t.addFieldInt32(6, s2, -1);
  }
  static addNullable(t, s2) {
    t.addFieldInt8(7, +s2, 1);
  }
  static addUnique(t, s2) {
    t.addFieldInt8(8, +s2, 0);
  }
  static addPrimaryKey(t, s2) {
    t.addFieldInt8(9, +s2, 0);
  }
  static addMetadata(t, s2) {
    t.addFieldOffset(10, s2, 0);
  }
  static endColumn(t) {
    let s2 = t.endObject();
    return t.requiredField(s2, 4), s2;
  }
  static createColumn(t, s2, i, e2, b, d, n2, a, o2, l, r2, _) {
    return _Column.startColumn(t), _Column.addName(t, s2), _Column.addType(t, i), _Column.addTitle(t, e2), _Column.addDescription(t, b), _Column.addWidth(t, d), _Column.addPrecision(t, n2), _Column.addScale(t, a), _Column.addNullable(t, o2), _Column.addUnique(t, l), _Column.addPrimaryKey(t, r2), _Column.addMetadata(t, _), _Column.endColumn(t);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/crs.js
var Crs = class _Crs {
  bb = null;
  bb_pos = 0;
  __init(t, s2) {
    return this.bb_pos = t, this.bb = s2, this;
  }
  static getRootAsCrs(t, s2) {
    return (s2 || new _Crs()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsCrs(s2, i) {
    return s2.setPosition(s2.position() + SIZE_PREFIX_LENGTH), (i || new _Crs()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  org(t) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  code() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  name(t) {
    let s2 = this.bb.__offset(this.bb_pos, 8);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  description(t) {
    let s2 = this.bb.__offset(this.bb_pos, 10);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  wkt(t) {
    let s2 = this.bb.__offset(this.bb_pos, 12);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  codeString(t) {
    let s2 = this.bb.__offset(this.bb_pos, 14);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  static startCrs(t) {
    t.startObject(6);
  }
  static addOrg(t, s2) {
    t.addFieldOffset(0, s2, 0);
  }
  static addCode(t, s2) {
    t.addFieldInt32(1, s2, 0);
  }
  static addName(t, s2) {
    t.addFieldOffset(2, s2, 0);
  }
  static addDescription(t, s2) {
    t.addFieldOffset(3, s2, 0);
  }
  static addWkt(t, s2) {
    t.addFieldOffset(4, s2, 0);
  }
  static addCodeString(t, s2) {
    t.addFieldOffset(5, s2, 0);
  }
  static endCrs(t) {
    return t.endObject();
  }
  static createCrs(t, s2, i, e2, r2, b, d) {
    return _Crs.startCrs(t), _Crs.addOrg(t, s2), _Crs.addCode(t, i), _Crs.addName(t, e2), _Crs.addDescription(t, r2), _Crs.addWkt(t, b), _Crs.addCodeString(t, d), _Crs.endCrs(t);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/geometry-type.js
var r;
var GeometryType = ((r = {})[r.Unknown = 0] = "Unknown", r[r.Point = 1] = "Point", r[r.LineString = 2] = "LineString", r[r.Polygon = 3] = "Polygon", r[r.MultiPoint = 4] = "MultiPoint", r[r.MultiLineString = 5] = "MultiLineString", r[r.MultiPolygon = 6] = "MultiPolygon", r[r.GeometryCollection = 7] = "GeometryCollection", r[r.CircularString = 8] = "CircularString", r[r.CompoundCurve = 9] = "CompoundCurve", r[r.CurvePolygon = 10] = "CurvePolygon", r[r.MultiCurve = 11] = "MultiCurve", r[r.MultiSurface = 12] = "MultiSurface", r[r.Curve = 13] = "Curve", r[r.Surface = 14] = "Surface", r[r.PolyhedralSurface = 15] = "PolyhedralSurface", r[r.TIN = 16] = "TIN", r[r.Triangle = 17] = "Triangle", r);

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/header.js
var Header = class _Header {
  bb = null;
  bb_pos = 0;
  __init(t, s2) {
    return this.bb_pos = t, this.bb = s2, this;
  }
  static getRootAsHeader(t, s2) {
    return (s2 || new _Header()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsHeader(s2, e2) {
    return s2.setPosition(s2.position() + SIZE_PREFIX_LENGTH), (e2 || new _Header()).__init(s2.readInt32(s2.position()) + s2.position(), s2);
  }
  name(t) {
    let s2 = this.bb.__offset(this.bb_pos, 4);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  envelope(t) {
    let s2 = this.bb.__offset(this.bb_pos, 6);
    return s2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + s2) + 8 * t) : 0;
  }
  envelopeLength() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  envelopeArray() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  geometryType() {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readUint8(this.bb_pos + t) : GeometryType.Unknown;
  }
  hasZ() {
    let t = this.bb.__offset(this.bb_pos, 10);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  hasM() {
    let t = this.bb.__offset(this.bb_pos, 12);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  hasT() {
    let t = this.bb.__offset(this.bb_pos, 14);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  hasTm() {
    let t = this.bb.__offset(this.bb_pos, 16);
    return !!t && !!this.bb.readInt8(this.bb_pos + t);
  }
  columns(t, e2) {
    let i = this.bb.__offset(this.bb_pos, 18);
    return i ? (e2 || new Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * t), this.bb) : null;
  }
  columnsLength() {
    let t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  featuresCount() {
    let t = this.bb.__offset(this.bb_pos, 20);
    return t ? this.bb.readUint64(this.bb_pos + t) : BigInt("0");
  }
  indexNodeSize() {
    let t = this.bb.__offset(this.bb_pos, 22);
    return t ? this.bb.readUint16(this.bb_pos + t) : 16;
  }
  crs(t) {
    let s2 = this.bb.__offset(this.bb_pos, 24);
    return s2 ? (t || new Crs()).__init(this.bb.__indirect(this.bb_pos + s2), this.bb) : null;
  }
  title(t) {
    let s2 = this.bb.__offset(this.bb_pos, 26);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  description(t) {
    let s2 = this.bb.__offset(this.bb_pos, 28);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  metadata(t) {
    let s2 = this.bb.__offset(this.bb_pos, 30);
    return s2 ? this.bb.__string(this.bb_pos + s2, t) : null;
  }
  static startHeader(t) {
    t.startObject(14);
  }
  static addName(t, s2) {
    t.addFieldOffset(0, s2, 0);
  }
  static addEnvelope(t, s2) {
    t.addFieldOffset(1, s2, 0);
  }
  static createEnvelopeVector(t, s2) {
    t.startVector(8, s2.length, 8);
    for (let e2 = s2.length - 1; e2 >= 0; e2--) t.addFloat64(s2[e2]);
    return t.endVector();
  }
  static startEnvelopeVector(t, s2) {
    t.startVector(8, s2, 8);
  }
  static addGeometryType(t, s2) {
    t.addFieldInt8(2, s2, GeometryType.Unknown);
  }
  static addHasZ(t, s2) {
    t.addFieldInt8(3, +s2, 0);
  }
  static addHasM(t, s2) {
    t.addFieldInt8(4, +s2, 0);
  }
  static addHasT(t, s2) {
    t.addFieldInt8(5, +s2, 0);
  }
  static addHasTm(t, s2) {
    t.addFieldInt8(6, +s2, 0);
  }
  static addColumns(t, s2) {
    t.addFieldOffset(7, s2, 0);
  }
  static createColumnsVector(t, s2) {
    t.startVector(4, s2.length, 4);
    for (let e2 = s2.length - 1; e2 >= 0; e2--) t.addOffset(s2[e2]);
    return t.endVector();
  }
  static startColumnsVector(t, s2) {
    t.startVector(4, s2, 4);
  }
  static addFeaturesCount(t, s2) {
    t.addFieldInt64(8, s2, BigInt("0"));
  }
  static addIndexNodeSize(t, s2) {
    t.addFieldInt16(9, s2, 16);
  }
  static addCrs(t, s2) {
    t.addFieldOffset(10, s2, 0);
  }
  static addTitle(t, s2) {
    t.addFieldOffset(11, s2, 0);
  }
  static addDescription(t, s2) {
    t.addFieldOffset(12, s2, 0);
  }
  static addMetadata(t, s2) {
    t.addFieldOffset(13, s2, 0);
  }
  static endHeader(t) {
    return t.endObject();
  }
  static finishHeaderBuffer(t, s2) {
    t.finish(s2);
  }
  static finishSizePrefixedHeaderBuffer(t, s2) {
    t.finish(s2, void 0, true);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/geometry.js
var Geometry = class _Geometry {
  bb = null;
  bb_pos = 0;
  __init(t, e2) {
    return this.bb_pos = t, this.bb = e2, this;
  }
  static getRootAsGeometry(t, e2) {
    return (e2 || new _Geometry()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsGeometry(e2, s2) {
    return e2.setPosition(e2.position() + SIZE_PREFIX_LENGTH), (s2 || new _Geometry()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  ends(t) {
    let e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e2) + 4 * t) : 0;
  }
  endsLength() {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  endsArray() {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  xy(t) {
    let e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e2) + 8 * t) : 0;
  }
  xyLength() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  xyArray() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  z(t) {
    let e2 = this.bb.__offset(this.bb_pos, 8);
    return e2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e2) + 8 * t) : 0;
  }
  zLength() {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  zArray() {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  m(t) {
    let e2 = this.bb.__offset(this.bb_pos, 10);
    return e2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e2) + 8 * t) : 0;
  }
  mLength() {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  mArray() {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  t(t) {
    let e2 = this.bb.__offset(this.bb_pos, 12);
    return e2 ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e2) + 8 * t) : 0;
  }
  tLength() {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  tArray() {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  tm(t) {
    let e2 = this.bb.__offset(this.bb_pos, 14);
    return e2 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e2) + 8 * t) : BigInt(0);
  }
  tmLength() {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  type() {
    let t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.readUint8(this.bb_pos + t) : GeometryType.Unknown;
  }
  parts(t, e2) {
    let s2 = this.bb.__offset(this.bb_pos, 18);
    return s2 ? (e2 || new _Geometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + s2) + 4 * t), this.bb) : null;
  }
  partsLength() {
    let t = this.bb.__offset(this.bb_pos, 18);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startGeometry(t) {
    t.startObject(8);
  }
  static addEnds(t, e2) {
    t.addFieldOffset(0, e2, 0);
  }
  static createEndsVector(t, e2) {
    t.startVector(4, e2.length, 4);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addInt32(e2[s2]);
    return t.endVector();
  }
  static startEndsVector(t, e2) {
    t.startVector(4, e2, 4);
  }
  static addXy(t, e2) {
    t.addFieldOffset(1, e2, 0);
  }
  static createXyVector(t, e2) {
    t.startVector(8, e2.length, 8);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addFloat64(e2[s2]);
    return t.endVector();
  }
  static startXyVector(t, e2) {
    t.startVector(8, e2, 8);
  }
  static addZ(t, e2) {
    t.addFieldOffset(2, e2, 0);
  }
  static createZVector(t, e2) {
    t.startVector(8, e2.length, 8);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addFloat64(e2[s2]);
    return t.endVector();
  }
  static startZVector(t, e2) {
    t.startVector(8, e2, 8);
  }
  static addM(t, e2) {
    t.addFieldOffset(3, e2, 0);
  }
  static createMVector(t, e2) {
    t.startVector(8, e2.length, 8);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addFloat64(e2[s2]);
    return t.endVector();
  }
  static startMVector(t, e2) {
    t.startVector(8, e2, 8);
  }
  static addT(t, e2) {
    t.addFieldOffset(4, e2, 0);
  }
  static createTVector(t, e2) {
    t.startVector(8, e2.length, 8);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addFloat64(e2[s2]);
    return t.endVector();
  }
  static startTVector(t, e2) {
    t.startVector(8, e2, 8);
  }
  static addTm(t, e2) {
    t.addFieldOffset(5, e2, 0);
  }
  static createTmVector(t, e2) {
    t.startVector(8, e2.length, 8);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addInt64(e2[s2]);
    return t.endVector();
  }
  static startTmVector(t, e2) {
    t.startVector(8, e2, 8);
  }
  static addType(t, s2) {
    t.addFieldInt8(6, s2, GeometryType.Unknown);
  }
  static addParts(t, e2) {
    t.addFieldOffset(7, e2, 0);
  }
  static createPartsVector(t, e2) {
    t.startVector(4, e2.length, 4);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addOffset(e2[s2]);
    return t.endVector();
  }
  static startPartsVector(t, e2) {
    t.startVector(4, e2, 4);
  }
  static endGeometry(t) {
    return t.endObject();
  }
  static createGeometry(t, e2, s2, b, r2, o2, i, _, h) {
    return _Geometry.startGeometry(t), _Geometry.addEnds(t, e2), _Geometry.addXy(t, s2), _Geometry.addZ(t, b), _Geometry.addM(t, r2), _Geometry.addT(t, o2), _Geometry.addTm(t, i), _Geometry.addType(t, _), _Geometry.addParts(t, h), _Geometry.endGeometry(t);
  }
};

// node_modules/flatgeobuf/lib/mjs/flat-geobuf/feature.js
var Feature = class _Feature {
  bb = null;
  bb_pos = 0;
  __init(t, e2) {
    return this.bb_pos = t, this.bb = e2, this;
  }
  static getRootAsFeature(t, e2) {
    return (e2 || new _Feature()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFeature(e2, s2) {
    return e2.setPosition(e2.position() + SIZE_PREFIX_LENGTH), (s2 || new _Feature()).__init(e2.readInt32(e2.position()) + e2.position(), e2);
  }
  geometry(t) {
    let e2 = this.bb.__offset(this.bb_pos, 4);
    return e2 ? (t || new Geometry()).__init(this.bb.__indirect(this.bb_pos + e2), this.bb) : null;
  }
  properties(t) {
    let e2 = this.bb.__offset(this.bb_pos, 6);
    return e2 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e2) + t) : 0;
  }
  propertiesLength() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  propertiesArray() {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  columns(t, s2) {
    let r2 = this.bb.__offset(this.bb_pos, 8);
    return r2 ? (s2 || new Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t), this.bb) : null;
  }
  columnsLength() {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startFeature(t) {
    t.startObject(3);
  }
  static addGeometry(t, e2) {
    t.addFieldOffset(0, e2, 0);
  }
  static addProperties(t, e2) {
    t.addFieldOffset(1, e2, 0);
  }
  static createPropertiesVector(t, e2) {
    t.startVector(1, e2.length, 1);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addInt8(e2[s2]);
    return t.endVector();
  }
  static startPropertiesVector(t, e2) {
    t.startVector(1, e2, 1);
  }
  static addColumns(t, e2) {
    t.addFieldOffset(2, e2, 0);
  }
  static createColumnsVector(t, e2) {
    t.startVector(4, e2.length, 4);
    for (let s2 = e2.length - 1; s2 >= 0; s2--) t.addOffset(e2[s2]);
    return t.endVector();
  }
  static startColumnsVector(t, e2) {
    t.startVector(4, e2, 4);
  }
  static endFeature(t) {
    return t.endObject();
  }
  static finishFeatureBuffer(t, e2) {
    t.finish(e2);
  }
  static finishSizePrefixedFeatureBuffer(t, e2) {
    t.finish(e2, void 0, true);
  }
  static createFeature(t, e2, s2, r2) {
    return _Feature.startFeature(t), _Feature.addGeometry(t, e2), _Feature.addProperties(t, s2), _Feature.addColumns(t, r2), _Feature.endFeature(t);
  }
};

// node_modules/flatgeobuf/lib/mjs/header-meta.js
function fromByteBuffer(t) {
  let r2 = Header.getRootAsHeader(t), i = r2.featuresCount(), n2 = r2.indexNodeSize(), o2 = [];
  for (let e2 = 0; e2 < r2.columnsLength(); e2++) {
    let t2 = r2.columns(e2);
    if (!t2) throw Error("Column unexpectedly missing");
    if (!t2.name()) throw Error("Column name unexpectedly missing");
    o2.push({ name: t2.name(), type: t2.type(), title: t2.title(), description: t2.description(), width: t2.width(), precision: t2.precision(), scale: t2.scale(), nullable: t2.nullable(), unique: t2.unique(), primary_key: t2.primaryKey() });
  }
  let l = r2.crs(), s2 = l ? { org: l.org(), code: l.code(), name: l.name(), description: l.description(), wkt: l.wkt(), code_string: l.codeString() } : null;
  return { geometryType: r2.geometryType(), columns: o2, envelope: null, featuresCount: Number(i), indexNodeSize: n2, crs: s2, title: r2.title(), description: r2.description(), metadata: r2.metadata() };
}

// node_modules/@repeaterjs/repeater/repeater.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject2(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i >= o2.length) o2 = void 0;
      return { value: o2 && o2[i++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2]) i[n2] = function(v) {
      return new Promise(function(a, b) {
        q.push([n2, v, a, b]) > 1 || resume(n2, v);
      });
    };
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
var RepeaterOverflowError = (
  /** @class */
  function(_super) {
    __extends(RepeaterOverflowError2, _super);
    function RepeaterOverflowError2(message) {
      var _this = _super.call(this, message) || this;
      Object.defineProperty(_this, "name", {
        value: "RepeaterOverflowError",
        enumerable: false
      });
      if (typeof Object.setPrototypeOf === "function") {
        Object.setPrototypeOf(_this, _this.constructor.prototype);
      } else {
        _this.__proto__ = _this.constructor.prototype;
      }
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, _this.constructor);
      }
      return _this;
    }
    return RepeaterOverflowError2;
  }(Error)
);
(
  /** @class */
  (function() {
    function FixedBuffer2(capacity) {
      if (capacity < 0) {
        throw new RangeError("Capacity may not be less than 0");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(FixedBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FixedBuffer2.prototype, "full", {
      get: function() {
        return this._q.length >= this._c;
      },
      enumerable: false,
      configurable: true
    });
    FixedBuffer2.prototype.add = function(value) {
      if (this.full) {
        throw new Error("Buffer full");
      } else {
        this._q.push(value);
      }
    };
    FixedBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return FixedBuffer2;
  })()
);
(
  /** @class */
  (function() {
    function SlidingBuffer2(capacity) {
      if (capacity < 1) {
        throw new RangeError("Capacity may not be less than 1");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(SlidingBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SlidingBuffer2.prototype, "full", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    SlidingBuffer2.prototype.add = function(value) {
      while (this._q.length >= this._c) {
        this._q.shift();
      }
      this._q.push(value);
    };
    SlidingBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return SlidingBuffer2;
  })()
);
(
  /** @class */
  (function() {
    function DroppingBuffer2(capacity) {
      if (capacity < 1) {
        throw new RangeError("Capacity may not be less than 1");
      }
      this._c = capacity;
      this._q = [];
    }
    Object.defineProperty(DroppingBuffer2.prototype, "empty", {
      get: function() {
        return this._q.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DroppingBuffer2.prototype, "full", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    DroppingBuffer2.prototype.add = function(value) {
      if (this._q.length < this._c) {
        this._q.push(value);
      }
    };
    DroppingBuffer2.prototype.remove = function() {
      if (this.empty) {
        throw new Error("Buffer empty");
      }
      return this._q.shift();
    };
    return DroppingBuffer2;
  })()
);
function swallow(value) {
  if (value != null && typeof value.then === "function") {
    value.then(NOOP, NOOP);
  }
}
var Initial = 0;
var Started = 1;
var Stopped = 2;
var Done = 3;
var Rejected = 4;
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function() {
};
function consumeExecution(r2) {
  var err = r2.err;
  var execution = Promise.resolve(r2.execution).then(function(value) {
    if (err != null) {
      throw err;
    }
    return value;
  });
  r2.err = void 0;
  r2.execution = execution.then(function() {
    return void 0;
  }, function() {
    return void 0;
  });
  return r2.pending === void 0 ? execution : r2.pending.then(function() {
    return execution;
  });
}
function createIteration(r2, value) {
  var done = r2.state >= Done;
  return Promise.resolve(value).then(function(value2) {
    if (!done && r2.state >= Rejected) {
      return consumeExecution(r2).then(function(value3) {
        return {
          value: value3,
          done: true
        };
      });
    }
    return { value: value2, done };
  });
}
function stop(r2, err) {
  var e_1, _a;
  if (r2.state >= Stopped) {
    return;
  }
  r2.state = Stopped;
  r2.onnext();
  r2.onstop();
  if (r2.err == null) {
    r2.err = err;
  }
  if (r2.pushes.length === 0 && (typeof r2.buffer === "undefined" || r2.buffer.empty)) {
    finish(r2);
  } else {
    try {
      for (var _b = __values(r2.pushes), _d = _b.next(); !_d.done; _d = _b.next()) {
        var push_1 = _d.value;
        push_1.resolve();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }
}
function finish(r2) {
  var e_2, _a;
  if (r2.state >= Done) {
    return;
  }
  if (r2.state < Stopped) {
    stop(r2);
  }
  r2.state = Done;
  r2.buffer = void 0;
  try {
    for (var _b = __values(r2.nexts), _d = _b.next(); !_d.done; _d = _b.next()) {
      var next = _d.value;
      var execution = r2.pending === void 0 ? consumeExecution(r2) : r2.pending.then(function() {
        return consumeExecution(r2);
      });
      next.resolve(createIteration(r2, execution));
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  r2.pushes = [];
  r2.nexts = [];
}
function reject(r2) {
  if (r2.state >= Rejected) {
    return;
  }
  if (r2.state < Done) {
    finish(r2);
  }
  r2.state = Rejected;
}
function push(r2, value) {
  swallow(value);
  if (r2.pushes.length >= MAX_QUEUE_LENGTH) {
    throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
  } else if (r2.state >= Stopped) {
    return Promise.resolve(void 0);
  }
  var valueP = r2.pending === void 0 ? Promise.resolve(value) : r2.pending.then(function() {
    return value;
  });
  valueP = valueP.catch(function(err) {
    if (r2.state < Stopped) {
      r2.err = err;
    }
    reject(r2);
    return void 0;
  });
  var nextP;
  if (r2.nexts.length) {
    var next_1 = r2.nexts.shift();
    next_1.resolve(createIteration(r2, valueP));
    if (r2.nexts.length) {
      nextP = Promise.resolve(r2.nexts[0].value);
    } else if (typeof r2.buffer !== "undefined" && !r2.buffer.full) {
      nextP = Promise.resolve(void 0);
    } else {
      nextP = new Promise(function(resolve) {
        return r2.onnext = resolve;
      });
    }
  } else if (typeof r2.buffer !== "undefined" && !r2.buffer.full) {
    r2.buffer.add(valueP);
    nextP = Promise.resolve(void 0);
  } else {
    nextP = new Promise(function(resolve) {
      return r2.pushes.push({ resolve, value: valueP });
    });
  }
  var floating = true;
  var next = {};
  var unhandled = nextP.catch(function(err) {
    if (floating) {
      throw err;
    }
    return void 0;
  });
  next.then = function(onfulfilled, onrejected) {
    floating = false;
    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
  };
  next.catch = function(onrejected) {
    floating = false;
    return Promise.prototype.catch.call(nextP, onrejected);
  };
  next.finally = nextP.finally.bind(nextP);
  r2.pending = valueP.then(function() {
    return unhandled;
  }).catch(function(err) {
    r2.err = err;
    reject(r2);
  });
  return next;
}
function createStop(r2) {
  var stop1 = stop.bind(null, r2);
  var stopP = new Promise(function(resolve) {
    return r2.onstop = resolve;
  });
  stop1.then = stopP.then.bind(stopP);
  stop1.catch = stopP.catch.bind(stopP);
  stop1.finally = stopP.finally.bind(stopP);
  return stop1;
}
function execute(r2) {
  if (r2.state >= Started) {
    return;
  }
  r2.state = Started;
  var push1 = push.bind(null, r2);
  var stop1 = createStop(r2);
  r2.execution = new Promise(function(resolve) {
    return resolve(r2.executor(push1, stop1));
  });
  r2.execution.catch(function() {
    return stop(r2);
  });
}
var records = /* @__PURE__ */ new WeakMap();
var Repeater = (
  /** @class */
  function() {
    function Repeater2(executor, buffer) {
      records.set(this, {
        executor,
        buffer,
        err: void 0,
        state: Initial,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: NOOP,
        onstop: NOOP
      });
    }
    Repeater2.prototype.next = function(value) {
      swallow(value);
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      if (r2.nexts.length >= MAX_QUEUE_LENGTH) {
        throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
      }
      if (r2.state <= Initial) {
        execute(r2);
      }
      r2.onnext(value);
      if (typeof r2.buffer !== "undefined" && !r2.buffer.empty) {
        var result = createIteration(r2, r2.buffer.remove());
        if (r2.pushes.length) {
          var push_2 = r2.pushes.shift();
          r2.buffer.add(push_2.value);
          r2.onnext = push_2.resolve;
        }
        return result;
      } else if (r2.pushes.length) {
        var push_3 = r2.pushes.shift();
        r2.onnext = push_3.resolve;
        return createIteration(r2, push_3.value);
      } else if (r2.state >= Stopped) {
        finish(r2);
        return createIteration(r2, consumeExecution(r2));
      }
      return new Promise(function(resolve) {
        return r2.nexts.push({ resolve, value });
      });
    };
    Repeater2.prototype.return = function(value) {
      swallow(value);
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      finish(r2);
      r2.execution = Promise.resolve(r2.execution).then(function() {
        return value;
      });
      return createIteration(r2, consumeExecution(r2));
    };
    Repeater2.prototype.throw = function(err) {
      var r2 = records.get(this);
      if (r2 === void 0) {
        throw new Error("WeakMap error");
      }
      if (r2.state <= Initial || r2.state >= Stopped || typeof r2.buffer !== "undefined" && !r2.buffer.empty) {
        finish(r2);
        if (r2.err == null) {
          r2.err = err;
        }
        return createIteration(r2, consumeExecution(r2));
      }
      return this.next(Promise.reject(err));
    };
    Repeater2.prototype[Symbol.asyncIterator] = function() {
      return this;
    };
    Repeater2.race = race;
    Repeater2.merge = merge;
    Repeater2.zip = zip;
    Repeater2.latest = latest;
    return Repeater2;
  }()
);
function getIterators(values, options) {
  var e_3, _a;
  var iters = [];
  var _loop_1 = function(value2) {
    if (value2 != null && typeof value2[Symbol.asyncIterator] === "function") {
      iters.push(value2[Symbol.asyncIterator]());
    } else if (value2 != null && typeof value2[Symbol.iterator] === "function") {
      iters.push(value2[Symbol.iterator]());
    } else {
      iters.push(function valueToAsyncIterator() {
        return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!options.yieldValues) return [3, 3];
                return [4, __await(value2)];
              case 1:
                return [4, _a2.sent()];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                if (!options.returnValues) return [3, 5];
                return [4, __await(value2)];
              case 4:
                return [2, _a2.sent()];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }());
    }
  };
  try {
    for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
      var value = values_1_1.value;
      _loop_1(value);
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
  return iters;
}
function race(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, stopped, finalIteration, iteration, i_1, _loop_2;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [
                2
                /*return*/
              ];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            iteration = void 0;
            i_1 = 0;
            _loop_2 = function() {
              var j, iters_1, iters_1_1, iter;
              var e_4, _a2;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    j = i_1;
                    try {
                      for (iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()) {
                        iter = iters_1_1.value;
                        Promise.resolve(iter.next()).then(function(iteration2) {
                          if (iteration2.done) {
                            stop2();
                            if (finalIteration === void 0) {
                              finalIteration = iteration2;
                            }
                          } else if (i_1 === j) {
                            i_1++;
                            advance(iteration2);
                          }
                        }, function(err) {
                          return stop2(err);
                        });
                      }
                    } catch (e_4_1) {
                      e_4 = { error: e_4_1 };
                    } finally {
                      try {
                        if (iters_1_1 && !iters_1_1.done && (_a2 = iters_1.return)) _a2.call(iters_1);
                      } finally {
                        if (e_4) throw e_4.error;
                      }
                    }
                    return [4, new Promise(function(resolve) {
                      return advance = resolve;
                    })];
                  case 1:
                    iteration = _b.sent();
                    if (!(iteration !== void 0)) return [3, 3];
                    return [4, push2(iteration.value)];
                  case 2:
                    _b.sent();
                    _b.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            };
            _a.label = 2;
          case 2:
            if (!!stopped) return [3, 4];
            return [5, _loop_2()];
          case 3:
            _a.sent();
            return [3, 2];
          case 4:
            return [2, finalIteration && finalIteration.value];
          case 5:
            stop2();
            return [4, Promise.race(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function merge(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { yieldValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advances, stopped, finalIteration;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [
                2
                /*return*/
              ];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_5, _a2;
              stopped = true;
              try {
                for (var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()) {
                  var advance = advances_1_1.value;
                  advance();
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (advances_1_1 && !advances_1_1.done && (_a2 = advances_1.return)) _a2.call(advances_1);
                } finally {
                  if (e_5) throw e_5.error;
                }
              }
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, void 0, void 0, function() {
                var iteration, _a2;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, , 6, 9]);
                      _b.label = 1;
                    case 1:
                      if (!!stopped) return [3, 5];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _b.sent();
                      if (!(iteration !== void 0)) return [3, 4];
                      if (iteration.done) {
                        finalIteration = iteration;
                        return [
                          2
                          /*return*/
                        ];
                      }
                      return [4, push2(iteration.value)];
                    case 3:
                      _b.sent();
                      _b.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      _a2 = iter.return;
                      if (!_a2) return [3, 8];
                      return [4, iter.return()];
                    case 7:
                      _a2 = _b.sent();
                      _b.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            _a.sent();
            return [2, finalIteration && finalIteration.value];
          case 3:
            stop2();
            return [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function zip(contenders) {
  var _this = this;
  var iters = getIterators(contenders, { returnValues: true });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, stopped, iterations, values;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            stopped = false;
            stop2.then(function() {
              advance();
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 6, 8]);
            _a.label = 2;
          case 2:
            if (!!stopped) return [3, 5];
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations2) {
              return advance(iterations2);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 3:
            iterations = _a.sent();
            if (iterations === void 0) {
              return [
                2
                /*return*/
              ];
            }
            values = iterations.map(function(iteration) {
              return iteration.value;
            });
            if (iterations.some(function(iteration) {
              return iteration.done;
            })) {
              return [2, values];
            }
            return [4, push2(values)];
          case 4:
            _a.sent();
            return [3, 2];
          case 5:
            return [3, 8];
          case 6:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 7:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function latest(contenders) {
  var _this = this;
  var iters = getIterators(contenders, {
    yieldValues: true,
    returnValues: true
  });
  return new Repeater(function(push2, stop2) {
    return __awaiter(_this, void 0, void 0, function() {
      var advance, advances, stopped, iterations_1, values_2;
      var _this2 = this;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!iters.length) {
              stop2();
              return [2, []];
            }
            advances = [];
            stopped = false;
            stop2.then(function() {
              var e_6, _a2;
              advance();
              try {
                for (var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()) {
                  var advance1 = advances_2_1.value;
                  advance1();
                }
              } catch (e_6_1) {
                e_6 = { error: e_6_1 };
              } finally {
                try {
                  if (advances_2_1 && !advances_2_1.done && (_a2 = advances_2.return)) _a2.call(advances_2);
                } finally {
                  if (e_6) throw e_6.error;
                }
              }
              stopped = true;
            });
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 5, 7]);
            Promise.all(iters.map(function(iter) {
              return iter.next();
            })).then(function(iterations) {
              return advance(iterations);
            }, function(err) {
              return stop2(err);
            });
            return [4, new Promise(function(resolve) {
              return advance = resolve;
            })];
          case 2:
            iterations_1 = _a.sent();
            if (iterations_1 === void 0) {
              return [
                2
                /*return*/
              ];
            }
            values_2 = iterations_1.map(function(iteration) {
              return iteration.value;
            });
            if (iterations_1.every(function(iteration) {
              return iteration.done;
            })) {
              return [2, values_2];
            }
            return [4, push2(values_2.slice())];
          case 3:
            _a.sent();
            return [4, Promise.all(iters.map(function(iter, i) {
              return __awaiter(_this2, void 0, void 0, function() {
                var iteration;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      if (iterations_1[i].done) {
                        return [2, iterations_1[i].value];
                      }
                      _a2.label = 1;
                    case 1:
                      if (!!stopped) return [3, 4];
                      Promise.resolve(iter.next()).then(function(iteration2) {
                        return advances[i](iteration2);
                      }, function(err) {
                        return stop2(err);
                      });
                      return [4, new Promise(function(resolve) {
                        return advances[i] = resolve;
                      })];
                    case 2:
                      iteration = _a2.sent();
                      if (iteration === void 0) {
                        return [2, iterations_1[i].value];
                      } else if (iteration.done) {
                        return [2, iteration.value];
                      }
                      values_2[i] = iteration.value;
                      return [4, push2(values_2.slice())];
                    case 3:
                      _a2.sent();
                      return [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, _a.sent()];
          case 5:
            stop2();
            return [4, Promise.all(iters.map(function(iter) {
              return iter.return && iter.return();
            }))];
          case 6:
            _a.sent();
            return [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}

// node_modules/flatgeobuf/lib/mjs/config.js
(class _e {
  static global = new _e();
  _extraRequestThreshold = 262144;
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e2) {
    if (e2 < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e2;
  }
});

// node_modules/flatgeobuf/lib/mjs/generic/geometry.js
function pairFlatCoordinates(t, e2) {
  let r2 = [];
  for (let o2 = 0; o2 < t.length; o2 += 2) {
    let n2 = [t[o2], t[o2 + 1]];
    e2 && n2.push(e2[o2 >> 1]), r2.push(n2);
  }
  return r2;
}

// node_modules/flatgeobuf/lib/mjs/generic/feature.js
new TextEncoder();
var s = new TextDecoder();
function parseProperties(e2, r2) {
  let a = {};
  if (!r2 || 0 === r2.length) return a;
  let n2 = e2.propertiesArray();
  if (!n2) return a;
  let o2 = new DataView(n2.buffer, n2.byteOffset), i = e2.propertiesLength(), l = 0;
  for (; l < i; ) {
    let e3 = o2.getUint16(l, true);
    l += 2;
    let i2 = r2[e3], c = i2.name;
    switch (i2.type) {
      case ColumnType.Bool:
        a[c] = !!o2.getUint8(l), l += 1;
        break;
      case ColumnType.Byte:
        a[c] = o2.getInt8(l), l += 1;
        break;
      case ColumnType.UByte:
        a[c] = o2.getUint8(l), l += 1;
        break;
      case ColumnType.Short:
        a[c] = o2.getInt16(l, true), l += 2;
        break;
      case ColumnType.UShort:
        a[c] = o2.getUint16(l, true), l += 2;
        break;
      case ColumnType.Int:
        a[c] = o2.getInt32(l, true), l += 4;
        break;
      case ColumnType.UInt:
        a[c] = o2.getUint32(l, true), l += 4;
        break;
      case ColumnType.Long:
        a[c] = Number(o2.getBigInt64(l, true)), l += 8;
        break;
      case ColumnType.ULong:
        a[c] = Number(o2.getBigUint64(l, true)), l += 8;
        break;
      case ColumnType.Float:
        a[c] = o2.getFloat32(l, true), l += 4;
        break;
      case ColumnType.Double:
        a[c] = o2.getFloat64(l, true), l += 8;
        break;
      case ColumnType.DateTime:
      case ColumnType.String: {
        let e4 = o2.getUint32(l, true);
        l += 4, a[c] = s.decode(n2.subarray(l, l + e4)), l += e4;
        break;
      }
      case ColumnType.Json: {
        let e4 = o2.getUint32(l, true);
        l += 4;
        let t = s.decode(n2.subarray(l, l + e4));
        a[c] = JSON.parse(t), l += e4;
        break;
      }
      case ColumnType.Binary: {
        let e4 = o2.getUint32(l, true);
        l += 4, a[c] = n2.subarray(l, l + e4), l += e4;
        break;
      }
      default:
        throw Error(`Unknown type ${i2.type}`);
    }
  }
  return a;
}

// src/constants.ts
var VERSION = 3;
var MAGIC_BYTES = [102, 103, 98, VERSION, 102, 103, 98, 0];
var SIZE_PREFIX_LEN2 = 4;
var HEADER_FETCH_SIZE = 8192 * 4;
var QUERY_PLAN_DEFAULTS = {
  /**
   * Amount of space allowed between features before splitting requests.
   * If features are closer together than this, they will be fetched in a
   * single request to minimize network overhead.
   */
  overfetchBytes: 500 * 1024
  // 500KB
};
var DEFAULT_CACHE_SIZE = 16 * 1024 * 1024;
var PAGE_SIZE = 5 * 1024 * 1024;

// src/fetch-manager.ts
var FetchManager = class {
  constructor(urlOrFetchRangeFn, maxCacheSize = DEFAULT_CACHE_SIZE, featureDataOffset = 0, fileByteLength, pageSize = PAGE_SIZE) {
    /** In-flight page requests keyed by page index */
    this.inFlightPageRequests = /* @__PURE__ */ new Map();
    /** In-flight assembled range requests keyed by "start-end" */
    this.inFlightRangeRequests = /* @__PURE__ */ new Map();
    this.cacheHits = 0;
    this.cacheMisses = 0;
    if (typeof urlOrFetchRangeFn === "string") {
      this.url = urlOrFetchRangeFn;
      this.fetchRangeFn = this.defaultFetchRange;
    } else {
      this.fetchRangeFn = urlOrFetchRangeFn;
    }
    this.featureDataOffset = featureDataOffset;
    this.fileByteLength = fileByteLength;
    this.pageSize = pageSize;
    this.pageCache = new lruCache.LRUCache({
      maxSize: maxCacheSize,
      sizeCalculation: (value) => value.byteLength,
      updateAgeOnGet: true
    });
  }
  /**
   * Get cache statistics
   */
  get cacheStats() {
    return {
      count: this.pageCache.size,
      calculatedSize: this.pageCache.calculatedSize,
      maxSize: this.pageCache.maxSize,
      inFlightRequests: this.inFlightPageRequests.size + this.inFlightRangeRequests.size,
      cacheHits: this.cacheHits,
      cacheMisses: this.cacheMisses
    };
  }
  /**
   * Clear the feature data cache
   */
  clearCache() {
    this.pageCache.clear();
    this.inFlightPageRequests.clear();
    this.inFlightRangeRequests.clear();
    this.cacheHits = 0;
    this.cacheMisses = 0;
  }
  /**
   * Fetch a byte range from the source.
   *
   * The result is cached using an LRU cache to minimize network requests.
   *
   * @param range - [start (number), end (number | null)] byte range to fetch.
   *                End may be null to indicate the end of the file.
   * @returns Promise resolving to the fetched data as ArrayBuffer
   * @throws Error if source is misconfigured
   */
  async fetchRange(range) {
    const [requestedStart, requestedEndNullable] = range;
    const rangeKey = `${requestedStart}-${requestedEndNullable ?? ""}`;
    const existingRangeRequest = this.inFlightRangeRequests.get(rangeKey);
    if (existingRangeRequest) {
      this.cacheHits++;
      return existingRangeRequest;
    }
    if (requestedEndNullable === null && this.fileByteLength === void 0) {
      this.cacheMisses++;
      const timeout = setTimeout(() => {
        throw new Error("Request timed out");
      }, 6e4);
      const directPromise = this.fetchRangeFn(range).then(
        (bytes3) => {
          clearTimeout(timeout);
          this.inFlightRangeRequests.delete(rangeKey);
          return bytes3;
        },
        (error) => {
          this.inFlightRangeRequests.delete(rangeKey);
          throw error;
        }
      );
      this.inFlightRangeRequests.set(rangeKey, directPromise);
      return directPromise;
    }
    const requestedEnd = requestedEndNullable !== null ? requestedEndNullable : this.fileByteLength - 1;
    const firstPageIndex = Math.max(
      0,
      Math.floor((requestedStart - this.featureDataOffset) / this.pageSize)
    );
    const lastPageIndex = Math.max(
      firstPageIndex,
      Math.floor((requestedEnd - this.featureDataOffset) / this.pageSize)
    );
    const assemblePromise = (async () => {
      const pages = [];
      for (let i = firstPageIndex; i <= lastPageIndex; i++) {
        const data = await this.fetchPage(i);
        pages.push({ index: i, data });
      }
      const totalLength = requestedEnd - requestedStart + 1;
      const output = new Uint8Array(totalLength);
      let writeOffset = 0;
      for (const { index, data } of pages) {
        const pageStart = this.featureDataOffset + index * this.pageSize;
        const pageEndExclusive = pageStart + this.pageSize;
        const sliceStart = Math.max(requestedStart, pageStart);
        const sliceEndExclusive = Math.min(requestedEnd + 1, pageEndExclusive);
        const offsetInPage = sliceStart - pageStart;
        const length = sliceEndExclusive - sliceStart;
        if (length <= 0) continue;
        const src = new Uint8Array(data, offsetInPage, length);
        output.set(src, writeOffset);
        writeOffset += length;
      }
      this.inFlightRangeRequests.delete(rangeKey);
      return output.buffer;
    })();
    this.inFlightRangeRequests.set(rangeKey, assemblePromise);
    return assemblePromise;
  }
  /**
   * Default fetch implementation using the fetch API.
   */
  async defaultFetchRange(range) {
    if (!this.url) {
      throw new Error("Misconfiguration: fetchRange called without url");
    }
    const response = await fetch(this.url, {
      headers: {
        Range: `bytes=${range[0]}-${range[1] ? range[1] : ""}`
      }
    });
    return response.arrayBuffer();
  }
  /** Fetch a full page by index, using cache and in-flight deduping */
  async fetchPage(pageIndex) {
    const cached = this.pageCache.get(pageIndex);
    if (cached) {
      this.cacheHits++;
      return cached;
    }
    const inFlight = this.inFlightPageRequests.get(pageIndex);
    if (inFlight) {
      this.cacheHits++;
      return inFlight;
    }
    this.cacheMisses++;
    console.log(
      "cache miss - fetchPage",
      pageIndex,
      this.pageSize,
      this.fileByteLength
    );
    const pageStart = this.featureDataOffset + pageIndex * this.pageSize;
    let pageEndInclusive = pageStart + this.pageSize - 1;
    if (this.fileByteLength !== void 0 && pageEndInclusive > this.fileByteLength - 1) {
      pageEndInclusive = this.fileByteLength - 1;
    }
    const timeout = setTimeout(() => {
      throw new Error("Request timed out");
    }, 6e4);
    const promise = this.fetchRangeFn([pageStart, pageEndInclusive]).then(
      (bytes3) => {
        clearTimeout(timeout);
        this.pageCache.set(pageIndex, bytes3);
        this.inFlightPageRequests.delete(pageIndex);
        return bytes3;
      },
      (error) => {
        this.inFlightPageRequests.delete(pageIndex);
        throw error;
      }
    );
    this.inFlightPageRequests.set(pageIndex, promise);
    return promise;
  }
};

// src/query-plan.ts
function createQueryPlan(results, featureDataOffset, options) {
  results.sort((a, b) => a[0] - b[0]);
  if (results.length === 0) {
    return {
      requests: [],
      bytes: 0,
      features: 0
    };
  } else if (results.length === 1) {
    const result = results[0];
    return {
      requests: [
        {
          range: toRange(result, featureDataOffset),
          offsets: [[0, result[1]]]
        }
      ],
      bytes: result[1] ? result[1] - result[0] : 0,
      features: 1
    };
  }
  const plan = {
    requests: [],
    bytes: results.reduce((acc, [offset2, length2]) => {
      const range = toRange([offset2, length2], featureDataOffset);
      acc += range[1] ? range[1] - range[0] : 0;
      return acc;
    }, 0),
    features: results.length
  };
  let offset = 0;
  const [start, length] = results[0];
  let currentRange = {
    range: toRange([start, length], featureDataOffset),
    offsets: [[0, length]]
  };
  offset = length;
  plan.requests.push(currentRange);
  const overfetchBytes = options.overfetchBytes ?? QUERY_PLAN_DEFAULTS.overfetchBytes;
  for (let i = 1; i < results.length; i++) {
    const [start2, length2] = results[i];
    const range = toRange([start2, length2], featureDataOffset);
    const distance = range[0] - currentRange.range[1] - 1;
    if (distance < overfetchBytes && currentRange.offsets.length < 1e3) {
      currentRange.range[1] = range[1];
      offset += distance;
      currentRange.offsets.push([offset, length2]);
      offset += length2;
    } else {
      currentRange = {
        range,
        offsets: [[0, length2]]
      };
      offset = length2;
      plan.requests.push(currentRange);
    }
  }
  return plan;
}
function toRange(offsetAndLength, featureDataOffset) {
  if (offsetAndLength[1] === null) {
    return [featureDataOffset + offsetAndLength[0], null];
  } else {
    return [
      featureDataOffset + offsetAndLength[0],
      featureDataOffset + offsetAndLength[0] + offsetAndLength[1] - 1
    ];
  }
}
async function* executeQueryPlan(plan, fetchRange, options = {}) {
  const fetchPromises = plan.map(async ({ range, offsets }, i) => {
    const data = await fetchRange(range);
    return { data, offsets, i };
  });
  const pendingFetches = new Set(plan.map((_, i) => i));
  while (pendingFetches.size > 0) {
    const completedFetch = await Promise.race(
      [...pendingFetches].map((i2) => fetchPromises[i2])
    );
    pendingFetches.delete(completedFetch.i);
    delete fetchPromises[completedFetch.i];
    const { data, offsets } = completedFetch;
    const view = new DataView(data);
    let i = 0;
    for (let [offset, length] of offsets) {
      if (length === null) {
        length = view.buffer.byteLength - offset;
      }
      let featureView = new DataView(data, offset, length);
      yield [featureView, offset];
      i++;
      if (i % 10 === 0) {
        process.nextTick(() => {
        });
      }
    }
  }
}

// node_modules/flatgeobuf/lib/mjs/geojson/geometry.js
function fromGeometry(t, o2) {
  let n2 = o2;
  if (n2 === GeometryType.Unknown && (n2 = t.type()), n2 === GeometryType.GeometryCollection) {
    let r2 = [];
    for (let e2 = 0; e2 < t.partsLength(); e2++) {
      let o3 = t.parts(e2), n3 = o3.type();
      r2.push(fromGeometry(o3, n3));
    }
    return { type: GeometryType[n2], geometries: r2 };
  }
  if (n2 === GeometryType.MultiPolygon) {
    let r2 = [];
    for (let o3 = 0; o3 < t.partsLength(); o3++) r2.push(fromGeometry(t.parts(o3), GeometryType.Polygon));
    return { type: GeometryType[n2], coordinates: r2.map((e2) => e2.coordinates) };
  }
  let i = function(t2, o3) {
    let n3 = t2.xyArray(), i2 = t2.zArray();
    switch (o3) {
      case GeometryType.Point: {
        let e2 = Array.from(n3);
        return i2 && e2.push(i2[0]), e2;
      }
      case GeometryType.MultiPoint:
      case GeometryType.LineString:
        return pairFlatCoordinates(n3, i2);
      case GeometryType.MultiLineString:
      case GeometryType.Polygon:
        return function(e2, t3, o4) {
          let n4;
          if (!o4 || 0 === o4.length) return [pairFlatCoordinates(e2, t3)];
          let i3 = 0, a = Array.from(o4).map((t4) => e2.slice(i3, i3 = t4 << 1));
          return t3 && (i3 = 0, n4 = Array.from(o4).map((e3) => t3.slice(i3, i3 = e3))), a.map((e3, t4) => pairFlatCoordinates(e3, n4 ? n4[t4] : void 0));
        }(n3, i2, t2.endsArray());
    }
  }(t, n2);
  return { type: GeometryType[n2], coordinates: i };
}

// node_modules/flatgeobuf/lib/mjs/geojson/feature.js
function fromFeature(t, o2, m) {
  let p = m.columns;
  return { type: "Feature", id: t, geometry: fromGeometry(o2.geometry(), m.geometryType), properties: parseProperties(o2, p) };
}
function validateFeatureData(view, size) {
  view.getUint32(0, true);
}
function parseFeatureData(offset, bytesAligned, header) {
  const bb = new ByteBuffer(bytesAligned);
  bb.setPosition(SIZE_PREFIX_LEN2);
  const feature = fromFeature(offset, Feature.getRootAsFeature(bb), header);
  return {
    ...feature,
    properties: {
      ...feature.properties,
      __byteLength: bytesAligned.byteLength,
      __offset: offset
    }
  };
}
function parseProperties2(bb, columns, offset) {
  const feature = Feature.getRootAsFeature(bb);
  const props = parseProperties(feature, columns);
  return {
    ...props,
    __byteLength: bb.capacity(),
    __offset: offset
  };
}
function parseByteSize(size) {
  if (size === void 0 || size === null) return void 0;
  if (typeof size === "number") return size;
  return bytes__default.default(size) ?? void 0;
}
var FlatGeobufSource = class {
  /**
   * Should not be called directly. Instead initialize using createSource(),
   * which will generate the necessary metadata and spatial index.
   */
  constructor(urlOrFetchRangeFn, header, index, featureDataOffset, maxCacheSize = DEFAULT_CACHE_SIZE, overfetchBytes, fileByteLength, pageSize) {
    if (typeof urlOrFetchRangeFn === "string") {
      this.url = urlOrFetchRangeFn;
    } else {
      this.fetchRangeFn = urlOrFetchRangeFn;
    }
    this.header = header;
    this.index = index;
    this.featureDataOffset = featureDataOffset;
    this.fetchManager = new FetchManager(
      urlOrFetchRangeFn,
      parseByteSize(maxCacheSize),
      this.featureDataOffset,
      fileByteLength,
      parseByteSize(pageSize)
    );
    this.overfetchBytes = parseByteSize(overfetchBytes);
  }
  /**
   * Get cache statistics
   */
  get cacheStats() {
    return this.fetchManager.cacheStats;
  }
  /**
   * Prefetch and cache all pages needed for features intersecting the envelope.
   * This uses getFeaturesAsync with warmCache:true under the hood to trigger
   * range fetches without parsing or yielding features.
   */
  async prefetch(bbox, options) {
    const warmOptions = {
      ...QUERY_PLAN_DEFAULTS,
      ...options,
      overfetchBytes: this.overfetchBytes ?? options?.overfetchBytes,
      // @ts-ignore - extend with warmCache flag for internal use
      warmCache: true
    };
    for await (const _ of this.getFeaturesAsync(bbox, warmOptions)) {
    }
  }
  /**
   * Clear the feature data cache
   */
  clearCache() {
    this.fetchManager.clearCache();
  }
  /**
   * Bounds of the source, as determined from the spatial index.
   */
  get bounds() {
    return {
      minX: this.index.minX,
      minY: this.index.minY,
      maxX: this.index.maxX,
      maxY: this.index.maxY
    };
  }
  /**
   * Size of the index in bytes, which approximates the size this data source
   * occupies in memory.
   */
  get indexSizeBytes() {
    return this.index.byteLength;
  }
  /**
   * Geometry type of the source.
   */
  get geometryType() {
    return GeometryType[this.header.geometryType];
  }
  /**
   * Get features within a bounding box. Features are streamed to minimize
   * memory usage. Each feature is deserialized to GeoJSON before being yielded.
   *
   * Memory usage is minimized by deserializing features to GeoJSON individually
   * before yielding them. If you need to minimize memory usage in an
   * environment like cloudflare workers, you need only concern yourself with
   * the memory usage of the binary bytes fetched + the GeoJSON size of only
   * the single largest feature being processed at any given time.
   *
   * @param bbox - Single bounding box or array of bounding boxes to query
   * @param options - Query options
   * @returns AsyncGenerator yielding GeoJSON features with metadata
   *
   * @example
   * ```typescript
   * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
   * for await (const feature of source.getFeaturesAsync(bbox)) {
   *   console.log(feature);
   * }
   * ```
   */
  async *getFeaturesAsync(bbox, options) {
    options = {
      ...QUERY_PLAN_DEFAULTS,
      ...options,
      overfetchBytes: this.overfetchBytes ?? options?.overfetchBytes
    };
    if (!Array.isArray(bbox)) {
      bbox = [bbox];
    }
    const offsets = [];
    for (const b of bbox) {
      if (!this.index) {
        throw new Error("Spatial index not available");
      }
      const results = await this.index.search(b.minX, b.minY, b.maxX, b.maxY);
      for (const result of results) {
        offsets.push(result);
      }
    }
    const plan = createQueryPlan(offsets, this.featureDataOffset, options);
    plan.requests.sort((a, b) => a.range[0] - b.range[0]);
    for await (const [data, offset] of executeQueryPlan(
      plan.requests,
      this.fetchManager.fetchRange.bind(this.fetchManager),
      options
    )) {
      if (options.warmCache) {
        continue;
      }
      const bytes3 = new Uint8Array(data.buffer);
      const bytesAligned = new Uint8Array(data.byteLength);
      bytesAligned.set(
        bytes3.slice(data.byteOffset, data.byteOffset + data.byteLength),
        0
      );
      const feature = parseFeatureData(offset, bytesAligned, this.header);
      yield feature;
    }
  }
  async countAndBytesForQuery(bbox, options) {
    if (!this.index) {
      throw new Error("Spatial index not available");
    }
    if (!Array.isArray(bbox)) {
      bbox = [bbox];
    }
    let offsetsSet = /* @__PURE__ */ new Set();
    let offsetAndLengths = [];
    for (const b of bbox) {
      const results = await this.index.search(b.minX, b.minY, b.maxX, b.maxY);
      for (const result of results) {
        const key = `${result[0]}-${result[1]}`;
        if (!offsetsSet.has(key)) {
          offsetsSet.add(key);
          offsetAndLengths.push(result);
        }
      }
    }
    const plan = createQueryPlan(
      offsetAndLengths,
      this.featureDataOffset,
      options ?? {}
    );
    return {
      bytes: plan.bytes,
      features: plan.features,
      requests: plan.requests.length
    };
  }
  /**
   * Scan all features in the source. Does not use the spatial index, but
   * rather fetches the entire feature data section and iterates through it.
   *
   * Features are not deserialized to GeoJSON until they are yielded, reducing
   * memory usage.
   *
   * @returns AsyncGenerator yielding GeoJSON features with metadata
   *
   * @example
   * ```typescript
   * for await (const feature of source.scanAllFeatures()) {
   *   console.log(feature);
   * }
   * ```
   */
  async *scanAllFeatures() {
    const data = await this.fetchManager.fetchRange([
      this.featureDataOffset,
      null
    ]);
    const view = new DataView(data);
    let offset = 0;
    while (offset < data.byteLength) {
      const size = view.getUint32(offset, true);
      const bytesAligned = new Uint8Array(data, offset, size + SIZE_PREFIX_LEN2);
      validateFeatureData(view);
      const feature = parseFeatureData(offset, bytesAligned, this.header);
      yield feature;
      offset += size + SIZE_PREFIX_LEN2;
    }
  }
  async *getFeatureProperties() {
    const data = await this.fetchManager.fetchRange([
      this.featureDataOffset,
      null
    ]);
    const view = new DataView(data);
    let offset = 0;
    while (offset < data.byteLength) {
      const size = view.getUint32(offset, true);
      const bytesAligned = new Uint8Array(data, offset, size + SIZE_PREFIX_LEN2);
      const bb = new ByteBuffer(bytesAligned);
      bb.setPosition(SIZE_PREFIX_LEN2);
      yield {
        properties: parseProperties2(bb, this.header.columns, offset),
        getFeature: () => parseFeatureData(offset, bytesAligned, this.header)
      };
      offset += size + SIZE_PREFIX_LEN2;
    }
  }
};
async function createSource(urlOrKey, options) {
  const fetchRangeFnOption = options?.fetchRangeFn;
  const maxCacheSize = parseByteSize(options?.maxCacheSize);
  const initialHeaderRequestLength = parseByteSize(options?.initialHeaderRequestLength) ?? HEADER_FETCH_SIZE;
  const overfetchBytes = parseByteSize(options?.overfetchBytes);
  const pageSize = parseByteSize(options?.pageSize);
  const fetchRange = fetchRangeFnOption && typeof fetchRangeFnOption === "function" ? (range) => {
    return fetchRangeFnOption(urlOrKey, range);
  } : (range) => {
    return fetch(urlOrKey, {
      headers: { Range: `bytes=${range[0]}-${range[1] ? range[1] : ""}` }
    }).then((response) => response.arrayBuffer());
  };
  let headerData = await fetchRange([0, initialHeaderRequestLength]);
  const view = new DataView(headerData);
  for (let i = 0; i < MAGIC_BYTES.length; i++) {
    if (view.getUint8(i) !== MAGIC_BYTES[i] && i < MAGIC_BYTES.length - 1) {
      throw new Error(
        "Invalid FlatGeobuf file (magic bytes mismatch). " + urlOrKey
      );
    }
  }
  const offset = MAGIC_BYTES.length + 4;
  const bb = new ByteBuffer(new Uint8Array(headerData, offset));
  const headerSize = view.getUint32(MAGIC_BYTES.length, true);
  const header = fromByteBuffer(bb);
  const featuresCount = header.featuresCount;
  const indexNodeSize = header.indexNodeSize;
  if (!indexNodeSize) {
    throw new Error("FlatGeobuf file does not contain a spatial index");
  }
  const rtreeDetails = calculatePackedRTreeDetails(
    featuresCount,
    indexNodeSize
  );
  const indexSize = rtreeDetails.nodesByteSize;
  const indexOffset = headerSize + MAGIC_BYTES.length + 4;
  if (headerData.byteLength < indexOffset + indexSize) {
    headerData = await fetchRange([0, indexOffset + indexSize]);
  }
  const indexData = headerData.slice(indexOffset, indexOffset + indexSize);
  const index = new RTreeIndex(indexData, rtreeDetails);
  let fileByteLength = void 0;
  try {
    const lastFeatureOffset = index.getLastFeatureOffset();
    const lastFeaturePrefixAbs = indexOffset + indexSize + lastFeatureOffset;
    const sizePrefixBuf = await fetchRange([
      lastFeaturePrefixAbs,
      lastFeaturePrefixAbs + SIZE_PREFIX_LEN2 - 1
    ]);
    const sizeView = new DataView(sizePrefixBuf);
    const lastFeatureSize = sizeView.getUint32(0, true);
    fileByteLength = lastFeaturePrefixAbs + SIZE_PREFIX_LEN2 + lastFeatureSize;
  } catch (e2) {
  }
  const source = new FlatGeobufSource(
    fetchRange,
    header,
    index,
    indexOffset + indexSize,
    maxCacheSize,
    overfetchBytes,
    fileByteLength,
    pageSize
  );
  return source;
}
var SourceCache = class {
  /**
   * Create a new SourceCache instance.
   *
   * @param sizeLimit - Maximum size of the cache, parseable by the bytes library.
   *                   Examples: '100MB', '1GB', '500KB'
   * @param options - Optional configuration object
   *   - onEvict: Callback called when a source is evicted from the cache. Receives (key, source, reason).
   *   - fetchRangeFn: Default fetch function to use when creating sources. Will be merged with options passed to get().
   *   - maxCacheSize: Default maximum cache size for sources. Will be merged with options passed to get().
   *   - initialHeaderRequestLength: Default initial header request length. Will be merged with options passed to get().
   *   - overfetchBytes: Default overfetch bytes. Will be merged with options passed to get().
   * @throws Error if sizeLimit is invalid
   */
  constructor(sizeLimit, options) {
    const size = bytes__default.default(sizeLimit);
    if (size === null) {
      throw new Error(`Invalid size limit: ${sizeLimit}`);
    }
    this.sizeLimitBytes = size;
    this.inFlightRequests = /* @__PURE__ */ new Map();
    this.onEvict = options?.onEvict;
    this.defaultOptions = {
      fetchRangeFn: options?.fetchRangeFn,
      maxCacheSize: options?.maxCacheSize,
      initialHeaderRequestLength: options?.initialHeaderRequestLength,
      overfetchBytes: options?.overfetchBytes
    };
    this.cache = new lruCache.LRUCache({
      maxSize: this.sizeLimitBytes,
      sizeCalculation: (source, key) => {
        const size2 = source.indexSizeBytes + source.cacheStats.maxSize;
        return size2;
      },
      dispose: (value, key, reason) => {
        if (this.onEvict) {
          this.onEvict(key, value, reason);
        }
      }
    });
  }
  /**
   * Get a FlatGeobufSource instance for the given key. If the source is already
   * cached, returns the cached instance. Otherwise, creates a new source and
   * caches it.
   *
   * @param key - URL or key to fetch the source from
   * @param options - Options for creating the source if it needs to be created. These will be merged with default options from the constructor.
   * @returns Promise resolving to a FlatGeobufSource instance
   *
   * @example
   * ```typescript
   * const sourceCache = new SourceCache('64mb');
   * // Basic usage with default options
   * const source = await sourceCache.get('https://example.com/data.fgb');
   *
   * // Customize feature data cache size
   * const source = await sourceCache.get('https://example.com/data.fgb', {
   *   maxCacheSize: 1024 * 1024 // 1MB feature cache
   * });
   *
   * // Use custom fetch implementation (e.g. for R2 bucket)
   * const source = await sourceCache.get('fgb-object-key', {
   *   fetchRangeFn: async (key, range) => {
   *     const response = await fetch(`https://my-bucket.r2.dev/${key}`, {
   *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
   *     });
   *     return response.arrayBuffer();
   *   }
   * });
   *
   * // With default fetch function set in constructor
   * const sourceCache = new SourceCache('64mb', {
   *   fetchRangeFn: async (key, range) => {
   *     const response = await fetch(`https://uploads.seasketch.org/${key}`, {
   *       headers: { Range: `bytes=${range[0]}-${range[1] ?? ''}` }
   *     });
   *     return response.arrayBuffer();
   *   }
   * });
   * // Now you can use get() without specifying fetchRangeFn each time
   * const source = await sourceCache.get('my-data.fgb');
   *
   * // Query features within a bounding box
   * const bbox = { minX: -180, minY: -90, maxX: 180, maxY: 90 };
   * for await (const feature of source.getFeaturesAsync(bbox)) {
   *   console.log(feature);
   * }
   * ```
   */
  async get(key, options) {
    const cached = this.cache.get(key);
    if (cached) {
      return cached;
    }
    const inFlightRequest = this.inFlightRequests.get(key);
    if (inFlightRequest) {
      return inFlightRequest;
    }
    const mergedOptions = {
      ...this.defaultOptions,
      ...options,
      maxCacheSize: options?.maxCacheSize || this.defaultOptions?.maxCacheSize || this.sizeLimitBytes / 4
    };
    const request = (async () => {
      try {
        const source = await createSource(key, mergedOptions);
        this.cache.set(key, source);
        return source;
      } finally {
        this.inFlightRequests.delete(key);
      }
    })();
    this.inFlightRequests.set(key, request);
    return request;
  }
};
/*! Bundled license information:

@repeaterjs/repeater/repeater.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/

exports.FlatGeobufSource = FlatGeobufSource;
exports.SourceCache = SourceCache;
exports.createSource = createSource;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map