/**
 * Byte offsets to fetch feature data from the fgb file, as [offset, length,
 * bbox].
 * The length is null if the feature is the last in the file.
 */
export type FeatureReference = [
  number,
  number | null,
  [number, number, number, number]
];

/**
 * Size of each node item in the R-tree index in bytes.
 * Consists of 4 float64 values (maxX, maxY, minX, minY) and 1 uint64 value (offset).
 */
export const NODE_ITEM_BYTE_LENGTH = 8 * 4 + 8;

/**
 * RTreeIndex provides spatial indexing for FlatGeobuf files.
 *
 * This implementation is inspired by flatbush but differs in that it does not
 * stream results. Instead, it fetches and reads the entire index at once. This approach
 * is simpler to implement and should have better performance for moderate
 * index sizes, but may need to be revised for very large indexes.
 *
 * The index is stored in a packed format, with each node containing:
 * - maxX, maxY, minX, minY (float64)
 * - offset (uint64)
 *
 * @example
 * ```typescript
 * const index = new RTreeIndex(data, details);
 * const results = await index.search(-180, -90, 180, 90);
 * ```
 */
export default class RTreeIndex {
  /** Minimum X coordinate of the entire index */
  minX: number;
  /** Minimum Y coordinate of the entire index */
  minY: number;
  /** Maximum X coordinate of the entire index */
  maxX: number;
  /** Maximum Y coordinate of the entire index */
  maxY: number;
  /** Total size of the index in bytes */
  byteLength: number;

  private view: DataView;
  private details: PackedRTreeDetails;

  /**
   * Creates a new RTreeIndex instance.
   *
   * @param data - The packed R-tree index data
   * @param details - Details about the R-tree structure. Generated by
   *   `calculatePackedRTreeDetails`.
   * @throws Error if data is empty or details are invalid
   */
  constructor(data: ArrayBuffer, details: PackedRTreeDetails) {
    this.details = details;

    if (!data.byteLength) {
      throw new Error("data is empty");
    }
    this.view = new DataView(data);
    this.byteLength = data.byteLength;
    if (details.featureCount === undefined) {
      throw new Error("numItems is undefined");
    } else if (isNaN(details.featureCount) || details.featureCount < 0) {
      throw new Error("numItems is invalid");
    }
    // Expose the bounds of the index so it can be used as a more accurate
    // envelope for this source
    const rootBounds = this.getNodeData(0);
    this.minX = rootBounds.minX;
    this.minY = rootBounds.minY;
    this.maxX = rootBounds.maxX;
    this.maxY = rootBounds.maxY;
  }

  /**
   * Search for features within a bounding box.
   *
   * The search is performed using a top-down traversal of the R-tree.
   * Results are returned as an array of [offset, length] tuples, where
   * length is null for the last feature in the file.
   *
   * @param minX - Minimum X coordinate of the search box
   * @param minY - Minimum Y coordinate of the search box
   * @param maxX - Maximum X coordinate of the search box
   * @param maxY - Maximum Y coordinate of the search box
   * @returns Promise resolving to array of [offset, length] tuples
   */
  search(minX: number, minY: number, maxX: number, maxY: number) {
    // Search starts at the root node, position 0. The search is a top-down
    let nodeIndex: number | undefined = 0;
    // The queue is used to store the node offsets that need to be searched
    const queue: number[] = [];
    const results: FeatureReference[] = [];

    while (nodeIndex !== undefined) {
      // Each node contains nodeSize children (by default 16). Here we calculate
      // the end position to stop at. This could simply be after processing
      // nodeSize nodes, but one node at each level could be only partially
      // filled, so we consult the levels array to check the end position.
      const end = Math.min(
        nodeIndex + this.details.nodeSize,
        // upperBound calculates the last position of the current level
        upperBound(nodeIndex, this.details.levels)
      );

      // Iterate over each child node. If it's a parent node match, add it to
      // the queue. If it's a leaf, add it to the results.
      for (let pos = nodeIndex; pos < end; pos++) {
        // Get the bounds and offset of the current node.
        const node = this.getNodeData(pos);

        // Test whether the current node is outside the search bounds. If so,
        // skip over it and continue processing the queue.
        if (
          maxX < node.minX ||
          maxY < node.minY ||
          minX > node.maxX ||
          minY > node.maxY
        ) {
          continue;
        }

        if (node.isLeaf) {
          // Need to get the end of the next leaf node, in addition to the
          // offset (starting position) so that range-requests can be made.
          // Since features are tightly packed, we just need the offset of the
          // next leaf. The end could be null (end of the file) if this is the
          // last leaf.
          const nextLeafPosition = pos + 1;
          let length: number | null = null;
          if (nextLeafPosition < this.details.numNodes) {
            const nextLeaf = this.getNodeData(nextLeafPosition);
            length = nextLeaf.offset - node.offset;
          }
          results.push([
            node.offset,
            length,
            [node.minX, node.minY, node.maxX, node.maxY],
          ]);
        } else {
          queue.push(Number(node.offset));
        }
      }
      // Get the next node to process from the queue
      nodeIndex = queue.pop();
    }
    return results;
  }

  /**
   * Get the data for a node at the specified index.
   *
   * @param index - Index of the node
   * @returns Object containing node bounds, offset, and whether it's a leaf node
   * @private
   */
  private getNodeData(index: number) {
    const byteIndex = index * NODE_ITEM_BYTE_LENGTH;
    return {
      minX: this.view.getFloat64(byteIndex, true),
      minY: this.view.getFloat64(byteIndex + 8, true),
      maxX: this.view.getFloat64(byteIndex + 16, true),
      maxY: this.view.getFloat64(byteIndex + 24, true),
      // The offset is a uint64, so we need to use getBigUint64. Theres no
      // sense in supporting files up to 9k terabytes, so we can safely use
      // Number() for ergonomics.
      offset: Number(this.view.getBigUint64(byteIndex + 32, true)),
      isLeaf: index >= this.details.levels[this.details.levels.length - 2],
    };
  }

  /**
   * Returns the byte offsets of all features in the index.
   * @returns Array of byte offsets
   */
  getFeatureOffsets() {
    const leafStart = this.details.levels[this.details.levels.length - 2];
    const offsets: number[] = [];
    for (let i = 0; i < this.details.featureCount; i++) {
      const byteIndex =
        i * NODE_ITEM_BYTE_LENGTH + leafStart * NODE_ITEM_BYTE_LENGTH;
      const offset = Number(this.view.getBigUint64(byteIndex + 32, true));
      offsets.push(offset);
    }
    return offsets;
  }

  /**
   * Returns the byte offset (relative to feature data start) of the last feature.
   */
  getLastFeatureOffset(): number {
    const lastIndex = this.details.numNodes - 1;
    const node = this.getNodeData(lastIndex);
    return Number(node.offset);
  }

  /**
   * Returns the byte offset (relative to feature data start) of the first feature.
   * This is determined by finding the first leaf node in the R-tree.
   */
  getFirstLeafNode() {
    const firstLeafIndex = this.details.levels[this.details.levels.length - 2];
    return this.getNodeData(firstLeafIndex);
  }
}

/**
 * Calculate the details of a packed R-tree index.
 *
 * Using the feature count and indexNodeSize, this function calculates:
 * - Number of nodes
 * - Number of bytes required to store the index
 * - Tree height
 * - Node offsets for each level in the index
 *
 * @param featureCount - The number of features in the index
 * @param indexNodeSize - The number of children per node
 * @returns PackedRTreeDetails object containing index structure information
 */
export function calculatePackedRTreeDetails(
  featureCount: number,
  indexNodeSize: number
): PackedRTreeDetails {
  const nodeSize = Math.min(Math.max(+indexNodeSize, 2), 65535);
  const numItems = featureCount;

  // Calculate number of nodes and tree height
  let n = numItems;
  let numNodes = 0;
  let treeHeight = 0;
  const nodesPerLevel = [n];
  do {
    treeHeight++;
    numNodes += n;
    n = Math.ceil(n / nodeSize);
    nodesPerLevel.push(n);
  } while (n > 1);

  // It appears I need to increment once more to account for the root node
  numNodes++;

  // find the index offsets for each level in top-down order
  const levels: number[] = [];
  let position = 0;
  while (nodesPerLevel.length) {
    n = nodesPerLevel.pop()!;
    position += n;
    levels.push(position);
  }

  return {
    nodeSize,
    numNodes,
    nodesByteSize: numNodes * NODE_ITEM_BYTE_LENGTH,
    treeHeight,
    levels,
    featureCount,
  };
}

/**
 * Binary search for the first value in the array bigger than the given value.
 * Borrowed from flatbush.
 *
 * @param value - The value to search for
 * @param arr - The sorted array to search in
 * @returns Index of the first value bigger than the given value
 * @private
 */
function upperBound(value: number, arr: number[]) {
  let i = 0;
  let j = arr.length - 1;
  while (i < j) {
    const m = (i + j) >> 1;
    if (arr[m] > value) {
      j = m;
    } else {
      i = m + 1;
    }
  }
  return arr[i];
}

/**
 * Details about the structure of a packed R-tree index.
 */
export interface PackedRTreeDetails {
  /** Number of features in the index */
  featureCount: number;
  /** Number of children per node */
  nodeSize: number;
  /** Total number of nodes in the tree */
  numNodes: number;
  /** Total size of the index in bytes */
  nodesByteSize: number;
  /** Height of the tree */
  treeHeight: number;
  /**
   * Array of level bounds in the index.
   *
   * The first element is the byte offset of the last node in the root level,
   * the last element is the byte offset of the last level before the leaves.
   *
   * Example:
   * ```
   * [ 40, 160, 1960, 30320, 484000 ]
   * ```
   *
   * In this example:
   * - Root level starts at 0
   * - First level starts at 40
   * - Leaf nodes start at 484000
   *
   * Unlike flatbush, the root node is included first, followed by subsequent
   * levels in the index, and finally the leaf nodes.
   */
  levels: number[];
}
