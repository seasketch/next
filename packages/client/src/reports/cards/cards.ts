import { ReportCardIcon } from "../ReportCard";
import { useContext } from "react";
import { FormLanguageContext } from "../../formElements/FormElement";
import { ReportCardConfigUpdateCallback } from "../registerCard";
import { DataUploadOutputType } from "../../generated/graphql";
import { Geostats } from "../../admin/data/GLStyleEditor/GeostatsModal";
import { RasterInfo } from "@seasketch/geostats-types";
import { SourceType } from "overlay-engine";
import { AnyLayer } from "mapbox-gl";

export type ProsemirrorBodyJSON = any;

export type ReportCardType =
  | "Attributes"
  | "TextBlock"
  | "Size"
  | "OverlappingAreas";

export type ReportingLayer = {
  stableId: string;
  title: string;
  tableOfContentsItemId: number;
  type: SourceType;
  url: string;
  size: number;
  meta: Geostats | RasterInfo;
  mapboxGlStyles: AnyLayer[];
  /**
   * Optionally, the field to group by.
   */
  groupBy?: string;
};

/**
 * A ReportCardConfiguration is a configuration object for a card that is
 * used to render a card in a report. It is used to determine the type of card,
 * its renderer component, and the componentSettings that are available.
 *
 * This configuration is used througout the client, and ultimately will need to
 * be stored in the database of project settings.
 */
export type ReportCardConfiguration<T> = {
  /**
   * Unique id of the card, usually generated by the server.
   */
  id: number;
  /**
   * Used to determine the type of card, its renderer component, and the
   * componentSettings that are available.
   */
  type: ReportCardType;
  /**
   * Almost all cards will have a main text body area.
   */
  body: ProsemirrorBodyJSON;
  /**
   * Alternate language settings for the card. Can be used with
   * useLocalizedComponentSetting to easily access component settings in the
   * appropriate language. (really? Might rely on FormLanguageContext. Might
   * need to update or create a new pattern)
   */
  alternateLanguageSettings: { [langCode: string]: any };
  /**
   * The settings for the card that are particular to it's type.
   */
  componentSettings: T;
  /**
   * The position of the card in the report. Cards are shown in ascending order
   * of position.
   */
  position: number;
  /**
   * The tint of the card.
   */
  tint?: string;
  /**
   * The icon of the card.
   */
  icon?: ReportCardIcon;
  /**
   * The reporting layers of the card.
   */
  reportingLayers: ReportingLayer[];
};

export type ReportTabConfiguration = {
  /**
   * Unique id of the tab, usually generated by the server.
   */
  id: number;
  /**
   * The title of the tab.
   */
  title: string;
  /**
   * The position of the tab in the report. Tabs are shown in ascending order
   * of position.
   */
  position: number;
  /**
   * The cards that are shown in the tab.
   */
  cards: ReportCardConfiguration<any>[];
  /**
   * Alternate language settings for the tab (e.g. title translations)
   */
  alternateLanguageSettings: { [langCode: string]: any };
};

/**
 * A ReportConfiguration is a configuration object for a report that is
 * used to render a report. It is used to determine the tabs that are shown
 * in the report, and the cards that are shown in each tab.
 *
 * Each sketch class has at least one ReportConfiguration, and multiple could be
 * used to support published vs unpublished changes, or even versioning of
 * reports.
 *
 */
export type ReportConfiguration = {
  /**
   * Unique id of the report, usually generated by the server.
   */
  id: number;
  /**
   * The tabs that are shown in the report. A single tab would indicate a
   * "no tabs" display without a tab bar.
   */
  tabs: ReportTabConfiguration[];
};

export type ReportCardProps<T extends ReportCardConfiguration<any>> = {
  config: T;
};

// Import card implementations

export function registerCards() {
  import("./SketchAttributesCard");
  import("./SizeCard");
  import("./OverlappingAreasCard");
  import("./TextBlockCard");
}

/**
 * Returns a localized card setting value. For EN, returns componentSettings[key] or fallback.
 * For non-EN, returns alternateLanguageSettings[lang][key] if present; otherwise falls back
 * to componentSettings[key] or fallback. Empty strings are treated as "not set" and will
 * fall back to the provided fallback value.
 */
export function useLocalizedCardSetting<
  TSettings extends Record<string, any>,
  K extends keyof TSettings
>(config: ReportCardConfiguration<TSettings>, key: K, fallback: any) {
  const lang = useContext(FormLanguageContext)?.lang?.code;
  if (lang && lang !== "EN") {
    const localized = config.alternateLanguageSettings?.[lang]?.[key as string];
    if (localized !== undefined && localized !== "") {
      return localized;
    }
  }
  const base = (config.componentSettings as any)?.[key as string];
  return base !== undefined && base !== "" ? base : fallback;
}

/**
 * Admin helpers for editing localized string fields on a ReportCard.
 * Provides input value (no EN fallback), placeholder (EN/default), and a setter
 * that merges edits without clobbering unrelated fields or other languages.
 */
export function useCardLocalizedStringAdmin(
  config: ReportCardConfiguration<any>,
  onUpdate: ReportCardConfigUpdateCallback
) {
  const lang = useContext(FormLanguageContext)?.lang?.code;

  const updateComponentSettings = (
    newSettings: Partial<Record<string, any>>
  ) => {
    onUpdate((prev) => {
      const previousSettings = {
        ...(config.componentSettings || {}),
        ...(prev.componentSettings || {}),
      } as Record<string, any>;
      return {
        ...prev,
        componentSettings: {
          ...previousSettings,
          ...newSettings,
        },
      };
    });
  };

  const getInputValue = (key: string): string => {
    if (lang && lang !== "EN") {
      const localized = config.alternateLanguageSettings?.[lang]?.[key];
      return typeof localized === "string" ? localized : "";
    }
    const base = (config.componentSettings as any)?.[key];
    return typeof base === "string" ? base : "";
  };

  const getPlaceholder = (key: string, defaultLabel: string): string => {
    if (lang && lang !== "EN") {
      const base = (config.componentSettings as any)?.[key];
      return typeof base === "string" && base.length > 0 ? base : defaultLabel;
    }
    return defaultLabel;
  };

  const setValue = (key: string, value: string) => {
    if (!lang || lang === "EN") {
      updateComponentSettings({ [key]: value });
    } else {
      onUpdate((prev) => {
        const previousAltAll = {
          ...(config.alternateLanguageSettings || {}),
          ...(prev.alternateLanguageSettings || {}),
        } as Record<string, any>;
        const previousAltForLang = {
          ...(config.alternateLanguageSettings?.[lang] || {}),
          ...(prev.alternateLanguageSettings?.[lang] || {}),
        } as Record<string, any>;
        return {
          ...prev,
          alternateLanguageSettings: {
            ...previousAltAll,
            [lang]: {
              ...previousAltForLang,
              [key]: value,
            },
          },
        };
      });
    }
  };

  return { getInputValue, getPlaceholder, setValue, updateComponentSettings };
}
