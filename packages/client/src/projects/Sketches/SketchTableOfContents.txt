import {
  SketchFolderDetailsFragment,
  SketchGeometryType,
  SketchTocDetailsFragment,
} from "../../generated/graphql";
import { useTranslation } from "react-i18next";
import { forwardRef, useCallback, useEffect, useMemo, useState } from "react";
import Skeleton from "../../components/Skeleton";
import { SketchAction } from "./useSketchActions";
import ContextMenuDropdown, {
  DropdownDividerProps,
} from "../../components/ContextMenuDropdown";
import { DropdownOption } from "../../components/DropdownButton";
import FolderItem, { FolderNodeDataProps, isFolderNode } from "./FolderItem";
import { DropTargetMonitor, useDrop } from "react-dnd";
import useUpdateSketchTableOfContentsDraggable from "./useUpdateSketchTableOfContentsItem";
import TreeV, { TreeItemI } from "../../components/TreeView";
import SketchItem, { isSketchNode, SketchNodeData } from "./SketchItem";

export default forwardRef<
  HTMLDivElement,
  {
    loading?: boolean;
    sketches: SketchTocDetailsFragment[];
    folders: SketchFolderDetailsFragment[];
    selectedIds: string[];
    expandedIds: string[];
    contextMenu?: {
      id: string;
      options: (DropdownOption | DropdownDividerProps)[];
      target: HTMLElement;
      offsetX: number;
    };
    onContextMenu: (
      node: TreeItemI<any>,
      target: HTMLElement,
      offsetX: number
    ) => void;
    onSelect: (
      metaKey: boolean,
      item: { id: string },
      isSelected: boolean
    ) => void;
    onExpand: (item: { id: string }, isExpanded: boolean) => void;
    reservedKeyCodes?: string[];
    onReservedKeyDown?: (keycode: string) => void;
    actions?: { create: SketchAction[]; edit: SketchAction[] };
    onActionSelected?: (action: SketchAction) => void;
  }
>(
  (
    {
      sketches,
      folders,
      expandedIds,
      onSelect,
      loading,
      reservedKeyCodes,
      onReservedKeyDown,
      actions,
      onActionSelected,
      onExpand,
      selectedIds,
      onContextMenu,
      contextMenu,
    },
    ref
  ) => {
    const { t } = useTranslation();
    const { dropFolder, dropSketch } =
      useUpdateSketchTableOfContentsDraggable();

    // useEffect(() => {
    //   const handler = () => setContextMenuTarget(null);
    //   if (contextMenuTarget) {
    //     const target = contextMenuTarget.target;
    //     target.addEventListener("blur", handler);
    //     document.addEventListener("click", handler);
    //     return () => {
    //       target.removeEventListener("blur", handler);
    //       document.removeEventListener("click", handler);
    //     };
    //   }
    // }, [contextMenuTarget]);

    const contextMenuOptions = useMemo(() => {
      const options: (DropdownOption | DropdownDividerProps)[] = [];
      if (actions && onActionSelected) {
        for (const action of actions.edit) {
          const { label, disabled, disabledForContextAction } = action;
          if (!disabledForContextAction) {
            options.push({
              label,
              disabled,
              onClick: () => onActionSelected(action),
            });
          }
        }
        const createActions = actions.create.filter(
          (a) => !a.disabledForContextAction
        );
        if (createActions.length) {
          options.push({ label: t("add new"), id: "add-new-divider" });
          for (const action of createActions) {
            const { id, label, disabled, disabledForContextAction } = action;
            if (!disabledForContextAction) {
              options.push({
                id,
                label,
                disabled,
                onClick: () => onActionSelected(action),
              });
            }
          }
        }
      }
      return options;
    }, [actions, onActionSelected, t]);

    const [{ canDrop, isOver }, drop] = useDrop(() => ({
      // The type (or types) to accept - strings or symbols
      accept: ["SketchFolder", "Sketch"],
      canDrop: (item, monitor) => {
        return (
          monitor.isOver({ shallow: true }) === true &&
          (Boolean(item.collectionId) || Boolean(item.folderId))
        );
      },
      // Props to collect
      collect: (monitor) => ({
        isOver: monitor.isOver({ shallow: true }),
        canDrop: monitor.canDrop(),
      }),
      drop: (
        item: {
          id: number;
          typeName: string;
          folderId?: number | null;
          collectionId?: number | null;
        },
        monitor: DropTargetMonitor<{ id: number; typeName: string }>
      ) => {
        if (!monitor.didDrop()) {
          (item.typeName === "SketchFolder" ? dropFolder : dropSketch)(
            item.id,
            {
              folderId: null,
              collectionId: null,
            }
          );
        }
      },
    }));

    // useEffect(() => {
    //   if (treeView.current) {
    //     treeView.current.onkeydown = (event) => {
    //       if (event.key === " ") {
    //         event.stopPropagation();
    //         // TODO: toggle visibility
    //         return;
    //       }
    //       if (
    //         reservedKeyCodes &&
    //         onReservedKeyDown &&
    //         reservedKeyCodes.indexOf(event.key) !== -1
    //       ) {
    //         event.stopPropagation();
    //         event.preventDefault();
    //         const view = treeView.current;
    //         setTimeout(() => {
    //           view?.blur();
    //         }, 100);
    //         onReservedKeyDown(event.key);
    //         return;
    //       }
    //       if (!event.metaKey && /^\w$/.test(event.key)) {
    //         event.stopPropagation();
    //       }
    //     };
    //   }
    // }, [treeView, reservedKeyCodes, onReservedKeyDown]);

    const onDragEnd = useCallback(
      (items: { type: "sketch" | "folder"; id: number }[]) => {
        for (const item of items) {
          if (item.type === "sketch") {
            const sketch = sketches.find((s) => s.id === item.id);
            if (sketch) {
              // eslint-disable-next-line i18next/no-literal-string
              onSelect(false, { id: `Sketch:${sketch.id}` }, true);
            } else {
              console.warn("didn't find sketch", item);
            }
          } else {
            const folder = folders.find((f) => f.id === item.id);
            if (folder) {
              // eslint-disable-next-line i18next/no-literal-string
              onSelect(false, { id: `SketchFolder:${folder.id}` }, true);
            } else {
              console.warn("didn't find folder", item);
            }
          }
        }
      },
      [folders, onSelect, sketches]
    );

    const onDropEnd = useCallback(
      (items: { type: "sketch" | "folder"; id: number }[]) => {
        for (const item of items) {
          if (item.type === "folder") {
            const folder = folders.find((f) => f.id === item.id);
            if (folder) {
              // eslint-disable-next-line i18next/no-literal-string
              onExpand({ id: `SketchFolder:${folder.id}` }, true);
            }
          }
        }
      },
      [onExpand, folders]
    );

    if (loading) {
      return (
        <div className="pt-2 space-y-2" ref={ref}>
          <Skeleton className="w-1/2 h-5" />
          <Skeleton className="w-2/3 h-5" />
          <Skeleton className="w-1/2 h-5" />
          <Skeleton className="w-2/3 h-5" />
          <Skeleton className="w-1/2 h-5" />
          <Skeleton className="w-2/3 h-5" />
          <Skeleton className="w-1/2 h-5" />
          <Skeleton className="w-2/3 h-5" />
        </div>
      );
    }

    // console.log({ expandedIds });

    return (
      <div
        ref={drop}
        className={
          isOver && canDrop
            ? "border-blue-200 rounded-md border pt-2 pl-5 bg-blue-50"
            : "pt-2 pl-5 border border-transparent"
        }
      >
        {/* {contextMenuTarget &&
          onActionSelected &&
          actions &&
          actions.edit.length > 0 && (
            <ContextMenuDropdown
              options={contextMenuOptions}
              // target={contextMenu.target}
              // offsetX={contextMenuTarget.offsetX}
            />
          )} */}
        <div>
          <TreeV
            onExpand={onExpand}
            expanded={expandedIds}
            onSelect={onSelect}
            selection={selectedIds}
            onContextMenu={onContextMenu}
            contextMenu={contextMenu}
            items={treeNodes}
            render={({ node, ...props }) => {
              if (isFolderNode(node) && props.children) {
                return (
                  <FolderItem
                    {...props}
                    node={node}
                    ChildGroup={props.ChildGroup}
                  />
                );
              } else if (isSketchNode(node)) {
                return <SketchItem {...props} node={node} />;
              } else {
                return <div>Unimplemented</div>;
              }
            }}
            ariaLabel="My Sketches"
            // contextMenuTargetRef={setContextMenuTarget}
            // onContextMenu={(e, data, isSelected) => {
            //   console.log({ x: e.clientX, y: e.clientY });
            //   var rect = e.currentTarget.getBoundingClientRect();
            //   var x = e.clientX - rect.left; //x position within the element.
            //   var y = e.clientY - rect.top; //y position within the element.
            //   if (!isSelected) {
            //     onSelect(e.metaKey, data, !isSelected);
            //   }

            //   const target = e.currentTarget;
            //   console.log("target", target, x, y);
            //   setContextMenuTarget({
            //     target: target as HTMLDivElement,
            //     offsetX: x,
            //   });
            //   e.preventDefault();
            // }}
          />
          {/* <TreeView
            ref={treeView}
            data={treeData.nodes}
            selectedIds={selectedIds}
            // multiSelect
            togglableSelect={true}
            expandedIds={expandedIds}
            onExpand={(props) => {
              const { element, isExpanded } = props;
              const data = treeData.items[element.id];
              onExpandedChange(data, isExpanded);
            }}
            onSelect={(props) => {
              const { element, isSelected } = props;
              const data = treeData.items[element.id];
              onSelectionChange(data, isSelected);
            }}
            clickAction="EXCLUSIVE_SELECT"
            aria-label={t("Your sketches")}
            nodeRenderer={({
              element,
              isExpanded,
              isDisabled,
              getNodeProps,
              level,
              handleExpand,
              isSelected,
              handleSelect,
              treeState,
            }) => {
              const data = treeData.items[element.id];
              const nodeProps = getNodeProps();
              if (data.__typename === "SketchFolder") {
                return (
                  <FolderItem
                    id={data.id}
                    name={data.name}
                    parentFolderId={data.folderId}
                    parentCollectionId={data.collectionId}
                    handleExpand={handleExpand}
                    handleSelect={handleSelect}
                    level={level}
                    nodeProps={nodeProps}
                    numChildren={element?.children?.length || 0}
                    isDisabled={isDisabled}
                    isExpanded={isExpanded}
                    isSelected={isSelected}
                    onContextMenu={(e) => {
                      var rect = e.currentTarget.getBoundingClientRect();
                      var x = e.clientX - rect.left; //x position within the element.
                      if (!isSelected) {
                        handleSelect(e);
                      }

                      const target = e.currentTarget;
                      setContextMenuTarget({
                        target: target as HTMLDivElement,
                        offsetX: x,
                      });
                      e.preventDefault();
                    }}
                    onDragEnd={onDragEnd}
                    onDropEnd={onDropEnd}
                  />
                );
              } else if (
                data.__typename === "Sketch" &&
                data.sketchClass?.geometryType !== SketchGeometryType.Collection
              ) {
                return (
                  <SketchItem
                    id={data.id}
                    name={data.name}
                    parentCollectionId={data.collectionId}
                    parentFolderId={data.folderId}
                    handleSelect={handleSelect}
                    level={level}
                    nodeProps={nodeProps}
                    isDisabled={isDisabled}
                    isSelected={isSelected}
                    onContextMenu={(e) => {
                      var rect = e.currentTarget.getBoundingClientRect();
                      var x = e.clientX - rect.left; //x position within the element.
                      if (!isSelected) {
                        handleSelect(e);
                      }

                      const target = e.currentTarget;
                      setContextMenuTarget({
                        target: target as HTMLDivElement,
                        offsetX: x,
                      });
                      e.preventDefault();
                    }}
                    onDragEnd={onDragEnd}
                  />
                );
              }
            }}
          /> */}
        </div>
      </div>
    );
  }
);
