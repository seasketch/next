import { FeatureCollection, Feature, Polygon, MultiPolygon, BBox } from "geojson";
export interface VectorFeature extends Feature<Polygon | MultiPolygon> {
    bbox: BBox;
}
export interface VectorDataSourceDetails {
    options: VectorDataSourceOptions;
    url: string;
}
export interface VectorDataSourceOptions {
    /**
     * Max number of feature bundles to keep in memory.
     * Calls to .fetch() will not return more than the contents these bundles, so
     * this acts as an effective limit on subsequent analysis.
     * @type {number}
     * @default 250
     * @memberof VectorDataSourceOptions
     */
    cacheSize: number;
    /**
     * Source will only preload bundles when the bounding box provided to hint()
     * contains less than hintPrefetchLimit bundles.
     * @type {number}
     * @default 8
     * @memberof VectorDataSourceOptions
     */
    hintPrefetchLimit: number;
    /**
     * When features are requested by fetch, bundled features with matching
     * union_id will be dissolved into a single feature. This dissolved feature is
     * expensive to create and so may be cached. A cache may contain more bundles
     * than needed, and this variable sets a cap on that number.
     *
     * @type {number}
     * @default 3
     * @memberof VectorDataSourceOptions
     */
    dissolvedFeatureCacheExcessLimit: number;
}
export declare const DEFAULTS: VectorDataSourceOptions;
interface DataSourceMetadata {
    name: string;
    project: string;
    homepage: string;
    version: number;
    description: string;
    index: IndexSource;
    compositeIndexes: CompositeIndexSource[];
}
interface IndexSource {
    length: number;
    bytes: number;
    location: string;
    rootDir: string;
}
interface CompositeIndexSource extends IndexSource {
    bbox: BBox;
    offset: number;
}
export interface FeatureTree {
    fid: Number;
    root: Node;
}
export interface Node {
    nodeId: Number;
    leaf?: VectorFeature;
    ancestors: number[];
    cutline?: number;
    children?: Node[];
}
export declare class VectorDataSource<T extends Feature> {
    options: VectorDataSourceOptions;
    metadata?: DataSourceMetadata;
    private url;
    private initPromise?;
    private initError?;
    private bundleIndex?;
    private pendingRequests;
    private cache;
    private tree;
    private dissolvedFeatureCache?;
    private needsRewinding?;
    /**
     * VectorDataSource aids client-side or lambda based geoprocessing tools fetch
     * data from binned static vector sources generated by @seasketch/datasources
     * commands.
     *
     * @param {string} url
     * @param {VectorDataSourceOptions} options
     * @memberof VectorDataSource
     */
    constructor(url: string, options?: Partial<VectorDataSourceOptions>);
    static clearRegisteredSources(): void;
    static getRegisteredSources(): VectorDataSourceDetails[];
    private fetchMetadata;
    private fetchBundleIndex;
    private identifyBundles;
    fetchBundle(id: number, priority?: "low" | "high"): Promise<FeatureCollection>;
    private removeFeaturesFromIndex;
    clear(): Promise<void>;
    private cancelLowPriorityRequests;
    /**
     * Triggers downloading of indexes and bundles for the defined extent. Bundle
     * data will only be downloaded if the number of bundles within the extent is
     * less than options.hintPrefetchLimit.
     *
     * An ideal use-case for this method is to update the datasource whenever a
     * user pans a web map in anticipation of using this source.
     *
     * @param {number} xmin
     * @param {number} ymin
     * @param {number} xmax
     * @param {number} ymax
     * @returns {Promise<void>} Resolves when all requests are complete
     * @memberof VectorDataSource
     */
    hint(bbox: BBox): Promise<void>;
    /**
     * Prefetch bundles for the given extent. If a Feature is provided, those
     * bundles that overlap will be prioritized for download first.
     *
     * This operation is *not* effected by `hintPrefetchLimit`. It's best used in
     * situations where the datasource will be used for analysis in the immediate
     * future. For example, when a user has started to draw a feature of interest
     * which will be overlaid.
     *
     * @param {number} minX
     * @param {number} minY
     * @param {number} maxX
     * @param {number} maxY
     * @param {Feature} [feature]
     * @returns {Promise<void>}
     * @memberof VectorDataSource
     */
    prefetch(bbox: BBox, feature?: Feature): Promise<void>;
    /**
     * Fetches bundles of features within bbox
     * @param bbox
     * @returns
     */
    fetch(bbox: BBox): Promise<T[]>;
    /**
     * Fetches bundles of subdivided Polygon or MultiPolygon features within bbox and merges
     * them back into their original features.  Merge performance is faster if passed an
     * additional unionProperty, a property that exists in each subdivided feature.
     */
    fetchUnion(bbox: BBox, unionProperty?: string): Promise<FeatureCollection<T["geometry"], T["properties"]>>;
    fetchOverlapping(feature: Feature): Promise<T[]>;
}
export {};
//# sourceMappingURL=index.d.ts.map